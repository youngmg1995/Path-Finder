{"version":3,"sources":["utils/perlin.js","static/android-chrome-512x512.png","static/Path-Finding.png","static/Unweighted.png","static/Weighted.png","static/Shortest-Path.png","static/Not-Shortest-Path.png","static/Heuristic.png","static/No-Heuristic.png","static/Hex-Grid.png","static/Start.png","static/Target.png","static/Empty.png","static/Weight.png","static/Wall.png","static/Searched.png","static/Extended.png","static/Final-Path.png","components/Tutorial.js","components/Dropdown.js","components/SliderDropdown.js","components/ControlPanel.js","utils/utils.js","utils/canvas-tools.js","components/Canvas.js","utils/algorithms.js","utils/animations.js","components/PathFinder.js","App.js","serviceWorker.js","index.js"],"names":["global","module","noise","Grad","x","y","z","this","prototype","dot2","dot3","grad3","p","perm","Array","gradP","seed","Math","floor","i","v","F2","sqrt","G2","G3","fade","t","lerp","a","b","simplex2","xin","yin","i1","j1","s","j","x0","y0","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","simplex3","zin","k1","i2","j2","k2","k","z0","z1","z2","x3","y3","z3","gi3","t3","perlin2","X","Y","n00","n01","n10","n11","u","perlin3","Z","n000","n001","n010","n011","n100","n101","n110","n111","w","exports","Tutorial","props","className","tutorialPage","alt","src","Logo","PathFinding","Weighted","Unweighted","Shortest","NotShortest","Heuristic","NoHeuristic","HexGrid","Start","Target","Empty","Weight","Wall","Searched","Extended","FinalPath","onClick","toggleTutorial","event","changePage","icon","faAngleDoubleRight","faAngleDoubleLeft","Dropdown","state","listOpen","headerTitle","title","options","windowState","setState","prevState","key","toggleList","document","addEventListener","escapeList","backgroundColor","fontColor","style","color","faAngleUp","size","transform","faAngleDown","map","item","id","callBack","selected","faCheck","React","Component","onClickOutside","SliderDropdown","value","hexSize","target","window","innerWidth","innerHeight","type","orient","min","max","onInput","changeValue","onMouseUp","submitValue","onKeyDown","onTouchEnd","ControlPanel","algorithm","speed","tool","mazes","clear","temp","slice","length","toggleSelected","showControls","changeHexSize","drawMaze","clearBoard","running","clickEvent","stopSearch","startSearch","faPause","faPlay","DIRECTIONS","isSameNode","node1","node2","nodeOnBoard","node","xUnits","yUnits","isValidNode","board","findNeighbors","directions","neighbors","change","neighbor","push","manhattanDistance","hexCoord1","hexCoordinates","hexCoord2","dx","dy","sign","abs","ceil2","scalarProd","vectorDiff","v1","v2","vectorSum","vectorAngle","angle","atan","PI","minHeap","lessThan","heap","minValue","shift","unshift","pop","disjointSet","dictionary","hasOwnProperty","parent","xRoot","find","yRoot","shuffleArray","array","arrayCopy","random","getRandomNode","offLimitsSet","randomNode","has","getRandomWallNode","getRandomNeighbor","parseKey","filter","drawLine","startNode","endNode","lineWidth","xOffset","yOffset","canvasRef","canvasUpdates","N","calcHexCenter","startPos","V","line","n","nearestHex","targetNode","Object","assign","fill","object","updateID","moveStart","oldNode","newNode","oldState","moveTarget","drawWeight","pos","sideLength","h","w1","w2","rw","r1","cx","current","getContext","path","beginPath","fillStyle","moveTo","lineTo","closePath","ringCenter","arc","stroke","drawHex","calcHexPath","fillHex","getPointerNode","domNode","rect","getBoundingClientRect","clientX","left","clientY","top","J","I","theta","cos","sin","calcUnits","canvasWidth","canvasHeight","initializeBoard","offset","initializeCanvas","split","parseInt","Canvas","width","height","updateNode","nextProps","prevProps","clearRect","componentDidMount","startPosition","c","oldPos","newPos","drawStartPos","drawNode","drawStart","drawTarget","ref","onMouseDown","downEvent","onTouchStart","startEvent","randomWalk","isRunning","searchUpdates","startTime","Date","getTime","currentNode","lastNode","newState","concat","depthFirst","queue","visitedNodes","Set","currentPath","add","newPath","breadthFirst","hillClimbing","sort","beamSearch","bestFirst","path1","path2","distance","insert","pathWeights","branchNBound","bestDistance","Infinity","bestPath","newDistance","aStarSearch","estimatedDistance","modifiedAStar","console","log","randomWalls","mazePath","dungeon","pathUpdates","randomWeights","depthFirstMaze","nodesToAdd","breadthFirstMaze","kruskalsMaze","unVisitedNodes","pathNodes","disjointPaths","roots","rootsSet","makeSet","union","primsMaze","startFound","targetFound","huntAndKill","newRandomWalk","randomDLA","pathNeighbors","brownianNode","wallDLA","cellularDungeon","newDungeon","wallCount","reduce","state1","state2","simplexCaves","ceil","thresholdFunction","searchSpeed","0","1","2","3","4","drawPathSpeed","moveDownPathSpeed","victorySpeed","drawMazeSpeed","pathFinderAnimation","pathFinder","hexsPerSecond","lastTime","currentStart","steps","totalHexs","requestAnimationFrame","frame","time","start","boardUpdates","update","updateAnimation","totalSteps","totalTime","prevStartNode","prevEndNode","endPos","prevNode","radiansPerSecond","targetPos","startAngle","pos1","pos2","nodeDistance","victoryAnimation","moveDownPathAnimation","drawPathAnimation","searchAnimation","mazeAnimation","mazeID","mazeBuilder","clearTheWay","lightWeightBaby","doTheJohnWall","PathFinder","getWindowState","createRef","showTutorial","handleResize","stateUpdate","button","onMove","onMoveType","canvas","origNode","move","moveEvent","buttons","removeEventListener","oldStart","newStart","oldTarget","newTarget","preventDefault","touches","end","endEvent","currentState","includes","direction","faBars","toggleControls","5","6","7","startPathFinder","stopPathFinder","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.0ff2808f.chunk.js","sourcesContent":["/*\r\n * A speed-improved perlin and simplex noise algorithms for 2D.\r\n *\r\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\r\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\r\n * Better rank ordering method by Stefan Gustavson in 2012.\r\n * Converted to Javascript by Joseph Gentle.\r\n *\r\n * Version 2012-03-09\r\n *\r\n * This code was placed in the public domain by its original author,\r\n * Stefan Gustavson. You may use it as you see fit, but\r\n * attribution is appreciated.\r\n *\r\n */\r\n\r\n(function(global){\r\n    var module = global.noise = {};\r\n  \r\n    function Grad(x, y, z) {\r\n      this.x = x; this.y = y; this.z = z;\r\n    }\r\n    \r\n    Grad.prototype.dot2 = function(x, y) {\r\n      return this.x*x + this.y*y;\r\n    };\r\n  \r\n    Grad.prototype.dot3 = function(x, y, z) {\r\n      return this.x*x + this.y*y + this.z*z;\r\n    };\r\n  \r\n    var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\r\n                 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\r\n                 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\r\n  \r\n    var p = [151,160,137,91,90,15,\r\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\r\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\r\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\r\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\r\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\r\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\r\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\r\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\r\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\r\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\r\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\r\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\r\n    // To remove the need for index wrapping, double the permutation table length\r\n    var perm = new Array(512);\r\n    var gradP = new Array(512);\r\n  \r\n    // This isn't a very good seeding function, but it works ok. It supports 2^16\r\n    // different seed values. Write something better if you need more seeds.\r\n    module.seed = function(seed) {\r\n      if(seed > 0 && seed < 1) {\r\n        // Scale the seed out\r\n        seed *= 65536;\r\n      }\r\n  \r\n      seed = Math.floor(seed);\r\n      if(seed < 256) {\r\n        seed |= seed << 8;\r\n      }\r\n  \r\n      for(var i = 0; i < 256; i++) {\r\n        var v;\r\n        if (i & 1) {\r\n          v = p[i] ^ (seed & 255);\r\n        } else {\r\n          v = p[i] ^ ((seed>>8) & 255);\r\n        }\r\n  \r\n        perm[i] = perm[i + 256] = v;\r\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\r\n      }\r\n    };\r\n  \r\n    module.seed(0);\r\n  \r\n    /*\r\n    for(var i=0; i<256; i++) {\r\n      perm[i] = perm[i + 256] = p[i];\r\n      gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\r\n    }*/\r\n  \r\n    // Skewing and unskewing factors for 2, 3, and 4 dimensions\r\n    var F2 = 0.5*(Math.sqrt(3)-1);\r\n    var G2 = (3-Math.sqrt(3))/6;\r\n  \r\n    var F3 = 1/3;\r\n    var G3 = 1/6;\r\n  \r\n    // 2D simplex noise\r\n    module.simplex2 = function(xin, yin) {\r\n      var n0, n1, n2; // Noise contributions from the three corners\r\n      // Skew the input space to determine which simplex cell we're in\r\n      var s = (xin+yin)*F2; // Hairy factor for 2D\r\n      var i = Math.floor(xin+s);\r\n      var j = Math.floor(yin+s);\r\n      var t = (i+j)*G2;\r\n      var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n      var y0 = yin-j+t;\r\n      // For the 2D case, the simplex shape is an equilateral triangle.\r\n      // Determine which simplex we are in.\r\n      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\r\n      if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\r\n        i1=1; j1=0;\r\n      } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\r\n        i1=0; j1=1;\r\n      }\r\n      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\r\n      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\r\n      // c = (3-sqrt(3))/6\r\n      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\r\n      var y1 = y0 - j1 + G2;\r\n      var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\r\n      var y2 = y0 - 1 + 2 * G2;\r\n      // Work out the hashed gradient indices of the three simplex corners\r\n      i &= 255;\r\n      j &= 255;\r\n      var gi0 = gradP[i+perm[j]];\r\n      var gi1 = gradP[i+i1+perm[j+j1]];\r\n      var gi2 = gradP[i+1+perm[j+1]];\r\n      // Calculate the contribution from the three corners\r\n      var t0 = 0.5 - x0*x0-y0*y0;\r\n      if(t0<0) {\r\n        n0 = 0;\r\n      } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\r\n      }\r\n      var t1 = 0.5 - x1*x1-y1*y1;\r\n      if(t1<0) {\r\n        n1 = 0;\r\n      } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\r\n      }\r\n      var t2 = 0.5 - x2*x2-y2*y2;\r\n      if(t2<0) {\r\n        n2 = 0;\r\n      } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\r\n      }\r\n      // Add contributions from each corner to get the final noise value.\r\n      // The result is scaled to return values in the interval [-1,1].\r\n      return 70 * (n0 + n1 + n2);\r\n    };\r\n  \r\n    // 3D simplex noise\r\n    module.simplex3 = function(xin, yin, zin) {\r\n      var n0, n1, n2, n3; // Noise contributions from the four corners\r\n  \r\n      // Skew the input space to determine which simplex cell we're in\r\n      var s = (xin+yin+zin)*F3; // Hairy factor for 2D\r\n      var i = Math.floor(xin+s);\r\n      var j = Math.floor(yin+s);\r\n      var k = Math.floor(zin+s);\r\n  \r\n      var t = (i+j+k)*G3;\r\n      var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n      var y0 = yin-j+t;\r\n      var z0 = zin-k+t;\r\n  \r\n      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\r\n      // Determine which simplex we are in.\r\n      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\r\n      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\r\n      if(x0 >= y0) {\r\n        if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\r\n        else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\r\n        else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\r\n      } else {\r\n        if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\r\n        else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\r\n        else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\r\n      }\r\n      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\r\n      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\r\n      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\r\n      // c = 1/6.\r\n      var x1 = x0 - i1 + G3; // Offsets for second corner\r\n      var y1 = y0 - j1 + G3;\r\n      var z1 = z0 - k1 + G3;\r\n  \r\n      var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\r\n      var y2 = y0 - j2 + 2 * G3;\r\n      var z2 = z0 - k2 + 2 * G3;\r\n  \r\n      var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\r\n      var y3 = y0 - 1 + 3 * G3;\r\n      var z3 = z0 - 1 + 3 * G3;\r\n  \r\n      // Work out the hashed gradient indices of the four simplex corners\r\n      i &= 255;\r\n      j &= 255;\r\n      k &= 255;\r\n      var gi0 = gradP[i+   perm[j+   perm[k   ]]];\r\n      var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\r\n      var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\r\n      var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\r\n  \r\n      // Calculate the contribution from the four corners\r\n      var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\r\n      if(t0<0) {\r\n        n0 = 0;\r\n      } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\r\n      }\r\n      var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\r\n      if(t1<0) {\r\n        n1 = 0;\r\n      } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\r\n      }\r\n      var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\r\n      if(t2<0) {\r\n        n2 = 0;\r\n      } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\r\n      }\r\n      var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\r\n      if(t3<0) {\r\n        n3 = 0;\r\n      } else {\r\n        t3 *= t3;\r\n        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\r\n      }\r\n      // Add contributions from each corner to get the final noise value.\r\n      // The result is scaled to return values in the interval [-1,1].\r\n      return 32 * (n0 + n1 + n2 + n3);\r\n  \r\n    };\r\n  \r\n    // ##### Perlin noise stuff\r\n  \r\n    function fade(t) {\r\n      return t*t*t*(t*(t*6-15)+10);\r\n    }\r\n  \r\n    function lerp(a, b, t) {\r\n      return (1-t)*a + t*b;\r\n    }\r\n  \r\n    // 2D Perlin Noise\r\n    module.perlin2 = function(x, y) {\r\n      // Find unit grid cell containing point\r\n      var X = Math.floor(x), Y = Math.floor(y);\r\n      // Get relative xy coordinates of point within that cell\r\n      x = x - X; y = y - Y;\r\n      // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n      X = X & 255; Y = Y & 255;\r\n  \r\n      // Calculate noise contributions from each of the four corners\r\n      var n00 = gradP[X+perm[Y]].dot2(x, y);\r\n      var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\r\n      var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\r\n      var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\r\n  \r\n      // Compute the fade curve value for x\r\n      var u = fade(x);\r\n  \r\n      // Interpolate the four results\r\n      return lerp(\r\n          lerp(n00, n10, u),\r\n          lerp(n01, n11, u),\r\n         fade(y));\r\n    };\r\n  \r\n    // 3D Perlin Noise\r\n    module.perlin3 = function(x, y, z) {\r\n      // Find unit grid cell containing point\r\n      var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\r\n      // Get relative xyz coordinates of point within that cell\r\n      x = x - X; y = y - Y; z = z - Z;\r\n      // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n      X = X & 255; Y = Y & 255; Z = Z & 255;\r\n  \r\n      // Calculate noise contributions from each of the eight corners\r\n      var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\r\n      var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\r\n      var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\r\n      var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\r\n      var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\r\n      var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\r\n      var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\r\n      var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\r\n  \r\n      // Compute the fade curve value for x, y, z\r\n      var u = fade(x);\r\n      var v = fade(y);\r\n      var w = fade(z);\r\n  \r\n      // Interpolate\r\n      return lerp(\r\n          lerp(\r\n            lerp(n000, n100, u),\r\n            lerp(n001, n101, u), w),\r\n          lerp(\r\n            lerp(n010, n110, u),\r\n            lerp(n011, n111, u), w),\r\n         v);\r\n    };\r\n  \r\n  })(this);","module.exports = __webpack_public_path__ + \"static/media/android-chrome-512x512.fce8419f.png\";","module.exports = __webpack_public_path__ + \"static/media/Path-Finding.e3278bc7.png\";","module.exports = __webpack_public_path__ + \"static/media/Unweighted.51b5ed7d.png\";","module.exports = __webpack_public_path__ + \"static/media/Weighted.84d3352f.png\";","module.exports = __webpack_public_path__ + \"static/media/Shortest-Path.932ee3fe.png\";","module.exports = __webpack_public_path__ + \"static/media/Not-Shortest-Path.5e2b6004.png\";","module.exports = __webpack_public_path__ + \"static/media/Heuristic.b2f0461b.png\";","module.exports = __webpack_public_path__ + \"static/media/No-Heuristic.e17a6ffa.png\";","module.exports = __webpack_public_path__ + \"static/media/Hex-Grid.6ba570cb.png\";","module.exports = __webpack_public_path__ + \"static/media/Start.2ecc2a39.png\";","module.exports = __webpack_public_path__ + \"static/media/Target.0b8f7753.png\";","module.exports = __webpack_public_path__ + \"static/media/Empty.a9973a9f.png\";","module.exports = __webpack_public_path__ + \"static/media/Weight.37d2f594.png\";","module.exports = __webpack_public_path__ + \"static/media/Wall.6f4cad92.png\";","module.exports = __webpack_public_path__ + \"static/media/Searched.0ba80aec.png\";","module.exports = __webpack_public_path__ + \"static/media/Extended.d0a9dbe2.png\";","module.exports = __webpack_public_path__ + \"static/media/Final-Path.9a1c54d3.png\";","import React from 'react';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleDoubleLeft, faAngleDoubleRight } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\n/* Images */\r\n/*========*/\r\n// Page 1\r\nimport Logo from \"../static/android-chrome-512x512.png\";\r\n// Page 2\r\nimport PathFinding from \"../static/Path-Finding.png\";\r\nimport Unweighted from \"../static/Unweighted.png\";\r\nimport Weighted from \"../static/Weighted.png\";\r\nimport Shortest from \"../static/Shortest-Path.png\";\r\nimport NotShortest from \"../static/Not-Shortest-Path.png\";\r\nimport Heuristic from \"../static/Heuristic.png\";\r\nimport NoHeuristic from \"../static/No-Heuristic.png\";\r\n// Page 4\r\nimport HexGrid from \"../static/Hex-Grid.png\";\r\nimport Start from \"../static/Start.png\";\r\nimport Target from \"../static/Target.png\";\r\nimport Empty from \"../static/Empty.png\";\r\nimport Weight from \"../static/Weight.png\";\r\nimport Wall from \"../static/Wall.png\";\r\nimport Searched from \"../static/Searched.png\";\r\nimport Extended from \"../static/Extended.png\";\r\nimport FinalPath from \"../static/Final-Path.png\";\r\n\r\n\r\nfunction Tutorial(props) {\r\n    return (\r\n        <div className=\"Tutorial-Outer-Wrapper\">\r\n            <div className=\"Tutorial-Inner-Wrapper\">\r\n                <div className=\"Tutorial-Page-Indicator\">\r\n                    {props.tutorialPage} / 8\r\n                </div>\r\n                {props.tutorialPage === 1 && \r\n                    <div className=\"Tutorial-Page-1\">\r\n                        <div className=\"Tutorial-Header-Spacer\"></div>\r\n                        <h1 className=\"Tutorial-Page-Header\">Tutorial</h1>\r\n                        <div className=\"Tutorial-Page-Content\">\r\n                            <h3 className=\"Page-Sub-Header\">Welcome to Path-Finder the React App for Visualizing Path-Finding Algorithms!!!</h3>\r\n                            <p className=\"Page-Instructions\">This tutorial will instruct you on how to use the App. When finished hit \"Exit Tutorial\" to get started.</p>\r\n                            <div className=\"Image-Wrapper\"><img className=\"Path-Finder-Logo\" alt=\"Logo\" src={Logo}/></div>\r\n                        </div>\r\n                    </div>\r\n                }\r\n                {props.tutorialPage === 2 && \r\n                    <div className=\"Tutorial-Page-2\">\r\n                        <div className=\"Tutorial-Header-Spacer\"></div>\r\n                        <h1 className=\"Tutorial-Page-Header\">Path-Finding</h1>\r\n                        <div className=\"Tutorial-Page-Content\">\r\n                            <h3 className=\"Page-Sub-Header\">What is a Path-Finding Algorithm?</h3>\r\n                            <p className=\"Page-Instructions-1\">Path-finding algorithms are computer programs used to search for paths from one place to another.</p>\r\n                            <div className=\"Image-Wrapper-1\"><img className=\"Image-1\" alt=\"loading...\" src={PathFinding}/></div>\r\n                            <p className=\"Page-Instructions-2\">Path-finding algorithms come in two flavors <b>Weighted</b> and <b>Unweighted</b>. Unweighted algorithms simply account for the number of moves from one node to another, while Weighted algorithms also take into account additional costs associated with each move. </p>\r\n                            <div className=\"Content-Box-1\">\r\n                                <div className=\"Image-Wrapper-2\"><b>Weighted</b><img className=\"Image-2\" alt=\"loading...\" src={Weighted}/></div>\r\n                                <div className=\"Image-Wrapper-3\"><b>Unweighted</b><img className=\"Image-3\" alt=\"loading...\" src={Unweighted}/></div>\r\n                            </div>\r\n                            <p className=\"Page-Instructions-3\">Some algorithms guarantee the shortest path possible will always be found, while others do not.</p>\r\n                            <div className=\"Content-Box-2\">\r\n                                <div className=\"Image-Wrapper-4\"><b>Shortest Path</b><img className=\"Image-4\" alt=\"loading...\" src={Shortest}/></div>\r\n                                <div className=\"Image-Wrapper-5\"><b>Not Shortest Path</b><img className=\"Image-5\" alt=\"loading...\" src={NotShortest}/></div>\r\n                            </div>\r\n                            <p className=\"Page-Instructions-4\">To be more efficient, some algorithms even utilitze a distance heuristic to incentivise the path to move closer to the target rather than away from it.</p>\r\n                            <div className=\"Content-Box-3\">\r\n                                <div className=\"Image-Wrapper-6\"><b>Uses Heuristic</b><img className=\"Image-6\" alt=\"loading...\" src={Heuristic}/></div>\r\n                                <div className=\"Image-Wrapper-7\"><b>No Heuristic</b><img className=\"Image-7\" alt=\"loading...\" src={NoHeuristic}/></div>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                }\r\n                {props.tutorialPage === 3 && \r\n                    <div className=\"Tutorial-Page-3\">\r\n                        <div className=\"Tutorial-Header-Spacer\"></div>\r\n                        <h1 className=\"Tutorial-Page-Header\">Algorithms</h1>\r\n                        <div className=\"Tutorial-Page-Content\">\r\n                            <h3 className=\"Page-Sub-Header\">Which Algorithm Should I Choose?</h3>\r\n                            <p className=\"Page-Instructions\">Some algorithms are more sophisticated than others. Below is a short description of each technique to help you decide on which to use.</p>\r\n                            <h2 className=\"Content-Header-1\">Unweighted</h2>\r\n                            <p className=\"Algorithm-1\"><b>Random Walk:</b> Wanders around the board randomly, even over previously visited nodes, until we happen to find the target by chance. Funny, but not practical.</p>\r\n                            <p className=\"Algorithm-2\"><b>Depth-First Search:</b> Searches down the same path until the target is found or no options available. Inefficient and results in long winding paths.</p>\r\n                            <p className=\"Algorithm-3\"><b>Breadth-First Search:</b> Always searches the nodes closest to the start first, spreading out like a wave. Inefficient, but guaranteed to find the shortest path.</p>\r\n                            <p className=\"Algorithm-4\"><b>Hill Climbing:</b> Like depth-first search, but uses a distance heuristic to extend the path towards the target. More efficient, but still likely to produce terrible paths.</p>\r\n                            <p className=\"Algorithm-5\"><b>Beam Search (w=2):</b> Like breadth-first search, but uses a distance heuristic to limit the extensions of the closest node to the two directions closest to the target. More efficient, but does not guarantee the shortest path.</p>\r\n                            <p className=\"Algorithm-6\"><b>Best-First Search:</b> Like breadth-first search, but uses a distance heuristic to always extend the node closest to the target rather than the node closest to the start. Very efficient, but does not guarantee the shortest path.</p>\r\n                            <h2 className=\"Content-Header-2\">Weighted</h2>\r\n                            <p className=\"Algorithm-7\"><b>Branch & Bound:</b> Also referred to as Dijkstra's algorithm, this is the weighted equivalent of breadth-first search. Inefficient but guarantees the least costly path.</p>\r\n                            <p className=\"Algorithm-8\"><b>A* Search:</b> Like branch & bound, but uses a distance heuristic to encourage searching down paths in the direction of the target first. Efficient and guarantees the least costly path making it hands down the best algorithm.</p>\r\n                        </div>\r\n                    </div>\r\n                }\r\n                {props.tutorialPage === 4 && \r\n                    <div className=\"Tutorial-Page-4\">\r\n                        <div className=\"Tutorial-Header-Spacer\"></div>\r\n                        <h1 className=\"Tutorial-Page-Header\">Hex Board</h1>\r\n                        <div className=\"Tutorial-Page-Content\">\r\n                            <h3 className=\"Page-Sub-Header\">How We Will Visualize Our Path-Finding Algorithms</h3>\r\n                            <p className=\"Page-Instructions-1\">To visualize our algorithms we will be using a hex grid. Each hex will represent a unique node and from each node we can move to any of its 6 neighboring hexes.</p>\r\n                            <div className=\"Image-Wrapper-1\"><img className=\"Image-1\" alt=\"loading...\" src={HexGrid}/></div>\r\n                            <p className=\"Page-Instructions-2\">Each algorithm will attempt to find a path on our hex grid from the <b>Start</b> node to the <b>Target</b> node. </p>\r\n                            <div className=\"Content-Box-1\">\r\n                                <div className=\"Image-Wrapper-2\"><b>Start</b><img className=\"Image-2\" alt=\"loading...\" src={Start}/></div>\r\n                                <div className=\"Image-Wrapper-3\"><b>Target</b><img className=\"Image-3\" alt=\"loading...\" src={Target}/></div>\r\n                            </div>\r\n                            <p className=\"Page-Instructions-3\">While searching for a path, our algorithms will encounter 3 types of nodes: <b>Empty</b> nodes, <b>Weighted</b> nodes, and <b>Wall</b> nodes. Empty nodes are the easiest to move through with a cost of 1, weighted nodes are more difficult to move through with a cost of 10, and wall nodes are impenetrable with a cost of {\"\\u221E\"}.</p>\r\n                            <div className=\"Content-Box-2\">\r\n                                <div className=\"Image-Wrapper-4\"><b>Empty</b><img className=\"Image-4\" alt=\"loading...\" src={Empty}/></div>\r\n                                <div className=\"Image-Wrapper-5\"><b>Weighted</b><img className=\"Image-5\" alt=\"loading...\" src={Weight}/></div>\r\n                                <div className=\"Image-Wrapper-5\"><b>Wall</b><img className=\"Image-5\" alt=\"loading...\" src={Wall}/></div>\r\n                            </div>\r\n                            <p className=\"Page-Instructions-4\">To help visualize how the path-finding algorithms search for the target, we will color each node as it is operated on. Nodes are colored purple when checked to see if they are the target, blue when the path is extended to that node, and yellow if the node is included in the final path.</p>\r\n                            <div className=\"Content-Box-3\">\r\n                                <div className=\"Image-Wrapper-6\"><b>Searched</b><img className=\"Image-6\" alt=\"loading...\" src={Searched}/></div>\r\n                                <div className=\"Image-Wrapper-7\"><b>Extended</b><img className=\"Image-7\" alt=\"loading...\" src={Extended}/></div>\r\n                                <div className=\"Image-Wrapper-8\"><b>Final Path</b><img className=\"Image-8\" alt=\"loading...\" src={FinalPath}/></div>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                }\r\n                {props.tutorialPage === 5 && \r\n                    <div className=\"Tutorial-Page-5\">\r\n                        <div className=\"Tutorial-Header-Spacer\"></div>\r\n                        <h1 className=\"Tutorial-Page-Header\">Controls</h1>\r\n                        <div className=\"Tutorial-Page-Content\">\r\n                        </div>\r\n                    </div>\r\n                }\r\n                {props.tutorialPage === 6 && \r\n                    <div className=\"Tutorial-Page-6\">\r\n                        <div className=\"Tutorial-Header-Spacer\"></div>\r\n                        <h1 className=\"Tutorial-Page-Header\">Drawing</h1>\r\n                        <div className=\"Tutorial-Page-Content\">\r\n                            \r\n                        </div>\r\n                    </div>\r\n                }\r\n                {props.tutorialPage === 7 && \r\n                    <div className=\"Tutorial-Page-7\">\r\n                        <div className=\"Tutorial-Header-Spacer\"></div>\r\n                        <h1 className=\"Tutorial-Page-Header\">Mazes</h1>\r\n                        <div className=\"Tutorial-Page-Content\">\r\n                            \r\n                        </div>\r\n                    </div>\r\n                }\r\n                {props.tutorialPage === 8 && \r\n                    <div className=\"Tutorial-Page-8\">\r\n                        <div className=\"Tutorial-Header-Spacer\"></div>\r\n                        <h1 className=\"Tutorial-Page-Header\">Run</h1>\r\n                        <div className=\"Tutorial-Page-Content\">\r\n                            \r\n                        </div>\r\n                    </div>\r\n                }\r\n                <div className=\"Tutorial-Buttons-Wrapper\">\r\n                    <div className=\"End-Button-Wrapper\">\r\n                        <div className=\"Tutorial-End-Button\" onClick={props.toggleTutorial}>\r\n                            Exit Tutorial\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"Page-Buttons-Wrapper\">\r\n                        <div className=\"Tutorial-Next-Button\" onClick={(event) => props.changePage(1)}>\r\n                            <FontAwesomeIcon className=\"Next-Arrow\" icon={faAngleDoubleRight}/>\r\n                        </div>\r\n                        <div className=\"Tutorial-Previous-Button\" onClick={(event) => props.changePage(-1)}>\r\n                            <FontAwesomeIcon className=\"Previous-Arrow\" icon={faAngleDoubleLeft}/>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Tutorial;","import React from 'react';\r\nimport onClickOutside from 'react-onclickoutside';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleUp , faAngleDown, faCheck } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass Dropdown extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            listOpen: false,\r\n            headerTitle: this.props.title,\r\n            options: this.props.options\r\n        }\r\n    }\r\n\r\n    handleClickOutside() {\r\n        if (this.props.windowState === 1) return;\r\n        this.setState({listOpen: false});\r\n    }\r\n\r\n    toggleList() {\r\n        this.setState(prevState => ({\r\n            listOpen: !prevState.listOpen\r\n        }));\r\n    }\r\n\r\n    escapeList(event) {\r\n        if (this.state.listOpen && event.key === 'Escape') this.toggleList();\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('keydown',(event) => this.escapeList(event));\r\n    }\r\n\r\n    render() {\r\n        const {listOpen, headerTitle, options} = this.state;\r\n        let backgroundColor, fontColor;\r\n        if (this.props.windowState === 1 || this.props.windowState === 2) {\r\n            if (listOpen) [ backgroundColor , fontColor ] = ['#27af62' , 'white' ];\r\n            else [ backgroundColor , fontColor ] = [ 'white' , 'black' ];\r\n        } else [ backgroundColor , fontColor ] = [ '#191414' , 'white' ];\r\n        return (\r\n            <div className=\"Dropdown\">\r\n                <div className=\"Dropdown-header-wrapper\">\r\n                    <div className=\"Dropdown-header\" onClick={() => this.toggleList()} style = {{backgroundColor: backgroundColor, color:fontColor}}>\r\n                        <div className=\"Dropdown-header-title\">{headerTitle}</div>\r\n                        {listOpen\r\n                            ? <FontAwesomeIcon className=\"angle-up\" icon={faAngleUp} size=\"lg\" transform=\"down-1\"/>\r\n                            : <FontAwesomeIcon className=\"angle-down\" icon={faAngleDown} size=\"lg\" transform=\"down-1\"/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n                {listOpen && <ul className={headerTitle+\"-Dropdown-list\"}>\r\n                    {options.map((item) => (\r\n                        <li key={item.id} className=\"Dropdown-list-item\" onClick={() => this.props.callBack(item.id,item.key,item.title)}>\r\n                            {item.title}\r\n                            {item.selected && <FontAwesomeIcon className=\"check\" icon={faCheck} size=\"1x\"/>}\r\n                        </li>\r\n                    ))}\r\n                </ul>}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default onClickOutside(Dropdown);","import React from 'react';\r\nimport onClickOutside from 'react-onclickoutside';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleUp , faAngleDown} from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass SliderDropdown extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            listOpen: false,\r\n            headerTitle: this.props.title,\r\n            value: this.props.hexSize\r\n        }\r\n    }\r\n\r\n    handleClickOutside() {\r\n        if (this.props.windowState === 1) return;\r\n        this.setState({\r\n            listOpen: false\r\n        });\r\n    }\r\n\r\n    toggleList() {\r\n        this.setState(prevState => ({\r\n            listOpen: !prevState.listOpen\r\n        }));\r\n    }\r\n\r\n    changeValue(event) {\r\n        this.setState({value:event.target.value});\r\n    }\r\n\r\n    submitValue(event) {\r\n        this.props.callBack(event.target.value);\r\n    }\r\n\r\n    escapeList(event) {\r\n        if (this.state.listOpen && event.key === 'Escape') this.toggleList();\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('keydown',(event) => this.escapeList(event));\r\n    }\r\n\r\n    render() {\r\n        let backgroundColor, fontColor;\r\n        if (window.innerWidth < 481 || window.innerHeight < 481) {\r\n            if (this.state.listOpen) [ backgroundColor , fontColor ] = ['#27af62' , 'white' ];\r\n            else [ backgroundColor , fontColor ] = [ 'white' , 'black' ];\r\n        } else [ backgroundColor , fontColor ] = [ '#191414' , 'white' ];\r\n        return (\r\n            <div className=\"Dropdown\">\r\n                <div className=\"Dropdown-header-wrapper\">\r\n                    <div className=\"Dropdown-header\" onClick={() => this.toggleList()} style = {{backgroundColor: backgroundColor, color:fontColor}}>\r\n                        <div className=\"Dropdown-header-title\">{this.state.headerTitle}</div>\r\n                        {this.state.listOpen\r\n                            ? <FontAwesomeIcon className=\"angle-up\" icon={faAngleUp} size=\"lg\" transform=\"down-1\"/>\r\n                            : <FontAwesomeIcon className=\"angle-down\" icon={faAngleDown} size=\"lg\" transform=\"down-1\"/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n                {this.state.listOpen && <div className={\"SliderDropdown-list\"}>\r\n                    <div className=\"slider-text\">{this.state.value}</div>\r\n                    <input className=\"slider\" type=\"range\" orient=\"vertical\" min=\"5\" max=\"100\"\r\n                        value={this.state.value}\r\n                        onInput={(event) => this.changeValue(event)}\r\n                        onMouseUp={(event) => this.submitValue(event)}\r\n                        onKeyDown={(event) => {if (event.key === \"Enter\") this.submitValue(event);}}\r\n                        onTouchEnd={(event) => this.submitValue(event)}\r\n                    />\r\n                </div>}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default onClickOutside(SliderDropdown);","import React from 'react';\r\nimport Dropdown from './Dropdown';\r\nimport SliderDropdown from './SliderDropdown';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faPlay , faPause } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass ControlPanel extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            algorithm: [\r\n                        {id:7, title:'Random Walk', selected:false, key:'algorithm'},\r\n                        {id:0, title:'Depth-First Search', selected:false, key:'algorithm'},\r\n                        {id:1, title:'Breadth-First Search', selected:false, key:'algorithm'},\r\n                        {id:2, title:'Hill Climbing', selected:false, key:'algorithm'},\r\n                        {id:3, title:'Beam Search (\\u03C9=2)', selected:false, key:'algorithm'},\r\n                        {id:4, title:'Best-First Search', selected:false, key:'algorithm'},\r\n                        {id:5, title:'Branch & Bound', selected:true, key:'algorithm'},\r\n                        {id:6, title:'A* Search', selected:false, key:'algorithm'}\r\n            ],\r\n            speed: [\r\n                        {id:0, title:'Slow', selected:false, key:'speed'},\r\n                        {id:1, title:'Medium', selected:false, key:'speed'},\r\n                        {id:2, title:'Fast', selected:true, key:'speed'},\r\n                        {id:3, title:'Ludicrous', selected:false, key:'speed'},\r\n                        {id:4, title:'Instant', selected:false, key:'speed'}\r\n            ],\r\n            tool: [\r\n                        {id:0, title:'Walls', selected:true, key:'tool'},\r\n                        {id:1, title:'Weights', selected:false, key:'tool'},\r\n                        {id:2, title:'Eraser', selected:false, key:'tool'}\r\n            ],\r\n            mazes: [\r\n                        {id:0, title:'Random Walls', selected:false, key:'mazes'},\r\n                        {id:1, title:'Random Weights', selected:false, key:'mazes'},\r\n                        {id:2, title:'Depth-First Maze', selected:false, key:'mazes'},\r\n                        {id:3, title:'Breadth-First Maze', selected:false, key:'mazes'},\r\n                        {id:4, title:\"Hunt & Kill Maze\", selected:false, key:'mazes'},\r\n                        {id:5, title:\"Prim's Maze\", selected:false, key:'mazes'},\r\n                        {id:6, title:\"Kruskal's Maze\", selected:false, key:'mazes'},\r\n                        {id:7, title:\"Random DLA Fractal\", selected:false, key:'mazes'},\r\n                        {id:8, title:\"Wall DLA Fractal\", selected:false, key:'mazes'},\r\n                        {id:9, title:\"Cellular Caves\", selected:false, key:'mazes'},\r\n                        {id:10, title:\"Simplex Caves\", selected:false, key:'mazes'}\r\n            ],\r\n            clear: [\r\n                        {id:1, title:'Path', selected:false, key:'clear'},\r\n                        {id:2, title:'Walls', selected:false, key:'clear'},\r\n                        {id:3, title:'Weights', selected:false, key:'clear'},\r\n                        {id:0, title:'Board', selected:false, key:'clear'},\r\n                        {id:4, title:'Canvas', selected:false, key:'clear'}\r\n            ]\r\n        }\r\n    }\r\n\r\n    toggleSelected(id,key,title) {\r\n        if (key !== 'clear') {\r\n            let temp = this.state[key].slice();\r\n            for (let i = 0; i < temp.length; i++) {\r\n                temp[i].selected = (id === temp[i].id);\r\n            }\r\n            this.setState({\r\n                [key]:temp\r\n            });\r\n        }\r\n        this.props.toggleSelected(key,id);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"ControlPanel\">\r\n                {this.props.showControls &&\r\n                    <div className=\"Controls-Wrapper-Background\">\r\n                        <div className=\"Controls-Wrapper\">\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Algorithm-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Algorithm'} \r\n                                    options={this.state.algorithm}\r\n                                    callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\"> \r\n                                <Dropdown className=\"Speed-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Speed'} \r\n                                    options={this.state.speed}\r\n                                    callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Tool-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Tool'} \r\n                                    options={this.state.tool}\r\n                                    callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <SliderDropdown className=\"Hex-Size-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Hex Size'}\r\n                                    hexSize={this.props.hexSize}\r\n                                    callBack = {(s) => this.props.changeHexSize(s)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Mazes-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Mazes'} \r\n                                    options={this.state.mazes}\r\n                                    callBack = {(id,key,title) => this.props.drawMaze(id)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Clear-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Clear'} \r\n                                    options={this.state.clear}\r\n                                    callBack = {(id,key,title) => this.props.clearBoard(id)}\r\n                                />\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                }\r\n                <div className=\"Play-Button-Wrapper\">\r\n                    <div className=\"Play-Button\" onClick={this.props.running\r\n                        ? (clickEvent) => this.props.stopSearch()\r\n                        : (clickEvent) => this.props.startSearch()\r\n                    }>\r\n                        {this.props.running\r\n                            ? <FontAwesomeIcon className=\"pause\" icon={faPause}/>\r\n                            : <FontAwesomeIcon className=\"play\" icon={faPlay}/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ControlPanel;","//=====================================================================================//\r\n// Constants //\r\n\r\nimport { parseKey } from \"./canvas-tools\";\r\n\r\n//=====================================================================================//\r\nconst DIRECTIONS = {\r\n    even: [\r\n            { i:0  , j:1 },\r\n            { i:-1 , j:0 },\r\n            { i:-1 , j:-1 },\r\n            { i:0  , j:-1 },\r\n            { i:1  , j:-1 },\r\n            { i:1  , j:0 }\r\n    ],\r\n    odd: [\r\n            { i:0  , j:1 },\r\n            { i:-1 , j:1 },\r\n            { i:-1 , j:0 },\r\n            { i:0  , j:-1 },\r\n            { i:1  , j:0 },\r\n            { i:1  , j:1 }\r\n    ]\r\n};\r\n\r\n//=====================================================================================//\r\n// Helper Functions //\r\n//=====================================================================================//\r\n\r\n// Node Functions: node = {i:i,j:j}//\r\n//=================================//\r\nfunction isSameNode(node1,node2) {\r\n    return (node1.i === node2.i && node1.j === node2.j);\r\n};\r\n\r\nfunction nodeInPath(node,path) {\r\n    for (let pathNode of path) {\r\n        if (isSameNode(node,pathNode)) return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nfunction addNodes(node1,node2) {\r\n    return { i:(node1.i + node2.i) , j:(node1.j + node2.j) };\r\n};\r\n\r\nfunction nodeOnBoard(node,xUnits,yUnits) {\r\n    return (node.i>=0 && node.j>=0 && node.i<xUnits && node.j<yUnits);\r\n};\r\n\r\nfunction isValidNode(node,board,xUnits,yUnits) {\r\n    let state = board[[node.i,node.j]];\r\n    let onBoard = nodeOnBoard(node,xUnits,yUnits);\r\n    return (onBoard && state.type !== 'wall');\r\n};\r\n\r\nfunction findNeighbors(node) {\r\n    let neighbors = [];\r\n    let directions;\r\n    if (node.i%2 === 0) directions = DIRECTIONS.even;\r\n    else directions = DIRECTIONS.odd;\r\n    for (let change of directions) {\r\n        let neighbor = addNodes(node,change);\r\n        neighbors.push(neighbor);\r\n    }\r\n    return neighbors;\r\n};\r\n\r\nfunction manhattanDistance(node1,node2) {\r\n    const hexCoord1 = hexCoordinates(node1);\r\n    const hexCoord2 = hexCoordinates(node2);\r\n    const dx = hexCoord2.x - hexCoord1.x;\r\n    const dy = hexCoord2.y - hexCoord1.y;\r\n    if (Math.sign(dx) === Math.sign(dy)) {\r\n        return Math.max(Math.abs(dx), Math.abs(dy));\r\n    }\r\n    return Math.abs(dx) + Math.abs(dy);\r\n};\r\n\r\nfunction hexCoordinates(node) {\r\n    return { x: node.j - floor2(node.i) , y: node.j + ceil2(node.i) };\r\n};\r\n\r\nfunction floor2(x) {\r\n    return ((x >= 0) ? (x >> 1) : (x - 1) / 2);\r\n};\r\n\r\nfunction ceil2(x) {\r\n    return ((x >= 0) ? ((x + 1) >> 1) : x / 2);\r\n}\r\n\r\n// Vectors Functions: v = {x:x,y:y} //\r\n//==================================//\r\nfunction dotProduct(v1,v2) {\r\n    return v1.x*v2.x + v1.y*v2.y;\r\n};\r\n\r\nfunction scalarProd(a,v) {\r\n    return {x:a*v.x , y:a*v.y};\r\n};\r\n\r\nfunction vectorDiff(v1,v2) {\r\n    return {x: v1.x - v2.x, y: v1.y - v2.y};\r\n};\r\n\r\nfunction vectorSum(v1,v2) {\r\n    return {x: v1.x + v2.x, y: v1.y + v2.y};\r\n};\r\n\r\nfunction vectorMag(v) {\r\n    return Math.sqrt((v.x)**2 + (v.y)**2);\r\n};\r\n\r\nfunction vectorOrthoMag(v,V) {\r\n    let b = scalarProd(dotProduct(v,V)/(vectorMag(V))**2, V);\r\n    let d =  vectorDiff(v, b);\r\n    return vectorMag(d);\r\n};\r\n\r\nfunction vectorAngle(v) {\r\n    let angle = Math.atan( v.y / v.x );\r\n    if (v.x < 0) angle += Math.PI;\r\n    return angle;\r\n};\r\n\r\n// Data Structures for Algorithms //\r\n//==================================//\r\nclass minHeap {\r\n    constructor(lessThan) {\r\n        this.heap = [];\r\n        this.lessThan = lessThan\r\n    }\r\n\r\n    length() {\r\n        return this.heap.length;\r\n    }\r\n\r\n    getMin() {\r\n        return this.heap[0];\r\n    }\r\n\r\n    insert(value) {\r\n        this.heap.push(value);\r\n        let i = this.heap.length-1;\r\n        while (i > 0) {\r\n            if (this.lessThan(this.heap[i] , this.heap[Math.floor((i-1)/2)])) {\r\n                [ this.heap[Math.floor((i-1)/2)] , this.heap[i] ] = [ this.heap[i] , this.heap[Math.floor((i-1)/2)] ];\r\n                i = Math.floor((i-1)/2);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    shift() {\r\n        const minValue = this.heap.shift();\r\n        if (this.heap.length === 0) return minValue;\r\n        this.heap.unshift(this.heap.pop());\r\n        let i = 0;\r\n        while (2*i+2 < this.heap.length) {\r\n            if (this.lessThan(this.heap[2*i+1], this.heap[i]) || this.lessThan(this.heap[2*i+2], this.heap[i])) {\r\n                if (this.lessThan(this.heap[2*i+1], this.heap[2*i+2])) {\r\n                    [ this.heap[2*i+1], this.heap[i] ] = [ this.heap[i] , this.heap[2*i+1] ];\r\n                    i = 2*i + 1;\r\n                } else {\r\n                    [ this.heap[2*i+2], this.heap[i] ] = [ this.heap[i] , this.heap[2*i+2] ];\r\n                    i = 2*i + 2;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return minValue;\r\n    }\r\n};\r\n\r\nclass disjointSet {\r\n    constructor() {\r\n        this.dictionary = {};\r\n    }\r\n\r\n    makeSet(x) {\r\n        if (this.dictionary.hasOwnProperty(x)) return;\r\n        else {\r\n            this.dictionary[x] = {\r\n                parent: x,\r\n                size: 1\r\n            }\r\n        }\r\n    }\r\n\r\n    find(y) {\r\n        // using path splitting to improve performance\r\n        let x = y;\r\n        while (this.dictionary[x].parent !== x) {\r\n            let parent = this.dictionary[x].parent;\r\n            let grandparent = this.dictionary[parent].parent;\r\n            [ x , this.dictionary[x].parent ] = [ parent , grandparent ];\r\n        }\r\n        return x;\r\n    }\r\n\r\n    union(x,y) {\r\n        // using size, again to improve performance\r\n        let xRoot = this.find(x);\r\n        let yRoot = this.find(y);\r\n        if (xRoot === yRoot) return;\r\n        if (this.dictionary[xRoot].size < this.dictionary[yRoot]) {\r\n            [ xRoot , yRoot ] = [ yRoot , xRoot ];\r\n        }\r\n        this.dictionary[yRoot].parent = xRoot;\r\n        this.dictionary[xRoot].size += this.dictionary[yRoot].size;\r\n    }\r\n};\r\n\r\nfunction shuffleArray(array) {\r\n    let arrayCopy = array.slice();\r\n    for (let i = arrayCopy.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [arrayCopy[i], arrayCopy[j]] = [arrayCopy[j], arrayCopy[i]];\r\n    }\r\n    return arrayCopy;\r\n};\r\n\r\nfunction getRandomNode(xUnits,yUnits,offLimitsSet) {\r\n    let randomNode;\r\n    do {\r\n        randomNode = Math.floor(Math.random()*xUnits)+','+Math.floor(Math.random()*yUnits);\r\n    } while (offLimitsSet.has(randomNode));\r\n    return randomNode;\r\n};\r\n\r\nfunction getRandomWallNode(xUnits,yUnits,offLimitsSet) {\r\n    let randomNode;\r\n    do {\r\n        if (Math.random() < .5) {\r\n            if (Math.random() < .5) {\r\n                randomNode = 0+','+Math.floor(Math.random()*yUnits);\r\n            } else {\r\n                randomNode = (xUnits-1)+','+Math.floor(Math.random()*yUnits);\r\n            }\r\n        } else {\r\n            if (Math.random() < .5) {\r\n                randomNode = Math.floor(Math.random()*xUnits)+','+0;\r\n            } else {\r\n                randomNode = Math.floor(Math.random()*xUnits)+','+(yUnits-1);\r\n            }\r\n        }\r\n    } while (offLimitsSet.has(randomNode));\r\n    return randomNode;\r\n};\r\n\r\nfunction getRandomNeighbor(node,xUnits,yUnits) {\r\n    let neighbors = findNeighbors(parseKey(node))\r\n                    .filter((node) => nodeOnBoard(node,xUnits,yUnits))\r\n                    .map((node) => (node.i+','+node.j));\r\n    return neighbors[Math.floor(Math.random()*neighbors.length)];\r\n};\r\n\r\n\r\n//=====================================================================================//\r\n// Exports //\r\n//=====================================================================================//\r\nexport {isSameNode, nodeInPath, addNodes, nodeOnBoard, isValidNode, findNeighbors, manhattanDistance};      // node functions\r\nexport {dotProduct, scalarProd, vectorDiff, vectorSum, vectorMag, vectorOrthoMag, vectorAngle};             // vector functions\r\nexport {minHeap, disjointSet, shuffleArray, getRandomNode, getRandomWallNode, getRandomNeighbor};                              // algorithm data structures\r\n","import {isSameNode, nodeOnBoard, manhattanDistance, scalarProd, vectorSum, vectorDiff} from './utils';\r\n\r\n//=====================================================================================//\r\n// Canvas Mouse and Touch Trackers for Drawing and Manipulating Board //\r\n//=====================================================================================//\r\nfunction onMouseDown(downEvent,state,canvasRef,setState) {\r\n    if (downEvent.button !== 0) return;\r\n    let canvas = canvasRef.current;\r\n    let node = getPointerNode(downEvent,canvas,state.s,state.xOffset,state.yOffset);\r\n    let origNode = node;\r\n    let onMove, onMoveType;\r\n    if (isSameNode(node,state.startNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) =>\r\n        moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 1;\r\n    } else if (isSameNode(node,state.targetNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) => \r\n        moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 2;\r\n    } else {\r\n        drawLine(node,node,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        onMove = (startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) => \r\n        drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits);\r\n        onMoveType = 0;\r\n    }\r\n    let move = (moveEvent) => {\r\n        if (moveEvent.buttons === 0) {\r\n            canvas.removeEventListener(\"mousemove\", move);\r\n            let board = {};\r\n            if (onMoveType === 1) {\r\n                let oldStart = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n                let newStart = {[[node.i,node.j]]: {node:node,type:'start',fill:'white',object:'start'}};\r\n                Object.assign(board, state.board, oldStart, newStart);\r\n                setState({board:board});\r\n            } else if (onMoveType === 2) {\r\n                let oldTarget = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n                let newTarget = {[[node.i,node.j]]: {node:node,type:'target',fill:'white',object:'target'}};\r\n                Object.assign(board, state.board, oldTarget, newTarget);\r\n                setState({board:board});\r\n            }\r\n        } else {\r\n            let newNode = getPointerNode(moveEvent,canvas,state.s,state.xOffset,state.yOffset);\r\n            if (isSameNode(newNode,node)) return;\r\n            if ( \r\n                    (onMoveType !== 0 && !nodeOnBoard(newNode,state.xUnits,state.yUnits))\r\n                ||  (onMoveType === 1 && isSameNode(newNode,state.targetNode))\r\n                ||  (onMoveType === 2 && isSameNode(newNode,state.startNode))\r\n            ) return;\r\n            onMove(node,newNode,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n                (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n            node = newNode;\r\n        }\r\n    };\r\n    canvas.addEventListener(\"mousemove\", move);\r\n};\r\n\r\n\r\nfunction onTouchStart(startEvent,state,canvasRef,setState) {\r\n    let canvas = canvasRef.current;\r\n    let node = getPointerNode(startEvent.touches[0],canvas,state.s,state.xOffset,state.yOffset);\r\n    let origNode = node;\r\n    let onMove, onMoveType;\r\n    if (isSameNode(node,state.startNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) =>\r\n        moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 1;\r\n    } else if (isSameNode(node,state.targetNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) => \r\n        moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 2;\r\n    } else {\r\n        drawLine(node,node,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        onMove = (startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) => \r\n        drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits);\r\n        onMoveType = 0;\r\n    }\r\n    let move = (moveEvent) => {\r\n        let newNode = getPointerNode(moveEvent.touches[0],canvas,state.s,state.xOffset,state.yOffset);\r\n        if (isSameNode(newNode,node)) return;\r\n        if ( \r\n                (onMoveType !== 0 && !nodeOnBoard(newNode,state.xUnits,state.yUnits))\r\n            ||  (onMoveType === 1 && isSameNode(newNode,state.targetNode))\r\n            ||  (onMoveType === 2 && isSameNode(newNode,state.startNode))\r\n        ) return;\r\n        onMove(node,newNode,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        node = newNode;\r\n    };\r\n    let end = (endEvent) => {\r\n        canvas.removeEventListener(\"touchmove\", move);\r\n        canvas.removeEventListener(\"touchend\", end);\r\n        let board = {};\r\n        if (onMoveType === 1) {\r\n            let oldStart = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n            let newStart = {[[node.i,node.j]]: {node:node,type:'start',fill:'white',object:'start'}};\r\n            Object.assign(board, state.board, oldStart, newStart);\r\n            setState({board:board});\r\n        } else if (onMoveType === 2) {\r\n            let oldTarget = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n            let newTarget = {[[node.i,node.j]]: {node:node,type:'target',fill:'white',object:'target'}};\r\n            Object.assign(board, state.board, oldTarget, newTarget);\r\n            setState({board:board});\r\n        }\r\n    }\r\n    canvas.addEventListener(\"touchmove\", move);\r\n    canvas.addEventListener(\"touchend\", end);\r\n};\r\n\r\n//=====================================================================================//\r\n// Canvas Tools //\r\n//=====================================================================================//\r\nfunction drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) {\r\n    // Initialize object for storing updates to the canvas\r\n    let canvasUpdates = {};\r\n    // Get Manhatton Distance from startNode to endNode\r\n    const N = manhattanDistance(startNode,endNode);\r\n    //Get equation of line from startNode to endNode\r\n    const [ startPos , endPos ] = [ calcHexCenter(startNode,s,xOffset,yOffset) , calcHexCenter(endNode,s,xOffset,yOffset) ];\r\n    const V = vectorDiff(endPos,startPos);\r\n    const line = (n) => {\r\n        if (N === 0) return startPos;\r\n        else return vectorSum( scalarProd(n/N,V) , startPos );\r\n    }\r\n    // Sample N+1 points along line and fill in hexs these points lie in; however, break the loop if we go off the board\r\n    // Also don't fill in the node if it is the startNode or targetNode\r\n    for (let n = 0; n <= N; n++) {\r\n        const pos = line(n);\r\n        const node = nearestHex(pos,s,xOffset,yOffset);\r\n        //console.log(n);\r\n        //console.log(pos);\r\n        //console.log(node);\r\n        if (!nodeOnBoard(node,xUnits,yUnits)) break;\r\n        if (isSameNode(node,state.startNode) || isSameNode(node,state.targetNode)) continue;\r\n        // Fill in hex according to selected tool\r\n        if (state.tool === 0 && state.board[[node.i,node.j]].type !== 'wall') {\r\n            Object.assign(canvasUpdates, {[[node.i,node.j]]: {node:node,type:'wall',fill:'#282c34',object:null,angle:null}});\r\n        } else if (state.tool === 1 && state.board[[node.i,node.j]].type !== 'weight') {\r\n            Object.assign(canvasUpdates, {[[node.i,node.j]]: {node:node,type:'weight',fill:'white',object:'weight',angle:null}});\r\n        } else if (state.tool === 2 && state.board[[node.i,node.j]].type !== 'empty') {\r\n            Object.assign(canvasUpdates, {[[node.i,node.j]]: {node:node,type:'empty',fill:'white',object:null,angle:null}});\r\n        }\r\n    }\r\n    // Update state\r\n    setState((prevState) => {\r\n        return {\r\n                    board: Object.assign({},prevState.board,canvasUpdates),\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\n// Old drawLine. Not quite as efficient as new one, or easy to understand\r\n/*\r\nfunction drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) {\r\n    // Setting start of path\r\n    let currentNode = startNode;\r\n    let V = nodeDistance(endNode,startNode,s,xOffset,yOffset);\r\n    // Fill start if not off board and not start/target node\r\n    let canvasUpdates = {};\r\n    if (nodeOnBoard(currentNode,xUnits,yUnits) &&  !isSameNode(currentNode,state.startNode) &&  !isSameNode(currentNode,state.targetNode)\r\n    ) {\r\n        // might be a problem that currentNode changes over time\r\n        if (state.tool === 0) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'wall',fill:'#282c34',object:null}});\r\n        } else if (state.tool === 1) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'weight',fill:'white',object:'weight'}});\r\n        } else if (state.tool === 2) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'empty',fill:'white',object:null}});\r\n        }\r\n    }\r\n    // Looping over path\r\n    while (!isSameNode(currentNode,endNode)) {\r\n        // Reset minDis\r\n        let minDis = Infinity;\r\n        // Find next hex to move to by looping over adjacent hexs\r\n        let neighbors = findNeighbors(currentNode);\r\n        let tempNode = Object.assign({},currentNode);\r\n        for (let neighbor of neighbors) {\r\n            let v = nodeDistance(neighbor,tempNode,s,xOffset,yOffset);\r\n            let dotProd = dotProduct(v,V);\r\n            if (dotProd >= 0) {\r\n                v = nodeDistance(neighbor,startNode,s,xOffset,yOffset);\r\n                let currentDis = vectorOrthoMag(v,V);\r\n                if (currentDis < minDis) {\r\n                    currentNode = neighbor;\r\n                    minDis = currentDis;\r\n                }\r\n            }\r\n        }\r\n        // If next hex off board then end path\r\n        if (!nodeOnBoard(currentNode,xUnits,yUnits)) break;\r\n        // Fill next hex unless it is start or target node\r\n        else if (!isSameNode(currentNode,state.startNode) && !isSameNode(currentNode,state.targetNode)) {\r\n            // might be a problem that currentNode changes over time\r\n            if (state.tool === 0) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'wall',fill:'#282c34',object:null}});\r\n            } else if (state.tool === 1) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'weight',fill:'white',object:'weight'}});\r\n            } else if (state.tool === 2) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'empty',fill:'white',object:null}});\r\n            }\r\n        }\r\n    }\r\n    // Update state\r\n    setState((prevState) => {\r\n        return {\r\n                    board: Object.assign({},prevState.board,canvasUpdates),\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n*/\r\n\r\nfunction moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) {\r\n    let angle = 0;\r\n    if (state.xUnits > state.yUnits) angle = -Math.PI/2;\r\n    let canvasUpdates = {[[newNode.i,newNode.j]]: {node:newNode,type:'start',fill:'white',object:'start',angle:angle}};             \r\n    const oldState = Object.assign({}, state.board[[oldNode.i,oldNode.j]]);\r\n    if (oldState.type === 'start') {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: {node:oldNode,type:'empty',fill:'white',object:null}});\r\n    } else {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: oldState});\r\n    }\r\n    setState((prevState) => {\r\n        return {\r\n                    startNode: newNode,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\nfunction moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) {\r\n    let canvasUpdates = {[[newNode.i,newNode.j]]: {node:newNode,type:'target',fill:'white',object:'target'}};             \r\n    const oldState = Object.assign({}, state.board[[oldNode.i,oldNode.j]]);\r\n    if (oldState.type === 'target') {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: {node:oldNode,type:'empty',fill:'white',object:null}});\r\n    } else {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: oldState});\r\n    }\r\n    setState((prevState) => {\r\n        return {\r\n                    targetNode: newNode,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\nfunction clearBoard(id,canvasRef,state,setState) {\r\n    if (id === 0) {\r\n        let canvas = canvasRef.current;\r\n        let cx = canvas.getContext('2d');\r\n        cx.clearRect(0,0,canvas.width,canvas.height);\r\n        let [board, startNode, targetNode] = initializeBoard(canvas.width, canvas.height, state.s);\r\n        setState((prevState) => {\r\n            return {\r\n                        board: board, \r\n                        startNode: startNode, \r\n                        targetNode: targetNode, \r\n                        canvasUpdates: board,\r\n                        updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    } else if (id === 4) {\r\n        let canvas = canvasRef.current;\r\n        let cx = canvas.getContext('2d');\r\n        cx.clearRect(0,0,canvas.width,canvas.height);\r\n        let { innerWidth: width, innerHeight: height } = window\r\n        let canvasHeight;\r\n        if (width < 481 || height < 481)  {\r\n            if ( width > height) canvasHeight = height*.85;\r\n            else canvasHeight = height*.8;\r\n        }\r\n        else canvasHeight = height*.9-4;\r\n        let canvasWidth = width;\r\n        let {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset} = initializeCanvas(canvasWidth,canvasHeight,state.s);\r\n        // Setting Initial State\r\n        setState((prevState) => {\r\n            return {\r\n                canvasWidth: canvasWidth,\r\n                canvasHeight: canvasHeight,\r\n                board: board,\r\n                startNode: startNode,\r\n                targetNode: targetNode,\r\n                xUnits: xUnits,\r\n                yUnits: yUnits,\r\n                xOffset: xOffset,\r\n                yOffset: yOffset,\r\n                canvasUpdates: board,\r\n                updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    } else {\r\n        let canvasUpdates = {};\r\n        if (id === 1) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (!['white','#282c34'].includes(currentState.fill)) {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{fill:'white'});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n            Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n        } else if (id === 2) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (currentState.type === 'wall') {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{type:'empty',fill:'white',object:null});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n        } else if (id === 3) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (currentState.type === 'weight') {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{type:'empty',fill:'white',object:null});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        board: Object.assign({},prevState.board,canvasUpdates), \r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    }\r\n};\r\n\r\nfunction doTheJohnWall(state,setState) {\r\n    let canvasUpdates = {};\r\n    for (let key in state.board) {\r\n        Object.assign(canvasUpdates, {[key]: {node:parseKey(key), type:'wall', fill:'#282c34', object:null}});\r\n    }\r\n    Object.assign(canvasUpdates, {[[state.startNode.i,state.startNode.j]]: state.board[[state.startNode.i,state.startNode.j]]});\r\n    Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n    setState((prevState) => {\r\n        return {\r\n                    board: canvasUpdates, \r\n                    canvasUpdates: canvasUpdates,\r\n                    updateID: prevState.updateID + 1\r\n        };\r\n    });\r\n};\r\n\r\nfunction lightWeightBaby(state,setState) {\r\n    let canvasUpdates = {};\r\n    for (let key in state.board) {\r\n        Object.assign(canvasUpdates, {[key]: {node:parseKey(key), type:'weight', fill:'white', object:'weight'}});\r\n    }\r\n    Object.assign(canvasUpdates, {[[state.startNode.i,state.startNode.j]]: state.board[[state.startNode.i,state.startNode.j]]});\r\n    Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n    setState((prevState) => {\r\n        return {\r\n                    board: canvasUpdates, \r\n                    canvasUpdates: canvasUpdates,\r\n                    updateID: prevState.updateID + 1\r\n        };\r\n    });\r\n};\r\n\r\nfunction clearTheWay(state,setState) {\r\n    let canvasUpdates = {};\r\n    for (let key in state.board) {\r\n        Object.assign(canvasUpdates, {[key]: {node:parseKey(key), type:'empty', fill:'white', object:null}});\r\n    }\r\n    Object.assign(canvasUpdates, {[[state.startNode.i,state.startNode.j]]: state.board[[state.startNode.i,state.startNode.j]]});\r\n    Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n    setState((prevState) => {\r\n        return {\r\n                    board: canvasUpdates, \r\n                    canvasUpdates: canvasUpdates,\r\n                    updateID: prevState.updateID + 1\r\n        };\r\n    });\r\n};\r\n\r\n//=====================================================================================//\r\n// Basic Drawing Functions //\r\n//=====================================================================================//\r\nfunction drawSearch(node,s,lineWidth,xOffset,yOffset,canvasRef,board,color) {\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    let state = board[[node.i,node.j]];\r\n    sleep(0).then(() => {\r\n        if (state === 'weight') {\r\n            drawWeight(pos,s,lineWidth,canvasRef,color);\r\n        } else {\r\n            fillHex(pos,s,color,canvasRef);\r\n            drawHex(pos,s,lineWidth,canvasRef)\r\n        }\r\n    });\r\n};\r\n\r\nfunction drawWeight(node,s,lineWidth,xOffset,yOffset,canvasRef){\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    let sideLength = s*.9;\r\n    let h = sideLength;\r\n    let w1 = sideLength;\r\n    let w2 = 1.5*sideLength;\r\n    let rw = sideLength*.18;\r\n    let r1 = sideLength*.33;\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    // draw trapezoid\r\n    let path = [\r\n                    {x:w1/2  , y:-h/2},\r\n                    {x:-w1/2 , y:-h/2},\r\n                    {x:-w2/2 , y:h/2},\r\n                    {x:w2/2  , y:h/2}\r\n    ]\r\n    cx.beginPath();\r\n    cx.fillStyle = 'black';\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i = 1; i < path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n    // draw ring\r\n    cx.beginPath();\r\n    let ringCenter = {x:pos.x, y:pos.y - h/2};\r\n    cx.lineWidth = rw;\r\n    cx.arc(ringCenter.x, ringCenter.y, r1, 0, 7);\r\n    cx.stroke();\r\n};\r\n\r\nfunction drawStart(startNode,s,xOffset,yOffset,canvasRef,angle) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    const r = .85;\r\n    const a = s*Math.sqrt(3)*r/2;\r\n    const b = a/1.3;\r\n    const c = a/2.6;\r\n    let path = [\r\n                { x:a    ,  y:0},\r\n                { x:-2*c ,  y:b},\r\n                { x:-c   ,  y:0},\r\n                { x:-2*c ,  y:-b}\r\n    ];\r\n    if (angle) {\r\n        for (let i=0; i<path.length; i++) {\r\n            let oldPos = path[i];\r\n            let newPos = {\r\n                x: oldPos.x*Math.cos(angle) - oldPos.y*Math.sin(angle),\r\n                y: oldPos.x*Math.sin(angle) + oldPos.y*Math.cos(angle)\r\n            }\r\n            path[i] = newPos;\r\n        }\r\n    }\r\n    let pos = calcHexCenter(startNode,s,xOffset,yOffset);\r\n    cx.fillStyle = 'black';\r\n    cx.beginPath();\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction drawStartPos(pos,s,canvasRef,angle) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    const r = .85;\r\n    const a = s*Math.sqrt(3)*r/2;\r\n    const b = a/1.3;\r\n    const c = a/2.6;\r\n    let path = [\r\n                { x:a    ,  y:0},\r\n                { x:-2*c ,  y:b},\r\n                { x:-c   ,  y:0},\r\n                { x:-2*c ,  y:-b}\r\n    ];\r\n    if (angle) {\r\n        for (let i=0; i<path.length; i++) {\r\n            let oldPos = path[i];\r\n            let newPos = {\r\n                x: oldPos.x*Math.cos(angle) - oldPos.y*Math.sin(angle),\r\n                y: oldPos.x*Math.sin(angle) + oldPos.y*Math.cos(angle)\r\n            }\r\n            path[i] = newPos;\r\n        }\r\n    }\r\n    cx.fillStyle = 'black';\r\n    cx.beginPath();\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction drawTarget(targetNode,s,lineWidth,xOffset,yOffset,canvasRef) {\r\n    const sideLength = s;\r\n    let pos = calcHexCenter(targetNode,s,xOffset,yOffset);\r\n    // Outer Ring\r\n    fillHex(pos,sideLength,'#b22222',canvasRef);\r\n    // White Fill\r\n    fillHex(pos,sideLength*2/3 - lineWidth/2,'white',canvasRef);\r\n    // Inner Ring\r\n    fillHex(pos,sideLength/3,'#b22222',canvasRef);\r\n    // Remake Border\r\n    drawHex(pos,sideLength,lineWidth,canvasRef);\r\n};\r\n\r\nfunction drawNode(node,s,lineWidth,xOffset,yOffset,color,canvasRef) {\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    fillHex(pos,s,color,canvasRef);\r\n    drawHex(pos,s,lineWidth,canvasRef);\r\n};\r\n\r\n\r\n//=====================================================================================//\r\n// Helper Functions //\r\n//=====================================================================================//\r\n\r\n// Helpers for Canvas Tools//\r\n//========================================//\r\nfunction drawHex(pos,s,lineWidth,canvasRef) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    let path = calcHexPath(pos,s);\r\n    cx.lineWidth = lineWidth;\r\n    cx.beginPath();\r\n    cx.moveTo(path[0].x,path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(path[i].x,path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.stroke();\r\n};\r\n\r\nfunction fillHex(pos,s,color,canvasRef) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    cx.fillStyle = color;\r\n    let path = calcHexPath(pos,s);\r\n    cx.beginPath();\r\n    cx.moveTo(path[0].x, path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(path[i].x,path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n};\r\n\r\nfunction getPointerNode(event,domNode,s,xOffset,yOffset) {\r\n    let rect = domNode.getBoundingClientRect();\r\n    let x = event.clientX - rect.left;\r\n    let y = event.clientY - rect.top;\r\n    return nearestHex({x:x,y:y},s,xOffset,yOffset);\r\n};\r\n\r\n// Functions That Peform Grid Calculations//\r\n//========================================//\r\nfunction calcHexCenter(node,s,xOffset,yOffset) {\r\n    const x = xOffset + (node.j + 1 - ((node.i+1)%2)/2)*s*Math.sqrt(3);\r\n    const y = yOffset + (1.5*node.i + 1)*s\r\n    return {x:x, y:y};\r\n};\r\n\r\nfunction nodeDistance(node1,node2,s,xOffset,yOffset) {\r\n    let pos1 = calcHexCenter(node1,s,xOffset,yOffset);\r\n    let pos2 = calcHexCenter(node2,s,xOffset,yOffset);\r\n    return {x:(pos1.x - pos2.x) , y:(pos1.y - pos2.y)};\r\n};\r\n\r\nfunction nearestHex(pos,s,xOffset,yOffset) {\r\n    const J = Math.floor((pos.x - xOffset)/(s*Math.sqrt(3)));\r\n    const I = Math.floor((pos.y - yOffset)/(1.5*s));\r\n    const u = (pos.x - xOffset)/(s*Math.sqrt(3)) - J;\r\n    const v = 1 - ((pos.y - yOffset)/(1.5*s) - I);\r\n    let i, j;\r\n    if (I%2 === 0) {\r\n        if (u < .5) {\r\n            if (v > (2/3*u + 2/3)) {\r\n                [ i , j ] = [ I-1 , J-1 ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        } else {\r\n            if (v > (-2/3*u + 4/3)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        }\r\n    } else {\r\n        if (u < .5) {\r\n            if (v > (-2/3*u + 1)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J-1 ];\r\n            }\r\n        } else {\r\n            if (v > (2/3*u + 1/3)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        }\r\n    }\r\n    return {i:i,j:j};\r\n};\r\n\r\nfunction calcHexPath(pos, s) {\r\n    let path = [];\r\n    for (let theta = Math.PI/6; theta < 2*Math.PI; theta += Math.PI/3) {\r\n        const x = pos.x + s*Math.cos(theta);\r\n        const y = pos.y + s*Math.sin(theta);\r\n        path.push({x:x, y:y});\r\n    }\r\n    return path;\r\n};\r\n\r\nfunction calcUnits(canvasWidth, canvasHeight, s) {\r\n    /*\r\n    const xUnits = Math.floor(canvasHeight/(1.5*s) - .5);\r\n    const yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)) - .5);\r\n    const xOffset = (canvasWidth - (yUnits + .5)*s*Math.sqrt(3))/2;\r\n    const yOffset = (canvasHeight - (xUnits*1.5 + .5)*s)/2;\r\n    */\r\n    const xUnits = Math.max(Math.floor((canvasHeight - s/2)/(1.5*s)),1);\r\n    let yUnits, xOffset, yOffset;\r\n    if (xUnits === 1) {\r\n        yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)));\r\n        xOffset = (canvasWidth - yUnits*s*Math.sqrt(3))/2;\r\n        yOffset = (canvasHeight - xUnits*2*s)/2;\r\n    } else {\r\n        yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)) - .5);\r\n        xOffset = (canvasWidth - (yUnits + .5)*s*Math.sqrt(3))/2;\r\n        yOffset = (canvasHeight - (xUnits*1.5 + .5)*s)/2;\r\n    }    \r\n    return [xUnits,yUnits,xOffset,yOffset];\r\n};\r\n\r\nfunction initializeBoard(canvasWidth, canvasHeight, s) {   \r\n    let [xUnits,yUnits] = calcUnits(canvasWidth, canvasHeight, s);\r\n    let board = {};\r\n    for (let i = 0; i < xUnits; i++) {\r\n        for (let j = 0; j < yUnits; j++) {\r\n            Object.assign(board, {[[i,j]]: {node:{i:i,j:j}, type:'empty', fill:'white', object:null}})\r\n        }\r\n    }\r\n    let startNode, targetNode, offset;\r\n    if (xUnits > yUnits) {\r\n        offset = Math.floor(xUnits*.25);\r\n        startNode = {i: xUnits-1-offset, j: Math.floor(yUnits/2)};\r\n        targetNode = {i: offset, j: Math.floor(yUnits/2)};\r\n    } else {\r\n        offset = Math.floor(yUnits*.25);\r\n        startNode = {i: Math.floor(xUnits/2), j: offset};\r\n        targetNode = {i: Math.floor(xUnits/2), j: yUnits-1-offset};\r\n    }\r\n    let angle = 0;\r\n    if (xUnits > yUnits) angle = -Math.PI/2;\r\n    Object.assign(board[[startNode.i,startNode.j]], {type: 'start', object:'start', angle:angle});\r\n    Object.assign(board[[targetNode.i,targetNode.j]], {type: 'target', object:'target'});\r\n    return [board, startNode, targetNode];\r\n};\r\n\r\nfunction initializeCanvas(canvasWidth,canvasHeight,s) {\r\n    let [xUnits,yUnits,xOffset,yOffset] = calcUnits(canvasWidth, canvasHeight, s);\r\n    let [board, startNode, targetNode] = initializeBoard(canvasWidth, canvasHeight, s);\r\n    let lineWidth = s/10;\r\n    return {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset,lineWidth};\r\n}\r\n\r\nfunction parseKey(key) {\r\n    let [i,j] = key.split(',').map((item) => parseInt(item));\r\n    return {i:i,j:j};\r\n};\r\n\r\n//=====================================================================================//\r\n// Exports //\r\n//=====================================================================================//\r\nexport {getPointerNode, onMouseDown, onTouchStart}\r\nexport {drawSearch, drawLine, moveStart, moveTarget, clearBoard, doTheJohnWall, lightWeightBaby, clearTheWay}\r\nexport {drawWeight, drawStart, drawStartPos, drawTarget, drawNode, drawHex, fillHex};\r\nexport {sleep, calcHexCenter, nodeDistance, nearestHex, calcHexPath, calcUnits, initializeBoard, initializeCanvas, parseKey};","import React from 'react';\r\nimport {initializeBoard, drawWeight, drawStart, drawStartPos, drawTarget, drawNode} from '../utils/canvas-tools';\r\n\r\n/*\r\n// To Do //\r\n//========================================================================================//\r\n-- Make new drawWeight function that takes node as imput instead of pos\r\n\r\n//========================================================================================//\r\n*/\r\n\r\n\r\nclass Canvas extends React.Component {\r\n    componentDidMount() {\r\n        let [board] = initializeBoard(this.props.width, this.props.height, this.props.s);\r\n        for (let key in board) {\r\n            let {node, fill, object, angle} = board[key];\r\n            this.updateNode(node, fill, object, angle);\r\n        }\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps) {\r\n        if (nextProps.updateID === this.props.updateID) return false;\r\n        else return true;\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (this.props.s !== prevProps.s) {\r\n            let canvas = this.props.canvasRef.current;\r\n            let cx = canvas.getContext('2d');\r\n            cx.clearRect(0,0,this.props.width,this.props.height);\r\n            this.componentDidMount();\r\n        } else {\r\n            for (let key in this.props.canvasUpdates) {\r\n                let {node, fill, object, angle} = this.props.canvasUpdates[key];\r\n                this.updateNode(node, fill, object, angle);\r\n            }\r\n            if (this.props.startPosition) {\r\n                let {pos,angle} = this.props.startPosition;\r\n                drawStartPos(pos,this.props.s,this.props.canvasRef,angle);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateNode(node,fill,object,angle) {\r\n        if (fill) {\r\n            drawNode(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, fill, this.props.canvasRef);\r\n        }\r\n        if (object) {\r\n            if (object === 'weight') {\r\n                drawWeight(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, this.props.canvasRef);\r\n            } else if (object === 'start') {\r\n                drawStart(node, this.props.s, this.props.xOffset, this.props.yOffset, this.props.canvasRef,angle);\r\n            } else if (object === 'target') {\r\n                drawTarget(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, this.props.canvasRef);\r\n            }\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <canvas\r\n                ref = {this.props.canvasRef}\r\n                width = {this.props.width}\r\n                height = {this.props.height}\r\n                onMouseDown={this.props.running ? null : (downEvent) => this.props.onMouseDown(downEvent)}\r\n                onTouchStart={this.props.running ? null : (startEvent) => this.props.onTouchStart(startEvent)}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default Canvas;","import {\r\n    isSameNode, nodeOnBoard, isValidNode, findNeighbors, manhattanDistance, minHeap, shuffleArray, getRandomNode,\r\n    getRandomWallNode, getRandomNeighbor, disjointSet\r\n} from './utils';\r\nimport { parseKey, calcHexCenter } from './canvas-tools';\r\nimport {noise} from './perlin';\r\n\r\n\r\n//=================================================================================================================================//\r\n// Path-Finding Algorithms //\r\n//=================================================================================================================================//\r\n\r\n\r\n// Unweighted Algorithms //\r\n//=======================//\r\nfunction randomWalk(startNode,targetNode,xUnits,yUnits,board,isRunning) {\r\n    // initialize path (not queue since we will only have one path) \r\n    let path = [startNode];\r\n    // initialize array for storing updates to canvas for animation\r\n    let searchUpdates = [];\r\n    // now take a random walk, checking neighboring nodes at each visited nodes until target is found\r\n    let startTime = new Date();\r\n    while (((new Date()).getTime() - startTime.getTime()) < 5000) {\r\n        let currentNode = path[path.length - 1];\r\n        let lastNode;\r\n        path.length < 2 ? lastNode = {i:-1,j:-1} : lastNode = path[path.length - 2];\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or off the board)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes and randomize their order\r\n        neighbors = shuffleArray(neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits))));\r\n        for (let node of neighbors) {\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(node,targetNode)) {\r\n                return [path.concat([node]), searchUpdates];\r\n            } else {\r\n                if (!isSameNode(node,startNode) && !isSameNode(node,lastNode)) {\r\n                    let newState = Object.assign({},board[[node.i,node.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                }\r\n            }\r\n        }\r\n        path.push(neighbors[0])\r\n    }\r\n};\r\n\r\nfunction depthFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.unshift(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction breadthFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.push(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction hillClimbing(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // sort nodes according to distance to target node (descending)\r\n        neighbors.sort((node1,node2) => manhattanDistance(node2,targetNode) - manhattanDistance(node1,targetNode));\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.unshift(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction beamSearch(startNode,targetNode,xUnits,yUnits,board, w = 2) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // sort nodes according to distance to target node (descending)\r\n        neighbors.sort((node1,node2) => manhattanDistance(node2,targetNode) - manhattanDistance(node1,targetNode));\r\n        // filter to valid nodes and keep only the first w number of them\r\n        neighbors = neighbors.filter(\r\n            (node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j))\r\n        ).slice(-w);\r\n        for (let newNode of neighbors) {\r\n            let newPath = currentPath.concat([newNode]);\r\n            // if we found target return the completed path and updates, else add path extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                return [newPath, searchUpdates];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.push(newPath);\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction bestFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.distance < path2.distance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({distance:manhattanDistance(startNode,targetNode) , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = path.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.insert({distance:manhattanDistance(newNode,targetNode) , path:newPath});\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\n\r\n// Weighted Algorithms //\r\n//=====================//\r\n// Dictionary below determines relative weight moving from one node to another.\r\n// Essentially moving through a weight is 10 times as difficult as an empty node.\r\nconst pathWeights = {'empty':1, 'weight':10, 'target':1};\r\n\r\nfunction branchNBound(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.distance < path2.distance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    let bestDistance = Infinity;\r\n    let bestPath = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            // if newDistance is not less than the bestDistance to the target so far, then drop the path from the queue\r\n            if (newDistance >= bestDistance) {\r\n                if (!isSameNode(newNode,targetNode)) {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                }\r\n                continue;\r\n            };\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                [bestPath, bestDistance] = [newPath, newDistance];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({distance:newDistance , path:newPath});\r\n            }\r\n        }\r\n    }\r\n    // Return best path (which could be empty if no path found) and searchUpdates for animation\r\n    return [bestPath, searchUpdates];\r\n};\r\n\r\nfunction aStarSearch(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.estimatedDistance < path2.estimatedDistance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({estimatedDistance:manhattanDistance(startNode,targetNode), distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                // extend other paths to be sure they aren't actually closer to the target (not sure about this part)\r\n                return [newPath, searchUpdates];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({\r\n                    estimatedDistance: newDistance + manhattanDistance(newNode,targetNode), \r\n                    distance:newDistance, \r\n                    path:newPath\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\n// Modified A* For Use In Maze Buidlers //\r\n//======================================//\r\nconst modifiedWeights = (type) => {\r\n    if (type === 0) return 1;\r\n    else return Math.random()*10000 + 1000;\r\n};\r\n\r\nfunction modifiedAStar(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.estimatedDistance < path2.estimatedDistance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({estimatedDistance:manhattanDistance(startNode,targetNode), distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + modifiedWeights(board[[newNode.i,newNode.j]]);\r\n            // if we found target then we have the shortest path, which we will then convert into canvas updates that are returned\r\n            if (isSameNode(newNode,targetNode)) {\r\n                let searchUpdates = [];\r\n                for (let node of newPath) {\r\n                    if (board[[node.i,node.j]] === 1) searchUpdates.push({node:node, type:'empty', fill:'white'});\r\n                }\r\n                return searchUpdates;\r\n            } else {\r\n                queue.insert({\r\n                    estimatedDistance: newDistance + manhattanDistance(newNode,targetNode), \r\n                    distance:newDistance, \r\n                    path:newPath\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // Return empty updates if no path to target was found\r\n    console.log('got here, but should not have')\r\n    return [];\r\n};\r\n\r\n\r\n//=================================================================================================================================//\r\n// Maze Building Algorithms //\r\n//=================================================================================================================================//\r\nfunction randomWalls(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize array to keep track of path for drawing maze and dungeon object for state of maze\r\n    let mazePath = [];\r\n    let dungeon = {};\r\n    // iterate over whole board and randomly generate walls (with P(wall) = .5)\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) {\r\n            dungeon[key] = 0;\r\n        } else if (Math.random() < .50) {\r\n            dungeon[key] = 1;\r\n            mazePath.push({node:node, type:'wall', fill:'#282c34'})\r\n        } else {\r\n            dungeon[key] = 0;\r\n        }\r\n    }\r\n    // use modified A* to ensure a path between the start and target nodes\r\n    let pathUpdates = modifiedAStar(startNode,targetNode,xUnits,yUnits,dungeon);\r\n    mazePath = mazePath.concat(pathUpdates);\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction randomWeights(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iterate over whole board and randomly generate walls (with P(wall) = .5)\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) continue;\r\n        if (Math.random() < .5) {\r\n            mazePath.push({node:node, type:'weight', fill:'white', object:'weight'})\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction depthFirstMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array\r\n    let queue = [start];\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to next node on the queue\r\n        const currentNode = queue.shift();\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // shuffle array to randomize order\r\n        neighbors = shuffleArray(neighbors);\r\n        // initialize array for adding the new nodes to queue (this lets us control the order in case the start or target node are encountered\r\n        // since we want to immediately extend these nodes to ensure a perfect path)\r\n        let nodesToAdd = [];\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) nodesToAdd.unshift(node);\r\n            else nodesToAdd.push(node);\r\n        }\r\n        queue = nodesToAdd.concat(queue);\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction breadthFirstMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array\r\n    let queue = [start];\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to next node on the queue\r\n        const currentNode = queue.shift();\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // shuffle array to randomize order\r\n        neighbors = shuffleArray(neighbors);\r\n        // add new nodes to queue, putting them at the end unless they are the start or target node (this ensures the start and target always get\r\n        // extended immediately which preserves the perfect maze condition)\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) queue.unshift(node);\r\n            else queue.push(node);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction kruskalsMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize list of unvisited nodes which we will visit in a randomized order; however, start and target nodes will be placed at the front to ensure\r\n    // a perfect maze is generated\r\n    let unVisitedNodes = [];\r\n    for (let key in board) {\r\n        if (!isSameNode(parseKey(key),startNode) && !isSameNode(parseKey(key),targetNode)) unVisitedNodes.push(key);\r\n    }\r\n    unVisitedNodes = shuffleArray(unVisitedNodes);\r\n    unVisitedNodes.unshift(startNode.i+','+startNode.j);\r\n    unVisitedNodes.unshift(targetNode.i+','+targetNode.j);\r\n    // initialize set to keep track of nodes added to the path\r\n    let pathNodes = new Set();\r\n    // initialize disjoint set to keep track of the disjoint paths\r\n    let disjointPaths = new disjointSet();\r\n    // lastly initialize array for storing mazePath updates for animation\r\n    let mazePath = [];\r\n    // iteratively look at each node in unVisited nodes, checking to see if it can be added to the path\r\n    for (let currentNode of unVisitedNodes) {\r\n        // get neighboring nodes and convert node to string\r\n        let neighbors = findNeighbors(parseKey(currentNode)).map((node) => (node.i+','+node.j));\r\n        // filter to neighbors that are on the board and are part of a path\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(parseKey(node),xUnits,yUnits) && pathNodes.has(node)));\r\n        // get the roots of each of these neighbors\r\n        let roots = neighbors.map((node) => disjointPaths.find(node));\r\n        // get the unique roots\r\n        let rootsSet = new Set(roots);\r\n        // Condition below guarantees perfect maze, but would not guarantee all paths are joined (and thus not guarantee that there is a path from start to target)\r\n        //if (roots.length !== rootsSet.size) continue;\r\n        // Condition below guarantees all paths are joined, but does not guarantee a perfect maze\r\n        if (roots.length > 1 && rootsSet.size < 2) continue;\r\n        // else we make current node part of the pathNodes and union all the roots\r\n        pathNodes.add(currentNode);\r\n        if (!isSameNode(parseKey(currentNode),startNode) && !isSameNode(parseKey(currentNode),targetNode)) {\r\n            mazePath.push({node:parseKey(currentNode), type:'empty', fill:'white'});\r\n        }\r\n        disjointPaths.makeSet(currentNode);\r\n        for (let node of roots) {\r\n            disjointPaths.union(currentNode,node);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n}\r\n\r\nfunction primsMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array and initialize values for keeping track of start and target nodes\r\n    let queue = [start];\r\n    let [ startFound , targetFound ] = [ false , false ];\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to random node on the queue, unless we have encountered the start or target node, in which case move to this node\r\n        // doing so ensures a perfect maze\r\n        let currentNode;\r\n        if (startFound) {\r\n            currentNode = queue.shift();\r\n            startFound = false;\r\n        }\r\n        else if (targetFound) {\r\n            currentNode = queue.shift();\r\n            targetFound = false;\r\n        } else {\r\n            const i = Math.floor(Math.random() * queue.length);\r\n            currentNode = queue[i];\r\n            queue = queue.slice(0,i).concat(queue.slice(i+1));\r\n        }\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // add new nodes to queue, putting them at the end unless they are the start or target node (this ensures the start and target always get\r\n        // extended immediately which preserves the perfect maze condition)\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode)) {\r\n                queue.unshift(node);\r\n                startFound = true;\r\n            } else if (isSameNode(node,targetNode)) {\r\n                queue.unshift(node);\r\n                targetFound = true;\r\n            }\r\n            else queue.push(node);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction huntAndKill(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array and initialize variable to determine when to choose new random walk point\r\n    let queue = [start];\r\n    let newRandomWalk = false;\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to next node on the queue, unless we determined current path cannot be exteneded, in which case pick random node\r\n        let currentNode;\r\n        if (newRandomWalk) {\r\n            const i = Math.floor(Math.random() * queue.length);\r\n            currentNode = queue[i];\r\n            queue = queue.slice(0,i).concat(queue.slice(i+1));\r\n            newRandomWalk = false;\r\n        } else {\r\n            currentNode = queue.shift();\r\n        }\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // shuffle array to randomize order\r\n        neighbors = shuffleArray(neighbors);\r\n        // initialize array for adding the new nodes to queue (this lets us control the order in case the start or target node are encountered\r\n        // since we want to immediately extend these nodes to ensure a perfect path)\r\n        let nodesToAdd = [];\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) nodesToAdd.unshift(node);\r\n            else nodesToAdd.push(node);\r\n        }\r\n        queue = nodesToAdd.concat(queue);\r\n        if (nodesToAdd.length === 0) newRandomWalk = true;\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction randomDLA(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize sets for keeping track of nodes in the path and neighboring nodes to the path\r\n    let [ pathNodes , pathNeighbors ] = [ new Set() , new Set() ];\r\n    // initialize array for keeping track of canvas updates\r\n    let mazePath = [];\r\n    // initialize brownianNode that randomly drifts around the board, add it to pathNeighbors to esure it is the first node added to th path\r\n    let brownianNode = getRandomNode(xUnits,yUnits,pathNodes);\r\n    pathNeighbors.add(brownianNode);\r\n    // run loop that lets the brownianNode walk randomly around the board\r\n    while (pathNodes.size < (xUnits*yUnits)/6) {\r\n        // updates for when brownianNode comes into contact with path\r\n        if (pathNeighbors.has(brownianNode)) {\r\n            // add node to pathNodes and add neighbors to pathNeighbors\r\n            pathNodes.add(brownianNode);\r\n            let neighbors = findNeighbors(parseKey(brownianNode)).filter((node) => nodeOnBoard(node,xUnits,yUnits));\r\n            for (let neighbor of neighbors) {\r\n                pathNeighbors.add(neighbor.i+','+neighbor.j);\r\n            }\r\n            // add to canvas updates if it is not the start or target node\r\n            if (!isSameNode(parseKey(brownianNode),startNode) && !isSameNode(parseKey(brownianNode),targetNode)) {\r\n                mazePath.push({node:parseKey(brownianNode), type:'empty', fill:'white', object:null});\r\n            }\r\n            // set brownianNode to new random position\r\n            brownianNode = getRandomNode(xUnits,yUnits,pathNodes);\r\n        } else {\r\n            // let brownianNode walk to new neighbor at random\r\n            brownianNode = getRandomNeighbor(brownianNode,xUnits,yUnits);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\nfunction wallDLA(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize sets for keeping track of nodes in the path and neighboring nodes to the path\r\n    let [ pathNodes , pathNeighbors ] = [ new Set() , new Set() ];\r\n    // initialize array for keeping track of canvas updates\r\n    let mazePath = [];\r\n    // initialize brownianNode that randomly drifts around the board, add it to pathNeighbors to esure it is the first node added to th path\r\n    let brownianNode = getRandomWallNode(xUnits,yUnits,pathNodes);\r\n    pathNeighbors.add(brownianNode);\r\n    // run loop that lets the brownianNode walk randomly around the board\r\n    while (pathNodes.size < (xUnits*yUnits)/6) {\r\n        // updates for when brownianNode comes into contact with path\r\n        if (pathNeighbors.has(brownianNode)) {\r\n            // add node to pathNodes and add neighbors to pathNeighbors\r\n            pathNodes.add(brownianNode);\r\n            let neighbors = findNeighbors(parseKey(brownianNode)).filter((node) => nodeOnBoard(node,xUnits,yUnits));\r\n            for (let neighbor of neighbors) {\r\n                pathNeighbors.add(neighbor.i+','+neighbor.j);\r\n            }\r\n            // add to canvas updates if it is not the start or target node\r\n            if (!isSameNode(parseKey(brownianNode),startNode) && !isSameNode(parseKey(brownianNode),targetNode)) {\r\n                mazePath.push({node:parseKey(brownianNode), type:'empty', fill:'white', object:null});\r\n            }\r\n            // set brownianNode to new random position\r\n            brownianNode = getRandomWallNode(xUnits,yUnits,pathNodes);\r\n        } else {\r\n            // let brownianNode walk to new neighbor at random\r\n            brownianNode = getRandomNeighbor(brownianNode,xUnits,yUnits);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction cellularDungeon(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // initialize dictionary for keeping track of dungeon state (0 for empty and 1 for wall)\r\n    let dungeon = {};\r\n    // begin by iterating over whole board and randomly generating walls (with P(wall) = .35)\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) {\r\n            dungeon[key] = 0;\r\n        // remove this to have walls be open\r\n        } else if (node.i === 0 || node.i === xUnits-1 || node.j === 0 || node.j === yUnits-1) {\r\n            mazePath.push({node:node, type:'wall', fill:'#282c34'})\r\n            dungeon[key] = 1;\r\n        } else if (Math.random() < .47) {\r\n            mazePath.push({node:node, type:'wall', fill:'#282c34'})\r\n            dungeon[key] = 1;\r\n        } else {\r\n            dungeon[key] = 0;\r\n        }\r\n    }\r\n    // now we let the board anneal over a set number of iterations to form the dungeons\r\n    for (let i=0; i<5; i++) {\r\n        let newDungeon = {};\r\n        // iterate over previous state and determine new state for each grid cell\r\n        for (let key in dungeon) {\r\n            const node = parseKey(key);\r\n            const neighborsStates = findNeighbors(node)\r\n                .filter((node) => nodeOnBoard(node,xUnits,yUnits))\r\n                // eslint-disable-next-line\r\n                .map((node) => dungeon[[node.i,node.j]]);\r\n            const wallCount = neighborsStates.reduce((state1,state2) => state1 + state2);\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) {\r\n                newDungeon[key] = 0;\r\n            // remove this to have walls be open\r\n            } else if (node.i === 0 || node.i === xUnits-1 || node.j === 0 || node.j === yUnits-1) {\r\n                newDungeon[key] = 1;\r\n            } else if ((dungeon[key] && wallCount >= 3) || (!dungeon[key] && wallCount >= 4)) {\r\n                newDungeon[key] = 1;\r\n            } else {\r\n                newDungeon[key] = 0;\r\n            }\r\n            if (dungeon[key] !== newDungeon[key]) {\r\n                if (newDungeon[key] === 1) {\r\n                    mazePath.push({node:node, type:'wall', fill:'#282c34'})\r\n                } else {\r\n                    mazePath.push({node:node, type:'empty', fill:'white'})\r\n                }\r\n            }\r\n        }\r\n        dungeon = newDungeon\r\n    }\r\n    // use modified A* to ensure a path between the start and target nodes\r\n    let pathUpdates = modifiedAStar(startNode,targetNode,xUnits,yUnits,dungeon);\r\n    mazePath = mazePath.concat(pathUpdates);\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction simplexCaves(startNode,targetNode,xUnits,yUnits,board,s,xOffset,yOffset) {\r\n    // initialize mazePath array for storing canvs updates and dungeon object for storing state of maze\r\n    let mazePath = [];\r\n    let dungeon = {};\r\n    // initiate perline noise\r\n    noise.seed(Math.random());\r\n    // for each node on the board grab the perlin noise value; if the value is above the cutoff, make it a wall, else empty\r\n    const defaultThreshold = .65;\r\n    // use below function to have threshold go to zero as we approach the edges (so the edges become walls)\r\n    const offset = Math.ceil(Math.min(xUnits/20, yUnits/20));\r\n    function thresholdFunction(node) {\r\n        const x = Math.min(node.i, xUnits-1-node.i);\r\n        const y = Math.min(node.j, yUnits-1-node.j);\r\n        const z = Math.min(x,y);\r\n        if (z < offset) {\r\n            return defaultThreshold * (1 - ((offset-z)/offset)**2);\r\n        }\r\n        else return defaultThreshold;\r\n    };\r\n    let scale = 150;\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) {\r\n            dungeon[key] = 0;\r\n        } else {\r\n            const pos = calcHexCenter(node,s,xOffset,yOffset);\r\n            const noiseValue = (noise.simplex2(pos.x / scale, pos.y / scale) + 1) / 2;\r\n            const threshold = thresholdFunction(node);\r\n            if (noiseValue > threshold) {\r\n                dungeon[key] = 1;\r\n                mazePath.push({node:node, type:'wall', fill:'#282c34'});\r\n            } else {\r\n                dungeon[key] = 0;\r\n            }\r\n        }\r\n    }\r\n    // use modified A* to ensure a path between the start and target nodes\r\n    let pathUpdates = modifiedAStar(startNode,targetNode,xUnits,yUnits,dungeon);\r\n    mazePath = mazePath.concat(pathUpdates);\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n}\r\n\r\n\r\nexport {randomWalk, depthFirst, breadthFirst, hillClimbing, beamSearch, bestFirst, branchNBound, aStarSearch};\r\nexport {randomWalls, randomWeights, depthFirstMaze, breadthFirstMaze, kruskalsMaze, primsMaze, huntAndKill, randomDLA, wallDLA, cellularDungeon, simplexCaves}","import {\r\n    randomWalk, depthFirst, breadthFirst, hillClimbing, beamSearch, bestFirst, branchNBound, aStarSearch,\r\n    randomWalls, randomWeights, depthFirstMaze, breadthFirstMaze, kruskalsMaze, primsMaze, huntAndKill, randomDLA, wallDLA, cellularDungeon, simplexCaves,\r\n} from './algorithms';\r\nimport { calcHexCenter, nodeDistance, doTheJohnWall, lightWeightBaby, clearTheWay } from './canvas-tools';\r\nimport { scalarProd, vectorSum, vectorDiff, vectorAngle, isSameNode } from './utils';\r\n\r\n\r\n\r\n//=================================================================================================================================//\r\n// Constants //\r\n//=================================================================================================================================//\r\n// mappings for speeds when animating search, drawPath, moveDownPath, victory, and drawMaze\r\nconst searchSpeed = {\r\n    0: 10,\r\n    1: 100,\r\n    2: 1000,\r\n    3: 10000,\r\n    4: Infinity\r\n};\r\nconst drawPathSpeed = {\r\n    0: 5,\r\n    1: 5**2,\r\n    2: 5**3,\r\n    3: 5**4,\r\n    4: Infinity\r\n};\r\nconst moveDownPathSpeed = {\r\n    0: 3,\r\n    1: 3**2,\r\n    2: 3**3,\r\n    3: 3**4,\r\n    4: Infinity\r\n};\r\nconst victorySpeed = {\r\n    0: 1.5*Math.PI,\r\n    1: 2*Math.PI,\r\n    2: 3*Math.PI,\r\n    3: 6*Math.PI,\r\n    4: Infinity\r\n};\r\nconst drawMazeSpeed = {\r\n    0: 6,\r\n    1: 6**2,\r\n    2: 6**3,\r\n    3: 6**4,\r\n    4: Infinity\r\n};\r\n\r\n\r\n//=================================================================================================================================//\r\n// Path-Finding Animations //\r\n//=================================================================================================================================//\r\nfunction pathFinderAnimation(state,canvasRef,setState,isRunning) {\r\n    // Set state to running so user can't interfere with pathFinder \r\n    setState((prevState) => ({\r\n        running: true, \r\n        updateID: prevState.updateID + 1\r\n    }));\r\n    let pathFinder;\r\n    switch (state.algorithm) {\r\n        case 0: pathFinder = depthFirst; break;\r\n        case 1: pathFinder = breadthFirst; break;\r\n        case 2: pathFinder = hillClimbing; break;\r\n        case 3: pathFinder = beamSearch; break;\r\n        case 4: pathFinder = bestFirst; break;\r\n        case 5: pathFinder = branchNBound; break;\r\n        case 6: pathFinder = aStarSearch; break;\r\n        case 7: pathFinder = randomWalk; break;\r\n        default: pathFinder = breadthFirst;\r\n    };\r\n    let [path, searchUpdates] = pathFinder(state.startNode,state.targetNode,state.xUnits,state.yUnits,state.board);\r\n    searchAnimation(path,searchUpdates,state.startNode,state.s,state.xOffset,state.yOffset,state.speed,state.board,setState,isRunning);\r\n};\r\n\r\nfunction searchAnimation(path,searchUpdates,startNode,s,xOffset,yOffset,speed,board,setState,isRunning) {\r\n    let hexsPerSecond = searchSpeed[speed];\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = searchUpdates.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = searchUpdates.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                if (path.length > 0) drawPathAnimation(path,startNode,s,xOffset,yOffset,speed,board,setState,isRunning);\r\n                else {\r\n                    setState((prevState) => ({\r\n                        running: false,\r\n                        updateID: prevState.updateID + 1,\r\n                        canvasUpdates: [],\r\n                        startPosition: false\r\n                    }));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction drawPathAnimation(path,startNode,s,xOffset,yOffset,speed,board,setState,isRunning) {\r\n    let hexsPerSecond = drawPathSpeed[speed];\r\n    let pathUpdates = [];\r\n    for (let node of path.slice(1,-1)) {\r\n        if (!isSameNode(node,startNode)) pathUpdates.push(Object.assign({},board[[node.i,node.j]],{fill:'#b1fc40'}));\r\n    }\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = pathUpdates.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = pathUpdates.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                moveDownPathAnimation(path,s,xOffset,yOffset,speed,setState,isRunning);\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction moveDownPathAnimation(path,s,xOffset,yOffset,speed,setState,isRunning) {\r\n    let hexsPerSecond = moveDownPathSpeed[speed];\r\n    const totalSteps = path.length - 1;\r\n    const totalTime = totalSteps / hexsPerSecond * 1000;\r\n    let startTime = null;\r\n    let i = 0;\r\n    function updateAnimation(time) {\r\n        let [ prevStartNode , prevEndNode ] = [ path[i] , path[i+1] ];\r\n        i = Math.floor((time - startTime) / totalTime * totalSteps);\r\n        let pos, angle;\r\n        if (i < totalSteps) {\r\n            let [ startNode , endNode ] = [ path[i] , path[i+1] ];\r\n            let [ startPos , endPos ] = [ calcHexCenter(startNode,s,xOffset,yOffset) , calcHexCenter(endNode,s,xOffset,yOffset) ]\r\n            let V = vectorDiff(endPos,startPos);\r\n            let v = scalarProd((time - startTime) / totalTime * totalSteps - i, V);\r\n            pos = vectorSum(startPos, v);\r\n            angle = vectorAngle(V);\r\n        } else {\r\n            let [ startNode , endNode ] = [ path[path.length-2] , path[path.length-1] ];\r\n            let [ startPos , endPos ] = [ calcHexCenter(startNode,s,xOffset,yOffset) , calcHexCenter(endNode,s,xOffset,yOffset) ]\r\n            let V = vectorDiff(endPos,startPos);\r\n            pos = calcHexCenter(endPos);\r\n            angle = vectorAngle(V);\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        canvasUpdates: [\r\n                            Object.assign({}, prevState.board[[prevStartNode.i,prevStartNode.j]]),\r\n                            Object.assign({},  prevState.board[[prevEndNode.i,prevEndNode.j]])\r\n                        ],\r\n                        startPosition: Object.assign({},{pos:pos,angle:angle}),\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (startTime != null) {\r\n                updateAnimation(time);\r\n            } else {\r\n                startTime = time;\r\n            }\r\n            if ((time - startTime) < totalTime) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                victoryAnimation(path[path.length-1],path[path.length-2],speed,s,xOffset,yOffset,setState,isRunning);\r\n            }\r\n        } else {\r\n            let [ prevStartNode , prevEndNode ] = [ path[i] , path[i+1] ];\r\n            setState((prevState) => {\r\n                return {\r\n                            canvasUpdates: [\r\n                                Object.assign({}, prevState.board[[prevStartNode.i,prevStartNode.j]]),\r\n                                Object.assign({},  prevState.board[[prevEndNode.i,prevEndNode.j]])\r\n                            ],\r\n                            startPosition: false,\r\n                            updateID: prevState.updateID +1\r\n                };\r\n            });\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction victoryAnimation(targetNode,prevNode,speed,s,xOffset,yOffset,setState,isRunning) {\r\n    const radiansPerSecond = victorySpeed[speed];\r\n    const targetPos = calcHexCenter(targetNode,s,xOffset,yOffset);\r\n    const startAngle = vectorAngle(nodeDistance(targetNode,prevNode,s,xOffset,yOffset));\r\n    const totalTime = 6*Math.PI / radiansPerSecond * 1000;\r\n    let startTime = null;\r\n    function updateAnimation(time) {\r\n        let angle;\r\n        if ((time - startTime) < totalTime) {\r\n            angle = startAngle + (time - startTime)/totalTime*6*Math.PI;\r\n        } else {\r\n            angle = startAngle + 6*Math.PI;\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        canvasUpdates: [ Object.assign({}, prevState.board[[targetNode.i,targetNode.j]]) ],\r\n                        startPosition: Object.assign({},{pos:targetPos,angle:angle}),\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (startTime != null) {\r\n                updateAnimation(time);\r\n            } else {\r\n                startTime = time;\r\n            }\r\n            if ((time - startTime) < totalTime) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                setState((prevState) => ({\r\n                    running: false,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: [],\r\n                    startPosition: false\r\n                }));\r\n            }\r\n        } else {\r\n            setState((prevState) => {\r\n                return {\r\n                            canvasUpdates: [ Object.assign({}, prevState.board[[targetNode.i,targetNode.j]]) ],\r\n                            startPosition: false,\r\n                            updateID: prevState.updateID +1\r\n                };\r\n            });\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\n\r\n//=================================================================================================================================//\r\n// Maze-Drawing Animations //\r\n//=================================================================================================================================//\r\nfunction mazeAnimation(mazeID,state,setState,isRunning) {\r\n    // clear board or fill it with required fill for maze\r\n    if (mazeID === 0 || mazeID === 1 || mazeID === 9 || mazeID === 10) clearTheWay(state,setState);\r\n    else if (mazeID === 7 || mazeID === 8) lightWeightBaby(state,setState);\r\n    else doTheJohnWall(state,setState);\r\n    // Set state to running so user can't interfere with pathFinder \r\n    setState((prevState) => ({\r\n        running: true, \r\n        updateID: prevState.updateID + 1\r\n    }));\r\n    // Get path array of nodes to fill in for maze\r\n    let mazeBuilder;\r\n    switch (mazeID) {\r\n        case 0: mazeBuilder = randomWalls; break;\r\n        case 1: mazeBuilder = randomWeights; break;\r\n        case 2: mazeBuilder = depthFirstMaze; break;\r\n        case 3: mazeBuilder = breadthFirstMaze; break;\r\n        case 4: mazeBuilder = huntAndKill; break;\r\n        case 5: mazeBuilder = primsMaze; break;\r\n        case 6: mazeBuilder = kruskalsMaze; break;\r\n        case 7: mazeBuilder = randomDLA; break;\r\n        case 8: mazeBuilder = wallDLA; break;\r\n        case 9: mazeBuilder = cellularDungeon; break;\r\n        case 10: mazeBuilder = simplexCaves; break;\r\n        default: mazeBuilder = depthFirstMaze;\r\n    };\r\n    let mazePath = mazeBuilder(state.startNode,state.targetNode,state.xUnits,state.yUnits,state.board,state.s,state.xOffset,state.yOffset);\r\n    // Set up parameters for animation\r\n    let hexsPerSecond = drawMazeSpeed[state.speed];\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = mazePath.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = mazePath.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                setState((prevState) => ({\r\n                    running: false,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: [],\r\n                    startPosition: false\r\n                }));\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nexport {pathFinderAnimation, mazeAnimation};","import React from 'react';\r\nimport Tutorial from './Tutorial';\r\nimport ControlPanel from './ControlPanel';\r\nimport Canvas from './Canvas';\r\nimport {onMouseDown, onTouchStart, clearBoard, initializeCanvas} from '../utils/canvas-tools';\r\nimport {pathFinderAnimation, mazeAnimation} from '../utils/animations';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faBars} from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass PathFinder extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        let { innerWidth: width, innerHeight: height } = window\r\n        // Set Up Control Panel\r\n        let windowState = this.getWindowState();\r\n        let showControls = {1:false,2:false,3:true}[windowState]\r\n        // Setting Up Canvas\r\n        let canvasHeight;\r\n        if (windowState === 1) canvasHeight = height*.8;\r\n        else if (windowState === 2) canvasHeight = height*.85;\r\n        else canvasHeight = height*.9-4;\r\n        let canvasWidth = width;\r\n        this.canvasRef = React.createRef();\r\n        let s = 15;\r\n        let {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset,lineWidth} = initializeCanvas(canvasWidth,canvasHeight,s);\r\n        // Setting Initial State\r\n        this.state = {\r\n            showTutorial: true,\r\n            tutorialPage: 1,\r\n            windowState: this.getWindowState(),\r\n            showControls: showControls,\r\n            algorithm: 5,\r\n            speed: 2,\r\n            tool: 0,\r\n            canvasWidth: canvasWidth,\r\n            canvasHeight: canvasHeight,\r\n            s: s,\r\n            lineWidth: lineWidth,\r\n            board: board,\r\n            startNode: startNode,\r\n            targetNode: targetNode,\r\n            xUnits: xUnits,\r\n            yUnits: yUnits,\r\n            xOffset: xOffset,\r\n            yOffset: yOffset,\r\n            running: false,\r\n            canvasUpdates: [],\r\n            startPosition: false,\r\n            updateID: 0\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('resize', (event) => this.handleResize());\r\n    }\r\n\r\n    handleResize() {\r\n        let windowState = this.getWindowState();\r\n        if (windowState !== this.state.windowState) {\r\n            if ((windowState === 1 || windowState === 2) && (this.state.windowState === 3)) {\r\n                this.setState({windowState:windowState, showControls:false});\r\n            } else if ((windowState === 3) && (this.state.windowState === 1 || this.state.windowState === 2)) {\r\n                this.setState({windowState:windowState, showControls:true});\r\n            } else this.setState({windowState:windowState});\r\n        }\r\n    }\r\n\r\n    getWindowState() {\r\n        let { innerWidth: width, innerHeight: height } = window;\r\n        if (width < 481 || height < 481)  {\r\n            if ( width > height) return 2;\r\n            else return 1;\r\n        } else return 3;\r\n    }\r\n\r\n    toggleSelected(key,id) {\r\n        if (key !== 'clear') {\r\n            this.setState({\r\n                [key]:id\r\n            })\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    toggleControls() {\r\n        this.setState((prevState) => ({showControls: !prevState.showControls}));\r\n    }\r\n\r\n    startPathFinder() {\r\n        // Check to make sure not already running\r\n        if (this.state.running) return;\r\n        const setState = (stateUpdate) => this.setState(stateUpdate);\r\n        const isRunning = () => {return this.state.running;};\r\n        this.clearBoard(1);\r\n        pathFinderAnimation(this.state,this.canvasRef,setState,isRunning);\r\n    }\r\n\r\n    stopPathFinder() {\r\n        this.setState((prevState) => ({running:false, updateID:prevState.updateID+1}));\r\n    }\r\n\r\n    onMouseDown(downEvent) {\r\n        onMouseDown(downEvent,this.state,this.canvasRef,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    onTouchStart(startEvent) {\r\n        // This isn't working in Chrome. Chrome automatically sets scroll event to passive which dissallows preventDefault\r\n        // I could find a way to set event to active, so instead just disabling scroll for canvas in CSS.\r\n        // This however is leading to a bug where scroll gets re-enabled after user uses pinch zoom. No soultion found yet. \r\n        startEvent.preventDefault();\r\n        onTouchStart(startEvent,this.state,this.canvasRef,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    clearBoard(id) {\r\n        if (this.state.running) return;\r\n        clearBoard(id,this.canvasRef,this.state,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    changeHexSize(s) {\r\n        if (this.state.running || s === this.state.s) return;\r\n        this.setState((prevState) => {\r\n            // check that s is not too large\r\n            let hexSize;\r\n            if (prevState.canvasWidth < prevState.canvasHeight) {\r\n                if (prevState.canvasWidth > 1.5*Math.sqrt(3)*s && prevState.canvasHeight > 3.5*s) hexSize = s;\r\n                else hexSize = Math.min(prevState.canvasWidth/(1.5*Math.sqrt(3)),prevState.canvasHeight/(3.5));\r\n            } else {\r\n                if (prevState.canvasWidth > 2*Math.sqrt(3)*s && prevState.canvasHeight > 2*s) hexSize = s;\r\n                else hexSize = Math.min(prevState.canvasWidth/(2*Math.sqrt(3)),prevState.canvasHeight/(2));\r\n            }\r\n            return Object.assign(\r\n                {}, \r\n                initializeCanvas(prevState.canvasWidth,prevState.canvasHeight,hexSize),\r\n                {updateID: prevState.updateID + 1, canvasUpdates: [], s:hexSize}\r\n            );\r\n        });\r\n    }\r\n\r\n    drawMaze(id) {\r\n        if (this.state.running) return;\r\n        const setState = (stateUpdate) => this.setState(stateUpdate);\r\n        const isRunning = () => {return this.state.running;};\r\n        mazeAnimation(id,this.state,setState,isRunning);\r\n    }\r\n\r\n    toggleTutorial() {\r\n        this.setState((prevState) => {\r\n            return {\r\n                showTutorial: !prevState.showTutorial,\r\n                tutorialPage: 1\r\n            };\r\n        });\r\n    }\r\n\r\n    changePage(direction) {\r\n        this.setState((prevState) => {\r\n            if ((direction === -1 && prevState.tutorialPage === 1) || (direction === 1 && prevState.tutorialPage === 8)) {\r\n                return {};\r\n            } else {\r\n                return {tutorialPage: prevState.tutorialPage + direction};\r\n            }\r\n        });\r\n    }\r\n\r\n    render() {\r\n        const algorithmMap = {\r\n            0: \"Depth-First Search\",\r\n            1: \"Breadth-First Search\",\r\n            2: \"Hill Climbing\",\r\n            3: \"Beam Search (\\u03C9=2)\",\r\n            4: \"Best-First Search\",\r\n            5: \"Branch & Bound\",\r\n            6: \"A* Search\",\r\n            7: \"Random Walk\"\r\n        };\r\n        return (\r\n            <div className=\"PathFinder\">\r\n                {this.state.showTutorial &&\r\n                    <Tutorial className=\"Tutorial\"\r\n                        tutorialPage={this.state.tutorialPage}\r\n                        toggleTutorial={(event) => this.toggleTutorial()}\r\n                        changePage={(direction) => this.changePage(direction)}\r\n                    />\r\n                }\r\n                <div className=\"Bars-Wrapper\">\r\n                    <FontAwesomeIcon className=\"bars\" icon={faBars} onClick={(event) => this.toggleControls()}/>\r\n                    <div className=\"Algorithm-Text\">{algorithmMap[this.state.algorithm]}</div>\r\n                </div>\r\n                <ControlPanel\r\n                    windowState={this.state.windowState}\r\n                    showControls={this.state.showControls}\r\n                    running={this.state.running}\r\n                    hexSize={this.state.s}\r\n                    toggleSelected={(key,id) => this.toggleSelected(key,id)}\r\n                    clearBoard={(id) => this.clearBoard(id)}\r\n                    changeHexSize={(s) => this.changeHexSize(s)}\r\n                    drawMaze={(id) => this.drawMaze(id)}\r\n                    startSearch={() => this.startPathFinder()}\r\n                    stopSearch={() => this.stopPathFinder()}\r\n                />\r\n                <Canvas\r\n                    className=\"canvas\"\r\n                    canvasRef={this.canvasRef}\r\n                    width={this.state.canvasWidth}\r\n                    height={this.state.canvasHeight}\r\n                    s={this.state.s}\r\n                    lineWidth={this.state.lineWidth}\r\n                    xOffset={this.state.xOffset}\r\n                    yOffset={this.state.yOffset}\r\n                    canvasUpdates={this.state.canvasUpdates}\r\n                    startPosition={this.state.startPosition}\r\n                    updateID={this.state.updateID}\r\n                    running={this.state.running}\r\n                    onMouseDown={(downEvent) => this.onMouseDown(downEvent)}\r\n                    onTouchStart={(startEvent) => this.onTouchStart(startEvent)}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathFinder;","import React from 'react';\nimport PathFinder from './components/PathFinder';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFinder />\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}