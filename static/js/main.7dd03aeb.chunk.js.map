{"version":3,"sources":["utils/perlin.js","components/Dropdown.js","components/SliderDropdown.js","components/ControlPanel.js","utils/utils.js","utils/canvas-tools.js","components/Canvas.js","utils/algorithms.js","utils/animations.js","components/PathFinder.js","App.js","serviceWorker.js","index.js"],"names":["global","module","noise","Grad","x","y","z","this","prototype","dot2","dot3","grad3","p","perm","Array","gradP","seed","Math","floor","i","v","F2","sqrt","G2","G3","fade","t","lerp","a","b","simplex2","xin","yin","i1","j1","s","j","x0","y0","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","simplex3","zin","k1","i2","j2","k2","k","z0","z1","z2","x3","y3","z3","gi3","t3","perlin2","X","Y","n00","n01","n10","n11","u","perlin3","Z","n000","n001","n010","n011","n100","n101","n110","n111","w","Dropdown","props","state","listOpen","headerTitle","title","options","windowState","setState","prevState","event","key","toggleList","document","addEventListener","escapeList","backgroundColor","fontColor","className","onClick","style","color","icon","faAngleUp","size","transform","faAngleDown","map","item","id","callBack","selected","faCheck","React","Component","onClickOutside","SliderDropdown","value","hexSize","target","window","innerWidth","innerHeight","type","orient","min","max","onInput","changeValue","onMouseUp","submitValue","onKeyDown","onTouchEnd","ControlPanel","algorithm","speed","tool","mazes","clear","temp","slice","length","toggleSelected","showControls","changeHexSize","drawMaze","clearBoard","running","clickEvent","stopSearch","startSearch","faPause","faPlay","DIRECTIONS","isSameNode","node1","node2","nodeOnBoard","node","xUnits","yUnits","isValidNode","board","findNeighbors","directions","neighbors","change","neighbor","push","manhattanDistance","hexCoord1","hexCoordinates","hexCoord2","dx","dy","sign","abs","ceil2","scalarProd","vectorDiff","v1","v2","vectorSum","vectorAngle","angle","atan","PI","minHeap","lessThan","heap","minValue","shift","unshift","pop","disjointSet","dictionary","hasOwnProperty","parent","xRoot","find","yRoot","shuffleArray","array","arrayCopy","random","getRandomNode","offLimitsSet","randomNode","has","getRandomWallNode","getRandomNeighbor","parseKey","filter","drawLine","startNode","endNode","lineWidth","xOffset","yOffset","canvasRef","canvasUpdates","N","calcHexCenter","startPos","V","line","n","nearestHex","targetNode","Object","assign","fill","object","updateID","moveStart","oldNode","newNode","oldState","moveTarget","drawWeight","pos","sideLength","h","w1","w2","rw","r1","cx","current","getContext","path","beginPath","fillStyle","moveTo","lineTo","closePath","ringCenter","arc","stroke","drawHex","calcHexPath","fillHex","getPointerNode","domNode","rect","getBoundingClientRect","clientX","left","clientY","top","J","I","theta","cos","sin","calcUnits","canvasWidth","canvasHeight","initializeBoard","offset","initializeCanvas","split","parseInt","Canvas","width","height","updateNode","nextProps","prevProps","clearRect","componentDidMount","startPosition","c","oldPos","newPos","drawStartPos","drawNode","drawStart","drawTarget","ref","onMouseDown","downEvent","onTouchStart","startEvent","randomWalk","isRunning","searchUpdates","startTime","Date","getTime","currentNode","lastNode","newState","concat","depthFirst","queue","visitedNodes","Set","currentPath","add","newPath","breadthFirst","hillClimbing","sort","beamSearch","bestFirst","path1","path2","distance","insert","pathWeights","branchNBound","bestDistance","Infinity","bestPath","newDistance","aStarSearch","estimatedDistance","modifiedAStar","console","log","randomWalls","mazePath","dungeon","pathUpdates","randomWeights","depthFirstMaze","nodesToAdd","breadthFirstMaze","kruskalsMaze","unVisitedNodes","pathNodes","disjointPaths","roots","rootsSet","makeSet","union","primsMaze","startFound","targetFound","huntAndKill","newRandomWalk","randomDLA","pathNeighbors","brownianNode","wallDLA","cellularDungeon","newDungeon","wallCount","reduce","state1","state2","simplexCaves","thresholdFunction","ceil","searchSpeed","0","1","2","3","4","drawPathSpeed","moveDownPathSpeed","victorySpeed","drawMazeSpeed","pathFinderAnimation","pathFinder","hexsPerSecond","lastTime","currentStart","steps","totalHexs","requestAnimationFrame","frame","time","start","boardUpdates","update","updateAnimation","totalSteps","totalTime","prevStartNode","prevEndNode","endPos","prevNode","radiansPerSecond","targetPos","startAngle","pos1","pos2","nodeDistance","victoryAnimation","moveDownPathAnimation","drawPathAnimation","searchAnimation","mazeAnimation","mazeID","mazeBuilder","clearTheWay","lightWeightBaby","doTheJohnWall","PathFinder","getWindowState","createRef","handleResize","stateUpdate","button","onMove","onMoveType","canvas","origNode","move","moveEvent","buttons","removeEventListener","oldStart","newStart","oldTarget","newTarget","preventDefault","touches","end","endEvent","currentState","includes","faBars","toggleControls","5","6","startPathFinder","stopPathFinder","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.7dd03aeb.chunk.js","sourcesContent":["/*\r\n * A speed-improved perlin and simplex noise algorithms for 2D.\r\n *\r\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\r\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\r\n * Better rank ordering method by Stefan Gustavson in 2012.\r\n * Converted to Javascript by Joseph Gentle.\r\n *\r\n * Version 2012-03-09\r\n *\r\n * This code was placed in the public domain by its original author,\r\n * Stefan Gustavson. You may use it as you see fit, but\r\n * attribution is appreciated.\r\n *\r\n */\r\n\r\n(function(global){\r\n    var module = global.noise = {};\r\n  \r\n    function Grad(x, y, z) {\r\n      this.x = x; this.y = y; this.z = z;\r\n    }\r\n    \r\n    Grad.prototype.dot2 = function(x, y) {\r\n      return this.x*x + this.y*y;\r\n    };\r\n  \r\n    Grad.prototype.dot3 = function(x, y, z) {\r\n      return this.x*x + this.y*y + this.z*z;\r\n    };\r\n  \r\n    var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\r\n                 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\r\n                 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\r\n  \r\n    var p = [151,160,137,91,90,15,\r\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\r\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\r\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\r\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\r\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\r\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\r\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\r\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\r\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\r\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\r\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\r\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\r\n    // To remove the need for index wrapping, double the permutation table length\r\n    var perm = new Array(512);\r\n    var gradP = new Array(512);\r\n  \r\n    // This isn't a very good seeding function, but it works ok. It supports 2^16\r\n    // different seed values. Write something better if you need more seeds.\r\n    module.seed = function(seed) {\r\n      if(seed > 0 && seed < 1) {\r\n        // Scale the seed out\r\n        seed *= 65536;\r\n      }\r\n  \r\n      seed = Math.floor(seed);\r\n      if(seed < 256) {\r\n        seed |= seed << 8;\r\n      }\r\n  \r\n      for(var i = 0; i < 256; i++) {\r\n        var v;\r\n        if (i & 1) {\r\n          v = p[i] ^ (seed & 255);\r\n        } else {\r\n          v = p[i] ^ ((seed>>8) & 255);\r\n        }\r\n  \r\n        perm[i] = perm[i + 256] = v;\r\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\r\n      }\r\n    };\r\n  \r\n    module.seed(0);\r\n  \r\n    /*\r\n    for(var i=0; i<256; i++) {\r\n      perm[i] = perm[i + 256] = p[i];\r\n      gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\r\n    }*/\r\n  \r\n    // Skewing and unskewing factors for 2, 3, and 4 dimensions\r\n    var F2 = 0.5*(Math.sqrt(3)-1);\r\n    var G2 = (3-Math.sqrt(3))/6;\r\n  \r\n    var F3 = 1/3;\r\n    var G3 = 1/6;\r\n  \r\n    // 2D simplex noise\r\n    module.simplex2 = function(xin, yin) {\r\n      var n0, n1, n2; // Noise contributions from the three corners\r\n      // Skew the input space to determine which simplex cell we're in\r\n      var s = (xin+yin)*F2; // Hairy factor for 2D\r\n      var i = Math.floor(xin+s);\r\n      var j = Math.floor(yin+s);\r\n      var t = (i+j)*G2;\r\n      var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n      var y0 = yin-j+t;\r\n      // For the 2D case, the simplex shape is an equilateral triangle.\r\n      // Determine which simplex we are in.\r\n      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\r\n      if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\r\n        i1=1; j1=0;\r\n      } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\r\n        i1=0; j1=1;\r\n      }\r\n      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\r\n      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\r\n      // c = (3-sqrt(3))/6\r\n      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\r\n      var y1 = y0 - j1 + G2;\r\n      var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\r\n      var y2 = y0 - 1 + 2 * G2;\r\n      // Work out the hashed gradient indices of the three simplex corners\r\n      i &= 255;\r\n      j &= 255;\r\n      var gi0 = gradP[i+perm[j]];\r\n      var gi1 = gradP[i+i1+perm[j+j1]];\r\n      var gi2 = gradP[i+1+perm[j+1]];\r\n      // Calculate the contribution from the three corners\r\n      var t0 = 0.5 - x0*x0-y0*y0;\r\n      if(t0<0) {\r\n        n0 = 0;\r\n      } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\r\n      }\r\n      var t1 = 0.5 - x1*x1-y1*y1;\r\n      if(t1<0) {\r\n        n1 = 0;\r\n      } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\r\n      }\r\n      var t2 = 0.5 - x2*x2-y2*y2;\r\n      if(t2<0) {\r\n        n2 = 0;\r\n      } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\r\n      }\r\n      // Add contributions from each corner to get the final noise value.\r\n      // The result is scaled to return values in the interval [-1,1].\r\n      return 70 * (n0 + n1 + n2);\r\n    };\r\n  \r\n    // 3D simplex noise\r\n    module.simplex3 = function(xin, yin, zin) {\r\n      var n0, n1, n2, n3; // Noise contributions from the four corners\r\n  \r\n      // Skew the input space to determine which simplex cell we're in\r\n      var s = (xin+yin+zin)*F3; // Hairy factor for 2D\r\n      var i = Math.floor(xin+s);\r\n      var j = Math.floor(yin+s);\r\n      var k = Math.floor(zin+s);\r\n  \r\n      var t = (i+j+k)*G3;\r\n      var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n      var y0 = yin-j+t;\r\n      var z0 = zin-k+t;\r\n  \r\n      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\r\n      // Determine which simplex we are in.\r\n      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\r\n      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\r\n      if(x0 >= y0) {\r\n        if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\r\n        else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\r\n        else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\r\n      } else {\r\n        if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\r\n        else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\r\n        else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\r\n      }\r\n      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\r\n      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\r\n      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\r\n      // c = 1/6.\r\n      var x1 = x0 - i1 + G3; // Offsets for second corner\r\n      var y1 = y0 - j1 + G3;\r\n      var z1 = z0 - k1 + G3;\r\n  \r\n      var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\r\n      var y2 = y0 - j2 + 2 * G3;\r\n      var z2 = z0 - k2 + 2 * G3;\r\n  \r\n      var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\r\n      var y3 = y0 - 1 + 3 * G3;\r\n      var z3 = z0 - 1 + 3 * G3;\r\n  \r\n      // Work out the hashed gradient indices of the four simplex corners\r\n      i &= 255;\r\n      j &= 255;\r\n      k &= 255;\r\n      var gi0 = gradP[i+   perm[j+   perm[k   ]]];\r\n      var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\r\n      var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\r\n      var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\r\n  \r\n      // Calculate the contribution from the four corners\r\n      var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\r\n      if(t0<0) {\r\n        n0 = 0;\r\n      } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\r\n      }\r\n      var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\r\n      if(t1<0) {\r\n        n1 = 0;\r\n      } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\r\n      }\r\n      var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\r\n      if(t2<0) {\r\n        n2 = 0;\r\n      } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\r\n      }\r\n      var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\r\n      if(t3<0) {\r\n        n3 = 0;\r\n      } else {\r\n        t3 *= t3;\r\n        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\r\n      }\r\n      // Add contributions from each corner to get the final noise value.\r\n      // The result is scaled to return values in the interval [-1,1].\r\n      return 32 * (n0 + n1 + n2 + n3);\r\n  \r\n    };\r\n  \r\n    // ##### Perlin noise stuff\r\n  \r\n    function fade(t) {\r\n      return t*t*t*(t*(t*6-15)+10);\r\n    }\r\n  \r\n    function lerp(a, b, t) {\r\n      return (1-t)*a + t*b;\r\n    }\r\n  \r\n    // 2D Perlin Noise\r\n    module.perlin2 = function(x, y) {\r\n      // Find unit grid cell containing point\r\n      var X = Math.floor(x), Y = Math.floor(y);\r\n      // Get relative xy coordinates of point within that cell\r\n      x = x - X; y = y - Y;\r\n      // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n      X = X & 255; Y = Y & 255;\r\n  \r\n      // Calculate noise contributions from each of the four corners\r\n      var n00 = gradP[X+perm[Y]].dot2(x, y);\r\n      var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\r\n      var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\r\n      var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\r\n  \r\n      // Compute the fade curve value for x\r\n      var u = fade(x);\r\n  \r\n      // Interpolate the four results\r\n      return lerp(\r\n          lerp(n00, n10, u),\r\n          lerp(n01, n11, u),\r\n         fade(y));\r\n    };\r\n  \r\n    // 3D Perlin Noise\r\n    module.perlin3 = function(x, y, z) {\r\n      // Find unit grid cell containing point\r\n      var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\r\n      // Get relative xyz coordinates of point within that cell\r\n      x = x - X; y = y - Y; z = z - Z;\r\n      // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n      X = X & 255; Y = Y & 255; Z = Z & 255;\r\n  \r\n      // Calculate noise contributions from each of the eight corners\r\n      var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\r\n      var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\r\n      var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\r\n      var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\r\n      var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\r\n      var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\r\n      var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\r\n      var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\r\n  \r\n      // Compute the fade curve value for x, y, z\r\n      var u = fade(x);\r\n      var v = fade(y);\r\n      var w = fade(z);\r\n  \r\n      // Interpolate\r\n      return lerp(\r\n          lerp(\r\n            lerp(n000, n100, u),\r\n            lerp(n001, n101, u), w),\r\n          lerp(\r\n            lerp(n010, n110, u),\r\n            lerp(n011, n111, u), w),\r\n         v);\r\n    };\r\n  \r\n  })(this);","import React from 'react';\r\nimport onClickOutside from 'react-onclickoutside';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleUp , faAngleDown, faCheck } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass Dropdown extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            listOpen: false,\r\n            headerTitle: this.props.title,\r\n            options: this.props.options\r\n        }\r\n    }\r\n\r\n    handleClickOutside() {\r\n        if (this.props.windowState === 1) return;\r\n        this.setState({listOpen: false});\r\n    }\r\n\r\n    toggleList() {\r\n        this.setState(prevState => ({\r\n            listOpen: !prevState.listOpen\r\n        }));\r\n    }\r\n\r\n    escapeList(event) {\r\n        if (this.state.listOpen && event.key === 'Escape') this.toggleList();\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('keydown',(event) => this.escapeList(event));\r\n    }\r\n\r\n    render() {\r\n        const {listOpen, headerTitle, options} = this.state;\r\n        let backgroundColor, fontColor;\r\n        if (this.props.windowState === 1 || this.props.windowState === 2) {\r\n            if (listOpen) [ backgroundColor , fontColor ] = ['#27af62' , 'white' ];\r\n            else [ backgroundColor , fontColor ] = [ 'white' , 'black' ];\r\n        } else [ backgroundColor , fontColor ] = [ '#191414' , 'white' ];\r\n        return (\r\n            <div className=\"Dropdown\">\r\n                <div className=\"Dropdown-header-wrapper\">\r\n                    <div className=\"Dropdown-header\" onClick={() => this.toggleList()} style = {{backgroundColor: backgroundColor, color:fontColor}}>\r\n                        <div className=\"Dropdown-header-title\">{headerTitle}</div>\r\n                        {listOpen\r\n                            ? <FontAwesomeIcon className=\"angle-up\" icon={faAngleUp} size=\"lg\" transform=\"down-1\"/>\r\n                            : <FontAwesomeIcon className=\"angle-down\" icon={faAngleDown} size=\"lg\" transform=\"down-1\"/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n                {listOpen && <ul className={headerTitle+\"-Dropdown-list\"}>\r\n                    {options.map((item) => (\r\n                        <li key={item.id} className=\"Dropdown-list-item\" onClick={() => this.props.callBack(item.id,item.key,item.title)}>\r\n                            {item.title}\r\n                            {item.selected && <FontAwesomeIcon className=\"check\" icon={faCheck} size=\"1x\"/>}\r\n                        </li>\r\n                    ))}\r\n                </ul>}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default onClickOutside(Dropdown);","import React from 'react';\r\nimport onClickOutside from 'react-onclickoutside';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleUp , faAngleDown} from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass SliderDropdown extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            listOpen: false,\r\n            headerTitle: this.props.title,\r\n            value: this.props.hexSize\r\n        }\r\n    }\r\n\r\n    handleClickOutside() {\r\n        if (this.props.windowState === 1) return;\r\n        this.setState({\r\n            listOpen: false\r\n        });\r\n    }\r\n\r\n    toggleList() {\r\n        this.setState(prevState => ({\r\n            listOpen: !prevState.listOpen\r\n        }));\r\n    }\r\n\r\n    changeValue(event) {\r\n        this.setState({value:event.target.value});\r\n    }\r\n\r\n    submitValue(event) {\r\n        this.props.callBack(event.target.value);\r\n    }\r\n\r\n    escapeList(event) {\r\n        if (this.state.listOpen && event.key === 'Escape') this.toggleList();\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('keydown',(event) => this.escapeList(event));\r\n    }\r\n\r\n    render() {\r\n        let backgroundColor, fontColor;\r\n        if (window.innerWidth < 481 || window.innerHeight < 481) {\r\n            if (this.state.listOpen) [ backgroundColor , fontColor ] = ['#27af62' , 'white' ];\r\n            else [ backgroundColor , fontColor ] = [ 'white' , 'black' ];\r\n        } else [ backgroundColor , fontColor ] = [ '#191414' , 'white' ];\r\n        return (\r\n            <div className=\"Dropdown\">\r\n                <div className=\"Dropdown-header-wrapper\">\r\n                    <div className=\"Dropdown-header\" onClick={() => this.toggleList()} style = {{backgroundColor: backgroundColor, color:fontColor}}>\r\n                        <div className=\"Dropdown-header-title\">{this.state.headerTitle}</div>\r\n                        {this.state.listOpen\r\n                            ? <FontAwesomeIcon className=\"angle-up\" icon={faAngleUp} size=\"lg\" transform=\"down-1\"/>\r\n                            : <FontAwesomeIcon className=\"angle-down\" icon={faAngleDown} size=\"lg\" transform=\"down-1\"/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n                {this.state.listOpen && <div className={\"SliderDropdown-list\"}>\r\n                    <div className=\"slider-text\">{this.state.value}</div>\r\n                    <input className=\"slider\" type=\"range\" orient=\"vertical\" min=\"5\" max=\"100\"\r\n                        value={this.state.value}\r\n                        onInput={(event) => this.changeValue(event)}\r\n                        onMouseUp={(event) => this.submitValue(event)}\r\n                        onKeyDown={(event) => {if (event.key === \"Enter\") this.submitValue(event);}}\r\n                        onTouchEnd={(event) => this.submitValue(event)}\r\n                    />\r\n                </div>}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default onClickOutside(SliderDropdown);","import React from 'react';\r\nimport Dropdown from './Dropdown';\r\nimport SliderDropdown from './SliderDropdown';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faPlay , faPause } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass ControlPanel extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            algorithm: [\r\n                        {id:7, title:'Random Walk', selected:false, key:'algorithm'},\r\n                        {id:0, title:'Depth-First Search', selected:false, key:'algorithm'},\r\n                        {id:1, title:'Breadth-First Search', selected:false, key:'algorithm'},\r\n                        {id:2, title:'Hill Climbing', selected:false, key:'algorithm'},\r\n                        {id:3, title:'Beam Search (\\u03C9=2)', selected:false, key:'algorithm'},\r\n                        {id:4, title:'Best-First Search', selected:false, key:'algorithm'},\r\n                        {id:5, title:'Branch & Bound', selected:true, key:'algorithm'},\r\n                        {id:6, title:'A* Search', selected:false, key:'algorithm'}\r\n            ],\r\n            speed: [\r\n                        {id:0, title:'Slow', selected:false, key:'speed'},\r\n                        {id:1, title:'Medium', selected:false, key:'speed'},\r\n                        {id:2, title:'Fast', selected:true, key:'speed'},\r\n                        {id:3, title:'Ludicrous', selected:false, key:'speed'},\r\n                        {id:4, title:'Instant', selected:false, key:'speed'}\r\n            ],\r\n            tool: [\r\n                        {id:0, title:'Walls', selected:true, key:'tool'},\r\n                        {id:1, title:'Weights', selected:false, key:'tool'},\r\n                        {id:2, title:'Eraser', selected:false, key:'tool'}\r\n            ],\r\n            mazes: [\r\n                        {id:0, title:'Random Walls', selected:false, key:'mazes'},\r\n                        {id:1, title:'Random Weights', selected:false, key:'mazes'},\r\n                        {id:2, title:'Depth-First Maze', selected:false, key:'mazes'},\r\n                        {id:3, title:'Breadth-First Maze', selected:false, key:'mazes'},\r\n                        {id:4, title:\"Hunt & Kill Maze\", selected:false, key:'mazes'},\r\n                        {id:5, title:\"Prim's Maze\", selected:false, key:'mazes'},\r\n                        {id:6, title:\"Kruskal's Maze\", selected:false, key:'mazes'},\r\n                        {id:7, title:\"Random DLA Fractal\", selected:false, key:'mazes'},\r\n                        {id:8, title:\"Wall DLA Fractal\", selected:false, key:'mazes'},\r\n                        {id:9, title:\"Cellular Caves\", selected:false, key:'mazes'},\r\n                        {id:10, title:\"Simplex Caves\", selected:false, key:'mazes'}\r\n            ],\r\n            clear: [\r\n                        {id:1, title:'Path', selected:false, key:'clear'},\r\n                        {id:2, title:'Walls', selected:false, key:'clear'},\r\n                        {id:3, title:'Weights', selected:false, key:'clear'},\r\n                        {id:0, title:'Board', selected:false, key:'clear'},\r\n                        {id:4, title:'Canvas', selected:false, key:'clear'}\r\n            ]\r\n        }\r\n    }\r\n\r\n    toggleSelected(id,key,title) {\r\n        if (key !== 'clear') {\r\n            let temp = this.state[key].slice();\r\n            for (let i = 0; i < temp.length; i++) {\r\n                temp[i].selected = (id === temp[i].id);\r\n            }\r\n            this.setState({\r\n                [key]:temp\r\n            });\r\n        }\r\n        this.props.toggleSelected(key,id);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"ControlPanel\">\r\n                {this.props.showControls &&\r\n                    <div className=\"Controls-Wrapper-Background\">\r\n                        <div className=\"Controls-Wrapper\">\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Algorithm-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Algorithm'} \r\n                                    options={this.state.algorithm}\r\n                                    callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\"> \r\n                                <Dropdown className=\"Speed-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Speed'} \r\n                                    options={this.state.speed}\r\n                                    callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Tool-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Tool'} \r\n                                    options={this.state.tool}\r\n                                    callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <SliderDropdown className=\"Hex-Size-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Hex Size'}\r\n                                    hexSize={this.props.hexSize}\r\n                                    callBack = {(s) => this.props.changeHexSize(s)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Mazes-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Mazes'} \r\n                                    options={this.state.mazes}\r\n                                    callBack = {(id,key,title) => this.props.drawMaze(id)}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Clear-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Clear'} \r\n                                    options={this.state.clear}\r\n                                    callBack = {(id,key,title) => this.props.clearBoard(id)}\r\n                                />\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                }\r\n                <div className=\"Play-Button-Wrapper\">\r\n                    <div className=\"Play-Button\" onClick={this.props.running\r\n                        ? (clickEvent) => this.props.stopSearch()\r\n                        : (clickEvent) => this.props.startSearch()\r\n                    }>\r\n                        {this.props.running\r\n                            ? <FontAwesomeIcon className=\"pause\" icon={faPause}/>\r\n                            : <FontAwesomeIcon className=\"play\" icon={faPlay}/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ControlPanel;","//=====================================================================================//\r\n// Constants //\r\n\r\nimport { parseKey } from \"./canvas-tools\";\r\n\r\n//=====================================================================================//\r\nconst DIRECTIONS = {\r\n    even: [\r\n            { i:0  , j:1 },\r\n            { i:-1 , j:0 },\r\n            { i:-1 , j:-1 },\r\n            { i:0  , j:-1 },\r\n            { i:1  , j:-1 },\r\n            { i:1  , j:0 }\r\n    ],\r\n    odd: [\r\n            { i:0  , j:1 },\r\n            { i:-1 , j:1 },\r\n            { i:-1 , j:0 },\r\n            { i:0  , j:-1 },\r\n            { i:1  , j:0 },\r\n            { i:1  , j:1 }\r\n    ]\r\n};\r\n\r\n//=====================================================================================//\r\n// Helper Functions //\r\n//=====================================================================================//\r\n\r\n// Node Functions: node = {i:i,j:j}//\r\n//=================================//\r\nfunction isSameNode(node1,node2) {\r\n    return (node1.i === node2.i && node1.j === node2.j);\r\n};\r\n\r\nfunction nodeInPath(node,path) {\r\n    for (let pathNode of path) {\r\n        if (isSameNode(node,pathNode)) return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nfunction addNodes(node1,node2) {\r\n    return { i:(node1.i + node2.i) , j:(node1.j + node2.j) };\r\n};\r\n\r\nfunction nodeOnBoard(node,xUnits,yUnits) {\r\n    return (node.i>=0 && node.j>=0 && node.i<xUnits && node.j<yUnits);\r\n};\r\n\r\nfunction isValidNode(node,board,xUnits,yUnits) {\r\n    let state = board[[node.i,node.j]];\r\n    let onBoard = nodeOnBoard(node,xUnits,yUnits);\r\n    return (onBoard && state.type !== 'wall');\r\n};\r\n\r\nfunction findNeighbors(node) {\r\n    let neighbors = [];\r\n    let directions;\r\n    if (node.i%2 === 0) directions = DIRECTIONS.even;\r\n    else directions = DIRECTIONS.odd;\r\n    for (let change of directions) {\r\n        let neighbor = addNodes(node,change);\r\n        neighbors.push(neighbor);\r\n    }\r\n    return neighbors;\r\n};\r\n\r\nfunction manhattanDistance(node1,node2) {\r\n    const hexCoord1 = hexCoordinates(node1);\r\n    const hexCoord2 = hexCoordinates(node2);\r\n    const dx = hexCoord2.x - hexCoord1.x;\r\n    const dy = hexCoord2.y - hexCoord1.y;\r\n    if (Math.sign(dx) === Math.sign(dy)) {\r\n        return Math.max(Math.abs(dx), Math.abs(dy));\r\n    }\r\n    return Math.abs(dx) + Math.abs(dy);\r\n};\r\n\r\nfunction hexCoordinates(node) {\r\n    return { x: node.j - floor2(node.i) , y: node.j + ceil2(node.i) };\r\n};\r\n\r\nfunction floor2(x) {\r\n    return ((x >= 0) ? (x >> 1) : (x - 1) / 2);\r\n};\r\n\r\nfunction ceil2(x) {\r\n    return ((x >= 0) ? ((x + 1) >> 1) : x / 2);\r\n}\r\n\r\n// Vectors Functions: v = {x:x,y:y} //\r\n//==================================//\r\nfunction dotProduct(v1,v2) {\r\n    return v1.x*v2.x + v1.y*v2.y;\r\n};\r\n\r\nfunction scalarProd(a,v) {\r\n    return {x:a*v.x , y:a*v.y};\r\n};\r\n\r\nfunction vectorDiff(v1,v2) {\r\n    return {x: v1.x - v2.x, y: v1.y - v2.y};\r\n};\r\n\r\nfunction vectorSum(v1,v2) {\r\n    return {x: v1.x + v2.x, y: v1.y + v2.y};\r\n};\r\n\r\nfunction vectorMag(v) {\r\n    return Math.sqrt((v.x)**2 + (v.y)**2);\r\n};\r\n\r\nfunction vectorOrthoMag(v,V) {\r\n    let b = scalarProd(dotProduct(v,V)/(vectorMag(V))**2, V);\r\n    let d =  vectorDiff(v, b);\r\n    return vectorMag(d);\r\n};\r\n\r\nfunction vectorAngle(v) {\r\n    let angle = Math.atan( v.y / v.x );\r\n    if (v.x < 0) angle += Math.PI;\r\n    return angle;\r\n};\r\n\r\n// Data Structures for Algorithms //\r\n//==================================//\r\nclass minHeap {\r\n    constructor(lessThan) {\r\n        this.heap = [];\r\n        this.lessThan = lessThan\r\n    }\r\n\r\n    length() {\r\n        return this.heap.length;\r\n    }\r\n\r\n    getMin() {\r\n        return this.heap[0];\r\n    }\r\n\r\n    insert(value) {\r\n        this.heap.push(value);\r\n        let i = this.heap.length-1;\r\n        while (i > 0) {\r\n            if (this.lessThan(this.heap[i] , this.heap[Math.floor((i-1)/2)])) {\r\n                [ this.heap[Math.floor((i-1)/2)] , this.heap[i] ] = [ this.heap[i] , this.heap[Math.floor((i-1)/2)] ];\r\n                i = Math.floor((i-1)/2);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    shift() {\r\n        const minValue = this.heap.shift();\r\n        if (this.heap.length === 0) return minValue;\r\n        this.heap.unshift(this.heap.pop());\r\n        let i = 0;\r\n        while (2*i+2 < this.heap.length) {\r\n            if (this.lessThan(this.heap[2*i+1], this.heap[i]) || this.lessThan(this.heap[2*i+2], this.heap[i])) {\r\n                if (this.lessThan(this.heap[2*i+1], this.heap[2*i+2])) {\r\n                    [ this.heap[2*i+1], this.heap[i] ] = [ this.heap[i] , this.heap[2*i+1] ];\r\n                    i = 2*i + 1;\r\n                } else {\r\n                    [ this.heap[2*i+2], this.heap[i] ] = [ this.heap[i] , this.heap[2*i+2] ];\r\n                    i = 2*i + 2;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return minValue;\r\n    }\r\n};\r\n\r\nclass disjointSet {\r\n    constructor() {\r\n        this.dictionary = {};\r\n    }\r\n\r\n    makeSet(x) {\r\n        if (this.dictionary.hasOwnProperty(x)) return;\r\n        else {\r\n            this.dictionary[x] = {\r\n                parent: x,\r\n                size: 1\r\n            }\r\n        }\r\n    }\r\n\r\n    find(y) {\r\n        // using path splitting to improve performance\r\n        let x = y;\r\n        while (this.dictionary[x].parent !== x) {\r\n            let parent = this.dictionary[x].parent;\r\n            let grandparent = this.dictionary[parent].parent;\r\n            [ x , this.dictionary[x].parent ] = [ parent , grandparent ];\r\n        }\r\n        return x;\r\n    }\r\n\r\n    union(x,y) {\r\n        // using size, again to improve performance\r\n        let xRoot = this.find(x);\r\n        let yRoot = this.find(y);\r\n        if (xRoot === yRoot) return;\r\n        if (this.dictionary[xRoot].size < this.dictionary[yRoot]) {\r\n            [ xRoot , yRoot ] = [ yRoot , xRoot ];\r\n        }\r\n        this.dictionary[yRoot].parent = xRoot;\r\n        this.dictionary[xRoot].size += this.dictionary[yRoot].size;\r\n    }\r\n};\r\n\r\nfunction shuffleArray(array) {\r\n    let arrayCopy = array.slice();\r\n    for (let i = arrayCopy.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [arrayCopy[i], arrayCopy[j]] = [arrayCopy[j], arrayCopy[i]];\r\n    }\r\n    return arrayCopy;\r\n};\r\n\r\nfunction getRandomNode(xUnits,yUnits,offLimitsSet) {\r\n    let randomNode;\r\n    do {\r\n        randomNode = Math.floor(Math.random()*xUnits)+','+Math.floor(Math.random()*yUnits);\r\n    } while (offLimitsSet.has(randomNode));\r\n    return randomNode;\r\n};\r\n\r\nfunction getRandomWallNode(xUnits,yUnits,offLimitsSet) {\r\n    let randomNode;\r\n    do {\r\n        if (Math.random() < .5) {\r\n            if (Math.random() < .5) {\r\n                randomNode = 0+','+Math.floor(Math.random()*yUnits);\r\n            } else {\r\n                randomNode = (xUnits-1)+','+Math.floor(Math.random()*yUnits);\r\n            }\r\n        } else {\r\n            if (Math.random() < .5) {\r\n                randomNode = Math.floor(Math.random()*xUnits)+','+0;\r\n            } else {\r\n                randomNode = Math.floor(Math.random()*xUnits)+','+(yUnits-1);\r\n            }\r\n        }\r\n    } while (offLimitsSet.has(randomNode));\r\n    return randomNode;\r\n};\r\n\r\nfunction getRandomNeighbor(node,xUnits,yUnits) {\r\n    let neighbors = findNeighbors(parseKey(node))\r\n                    .filter((node) => nodeOnBoard(node,xUnits,yUnits))\r\n                    .map((node) => (node.i+','+node.j));\r\n    return neighbors[Math.floor(Math.random()*neighbors.length)];\r\n};\r\n\r\n\r\n//=====================================================================================//\r\n// Exports //\r\n//=====================================================================================//\r\nexport {isSameNode, nodeInPath, addNodes, nodeOnBoard, isValidNode, findNeighbors, manhattanDistance};      // node functions\r\nexport {dotProduct, scalarProd, vectorDiff, vectorSum, vectorMag, vectorOrthoMag, vectorAngle};             // vector functions\r\nexport {minHeap, disjointSet, shuffleArray, getRandomNode, getRandomWallNode, getRandomNeighbor};                              // algorithm data structures\r\n","import {isSameNode, nodeOnBoard, manhattanDistance, scalarProd, vectorSum, vectorDiff} from './utils';\r\n\r\n//=====================================================================================//\r\n// Canvas Mouse and Touch Trackers for Drawing and Manipulating Board //\r\n//=====================================================================================//\r\nfunction onMouseDown(downEvent,state,canvasRef,setState) {\r\n    if (downEvent.button !== 0) return;\r\n    let canvas = canvasRef.current;\r\n    let node = getPointerNode(downEvent,canvas,state.s,state.xOffset,state.yOffset);\r\n    let origNode = node;\r\n    let onMove, onMoveType;\r\n    if (isSameNode(node,state.startNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) =>\r\n        moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 1;\r\n    } else if (isSameNode(node,state.targetNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) => \r\n        moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 2;\r\n    } else {\r\n        drawLine(node,node,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        onMove = (startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) => \r\n        drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits);\r\n        onMoveType = 0;\r\n    }\r\n    let move = (moveEvent) => {\r\n        if (moveEvent.buttons === 0) {\r\n            canvas.removeEventListener(\"mousemove\", move);\r\n            let board = {};\r\n            if (onMoveType === 1) {\r\n                let oldStart = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n                let newStart = {[[node.i,node.j]]: {node:node,type:'start',fill:'white',object:'start'}};\r\n                Object.assign(board, state.board, oldStart, newStart);\r\n                setState({board:board});\r\n            } else if (onMoveType === 2) {\r\n                let oldTarget = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n                let newTarget = {[[node.i,node.j]]: {node:node,type:'target',fill:'white',object:'target'}};\r\n                Object.assign(board, state.board, oldTarget, newTarget);\r\n                setState({board:board});\r\n            }\r\n        } else {\r\n            let newNode = getPointerNode(moveEvent,canvas,state.s,state.xOffset,state.yOffset);\r\n            if (isSameNode(newNode,node)) return;\r\n            if ( \r\n                    (onMoveType !== 0 && !nodeOnBoard(newNode,state.xUnits,state.yUnits))\r\n                ||  (onMoveType === 1 && isSameNode(newNode,state.targetNode))\r\n                ||  (onMoveType === 2 && isSameNode(newNode,state.startNode))\r\n            ) return;\r\n            onMove(node,newNode,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n                (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n            node = newNode;\r\n        }\r\n    };\r\n    canvas.addEventListener(\"mousemove\", move);\r\n};\r\n\r\n\r\nfunction onTouchStart(startEvent,state,canvasRef,setState) {\r\n    let canvas = canvasRef.current;\r\n    let node = getPointerNode(startEvent.touches[0],canvas,state.s,state.xOffset,state.yOffset);\r\n    let origNode = node;\r\n    let onMove, onMoveType;\r\n    if (isSameNode(node,state.startNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) =>\r\n        moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 1;\r\n    } else if (isSameNode(node,state.targetNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) => \r\n        moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 2;\r\n    } else {\r\n        drawLine(node,node,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        onMove = (startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) => \r\n        drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits);\r\n        onMoveType = 0;\r\n    }\r\n    let move = (moveEvent) => {\r\n        let newNode = getPointerNode(moveEvent.touches[0],canvas,state.s,state.xOffset,state.yOffset);\r\n        if (isSameNode(newNode,node)) return;\r\n        if ( \r\n                (onMoveType !== 0 && !nodeOnBoard(newNode,state.xUnits,state.yUnits))\r\n            ||  (onMoveType === 1 && isSameNode(newNode,state.targetNode))\r\n            ||  (onMoveType === 2 && isSameNode(newNode,state.startNode))\r\n        ) return;\r\n        onMove(node,newNode,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        node = newNode;\r\n    };\r\n    let end = (endEvent) => {\r\n        canvas.removeEventListener(\"touchmove\", move);\r\n        canvas.removeEventListener(\"touchend\", end);\r\n        let board = {};\r\n        if (onMoveType === 1) {\r\n            let oldStart = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n            let newStart = {[[node.i,node.j]]: {node:node,type:'start',fill:'white',object:'start'}};\r\n            Object.assign(board, state.board, oldStart, newStart);\r\n            setState({board:board});\r\n        } else if (onMoveType === 2) {\r\n            let oldTarget = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n            let newTarget = {[[node.i,node.j]]: {node:node,type:'target',fill:'white',object:'target'}};\r\n            Object.assign(board, state.board, oldTarget, newTarget);\r\n            setState({board:board});\r\n        }\r\n    }\r\n    canvas.addEventListener(\"touchmove\", move);\r\n    canvas.addEventListener(\"touchend\", end);\r\n};\r\n\r\n//=====================================================================================//\r\n// Canvas Tools //\r\n//=====================================================================================//\r\nfunction drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) {\r\n    // Initialize object for storing updates to the canvas\r\n    let canvasUpdates = {};\r\n    // Get Manhatton Distance from startNode to endNode\r\n    const N = manhattanDistance(startNode,endNode);\r\n    //Get equation of line from startNode to endNode\r\n    const [ startPos , endPos ] = [ calcHexCenter(startNode,s,xOffset,yOffset) , calcHexCenter(endNode,s,xOffset,yOffset) ];\r\n    const V = vectorDiff(endPos,startPos);\r\n    const line = (n) => {\r\n        if (N === 0) return startPos;\r\n        else return vectorSum( scalarProd(n/N,V) , startPos );\r\n    }\r\n    // Sample N+1 points along line and fill in hexs these points lie in; however, break the loop if we go off the board\r\n    // Also don't fill in the node if it is the startNode or targetNode\r\n    for (let n = 0; n <= N; n++) {\r\n        const pos = line(n);\r\n        const node = nearestHex(pos,s,xOffset,yOffset);\r\n        //console.log(n);\r\n        //console.log(pos);\r\n        //console.log(node);\r\n        if (!nodeOnBoard(node,xUnits,yUnits)) break;\r\n        if (isSameNode(node,state.startNode) || isSameNode(node,state.targetNode)) continue;\r\n        // Fill in hex according to selected tool\r\n        if (state.tool === 0 && state.board[[node.i,node.j]].type !== 'wall') {\r\n            Object.assign(canvasUpdates, {[[node.i,node.j]]: {node:node,type:'wall',fill:'#282c34',object:null,angle:null}});\r\n        } else if (state.tool === 1 && state.board[[node.i,node.j]].type !== 'weight') {\r\n            Object.assign(canvasUpdates, {[[node.i,node.j]]: {node:node,type:'weight',fill:'white',object:'weight',angle:null}});\r\n        } else if (state.tool === 2 && state.board[[node.i,node.j]].type !== 'empty') {\r\n            Object.assign(canvasUpdates, {[[node.i,node.j]]: {node:node,type:'empty',fill:'white',object:null,angle:null}});\r\n        }\r\n    }\r\n    // Update state\r\n    setState((prevState) => {\r\n        return {\r\n                    board: Object.assign({},prevState.board,canvasUpdates),\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\n// Old drawLine. Not quite as efficient as new one, or easy to understand\r\n/*\r\nfunction drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) {\r\n    // Setting start of path\r\n    let currentNode = startNode;\r\n    let V = nodeDistance(endNode,startNode,s,xOffset,yOffset);\r\n    // Fill start if not off board and not start/target node\r\n    let canvasUpdates = {};\r\n    if (nodeOnBoard(currentNode,xUnits,yUnits) &&  !isSameNode(currentNode,state.startNode) &&  !isSameNode(currentNode,state.targetNode)\r\n    ) {\r\n        // might be a problem that currentNode changes over time\r\n        if (state.tool === 0) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'wall',fill:'#282c34',object:null}});\r\n        } else if (state.tool === 1) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'weight',fill:'white',object:'weight'}});\r\n        } else if (state.tool === 2) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'empty',fill:'white',object:null}});\r\n        }\r\n    }\r\n    // Looping over path\r\n    while (!isSameNode(currentNode,endNode)) {\r\n        // Reset minDis\r\n        let minDis = Infinity;\r\n        // Find next hex to move to by looping over adjacent hexs\r\n        let neighbors = findNeighbors(currentNode);\r\n        let tempNode = Object.assign({},currentNode);\r\n        for (let neighbor of neighbors) {\r\n            let v = nodeDistance(neighbor,tempNode,s,xOffset,yOffset);\r\n            let dotProd = dotProduct(v,V);\r\n            if (dotProd >= 0) {\r\n                v = nodeDistance(neighbor,startNode,s,xOffset,yOffset);\r\n                let currentDis = vectorOrthoMag(v,V);\r\n                if (currentDis < minDis) {\r\n                    currentNode = neighbor;\r\n                    minDis = currentDis;\r\n                }\r\n            }\r\n        }\r\n        // If next hex off board then end path\r\n        if (!nodeOnBoard(currentNode,xUnits,yUnits)) break;\r\n        // Fill next hex unless it is start or target node\r\n        else if (!isSameNode(currentNode,state.startNode) && !isSameNode(currentNode,state.targetNode)) {\r\n            // might be a problem that currentNode changes over time\r\n            if (state.tool === 0) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'wall',fill:'#282c34',object:null}});\r\n            } else if (state.tool === 1) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'weight',fill:'white',object:'weight'}});\r\n            } else if (state.tool === 2) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'empty',fill:'white',object:null}});\r\n            }\r\n        }\r\n    }\r\n    // Update state\r\n    setState((prevState) => {\r\n        return {\r\n                    board: Object.assign({},prevState.board,canvasUpdates),\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n*/\r\n\r\nfunction moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) {\r\n    let angle = 0;\r\n    if (state.xUnits > state.yUnits) angle = -Math.PI/2;\r\n    let canvasUpdates = {[[newNode.i,newNode.j]]: {node:newNode,type:'start',fill:'white',object:'start',angle:angle}};             \r\n    const oldState = Object.assign({}, state.board[[oldNode.i,oldNode.j]]);\r\n    if (oldState.type === 'start') {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: {node:oldNode,type:'empty',fill:'white',object:null}});\r\n    } else {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: oldState});\r\n    }\r\n    setState((prevState) => {\r\n        return {\r\n                    startNode: newNode,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\nfunction moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) {\r\n    let canvasUpdates = {[[newNode.i,newNode.j]]: {node:newNode,type:'target',fill:'white',object:'target'}};             \r\n    const oldState = Object.assign({}, state.board[[oldNode.i,oldNode.j]]);\r\n    if (oldState.type === 'target') {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: {node:oldNode,type:'empty',fill:'white',object:null}});\r\n    } else {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: oldState});\r\n    }\r\n    setState((prevState) => {\r\n        return {\r\n                    targetNode: newNode,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\nfunction clearBoard(id,canvasRef,state,setState) {\r\n    if (id === 0) {\r\n        let canvas = canvasRef.current;\r\n        let cx = canvas.getContext('2d');\r\n        cx.clearRect(0,0,canvas.width,canvas.height);\r\n        let [board, startNode, targetNode] = initializeBoard(canvas.width, canvas.height, state.s);\r\n        setState((prevState) => {\r\n            return {\r\n                        board: board, \r\n                        startNode: startNode, \r\n                        targetNode: targetNode, \r\n                        canvasUpdates: board,\r\n                        updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    } else if (id === 4) {\r\n        let canvas = canvasRef.current;\r\n        let cx = canvas.getContext('2d');\r\n        cx.clearRect(0,0,canvas.width,canvas.height);\r\n        let { innerWidth: width, innerHeight: height } = window\r\n        let canvasHeight;\r\n        if (width < 481 || height < 481)  {\r\n            if ( width > height) canvasHeight = height*.85;\r\n            else canvasHeight = height*.8;\r\n        }\r\n        else canvasHeight = height*.9-4;\r\n        let canvasWidth = width;\r\n        let {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset} = initializeCanvas(canvasWidth,canvasHeight,state.s);\r\n        // Setting Initial State\r\n        setState((prevState) => {\r\n            return {\r\n                canvasWidth: canvasWidth,\r\n                canvasHeight: canvasHeight,\r\n                board: board,\r\n                startNode: startNode,\r\n                targetNode: targetNode,\r\n                xUnits: xUnits,\r\n                yUnits: yUnits,\r\n                xOffset: xOffset,\r\n                yOffset: yOffset,\r\n                canvasUpdates: board,\r\n                updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    } else {\r\n        let canvasUpdates = {};\r\n        if (id === 1) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (!['white','#282c34'].includes(currentState.fill)) {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{fill:'white'});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n            Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n        } else if (id === 2) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (currentState.type === 'wall') {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{type:'empty',fill:'white',object:null});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n        } else if (id === 3) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (currentState.type === 'weight') {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{type:'empty',fill:'white',object:null});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        board: Object.assign({},prevState.board,canvasUpdates), \r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    }\r\n};\r\n\r\nfunction doTheJohnWall(state,setState) {\r\n    let canvasUpdates = {};\r\n    for (let key in state.board) {\r\n        Object.assign(canvasUpdates, {[key]: {node:parseKey(key), type:'wall', fill:'#282c34', object:null}});\r\n    }\r\n    Object.assign(canvasUpdates, {[[state.startNode.i,state.startNode.j]]: state.board[[state.startNode.i,state.startNode.j]]});\r\n    Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n    setState((prevState) => {\r\n        return {\r\n                    board: canvasUpdates, \r\n                    canvasUpdates: canvasUpdates,\r\n                    updateID: prevState.updateID + 1\r\n        };\r\n    });\r\n};\r\n\r\nfunction lightWeightBaby(state,setState) {\r\n    let canvasUpdates = {};\r\n    for (let key in state.board) {\r\n        Object.assign(canvasUpdates, {[key]: {node:parseKey(key), type:'weight', fill:'white', object:'weight'}});\r\n    }\r\n    Object.assign(canvasUpdates, {[[state.startNode.i,state.startNode.j]]: state.board[[state.startNode.i,state.startNode.j]]});\r\n    Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n    setState((prevState) => {\r\n        return {\r\n                    board: canvasUpdates, \r\n                    canvasUpdates: canvasUpdates,\r\n                    updateID: prevState.updateID + 1\r\n        };\r\n    });\r\n};\r\n\r\nfunction clearTheWay(state,setState) {\r\n    let canvasUpdates = {};\r\n    for (let key in state.board) {\r\n        Object.assign(canvasUpdates, {[key]: {node:parseKey(key), type:'empty', fill:'white', object:null}});\r\n    }\r\n    Object.assign(canvasUpdates, {[[state.startNode.i,state.startNode.j]]: state.board[[state.startNode.i,state.startNode.j]]});\r\n    Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n    setState((prevState) => {\r\n        return {\r\n                    board: canvasUpdates, \r\n                    canvasUpdates: canvasUpdates,\r\n                    updateID: prevState.updateID + 1\r\n        };\r\n    });\r\n};\r\n\r\n//=====================================================================================//\r\n// Basic Drawing Functions //\r\n//=====================================================================================//\r\nfunction drawSearch(node,s,lineWidth,xOffset,yOffset,canvasRef,board,color) {\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    let state = board[[node.i,node.j]];\r\n    sleep(0).then(() => {\r\n        if (state === 'weight') {\r\n            drawWeight(pos,s,lineWidth,canvasRef,color);\r\n        } else {\r\n            fillHex(pos,s,color,canvasRef);\r\n            drawHex(pos,s,lineWidth,canvasRef)\r\n        }\r\n    });\r\n};\r\n\r\nfunction drawWeight(node,s,lineWidth,xOffset,yOffset,canvasRef){\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    let sideLength = s*.9;\r\n    let h = sideLength;\r\n    let w1 = sideLength;\r\n    let w2 = 1.5*sideLength;\r\n    let rw = sideLength*.18;\r\n    let r1 = sideLength*.33;\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    // draw trapezoid\r\n    let path = [\r\n                    {x:w1/2  , y:-h/2},\r\n                    {x:-w1/2 , y:-h/2},\r\n                    {x:-w2/2 , y:h/2},\r\n                    {x:w2/2  , y:h/2}\r\n    ]\r\n    cx.beginPath();\r\n    cx.fillStyle = 'black';\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i = 1; i < path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n    // draw ring\r\n    cx.beginPath();\r\n    let ringCenter = {x:pos.x, y:pos.y - h/2};\r\n    cx.lineWidth = rw;\r\n    cx.arc(ringCenter.x, ringCenter.y, r1, 0, 7);\r\n    cx.stroke();\r\n};\r\n\r\nfunction drawStart(startNode,s,xOffset,yOffset,canvasRef,angle) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    const r = .85;\r\n    const a = s*Math.sqrt(3)*r/2;\r\n    const b = a/1.3;\r\n    const c = a/2.6;\r\n    let path = [\r\n                { x:a    ,  y:0},\r\n                { x:-2*c ,  y:b},\r\n                { x:-c   ,  y:0},\r\n                { x:-2*c ,  y:-b}\r\n    ];\r\n    if (angle) {\r\n        for (let i=0; i<path.length; i++) {\r\n            let oldPos = path[i];\r\n            let newPos = {\r\n                x: oldPos.x*Math.cos(angle) - oldPos.y*Math.sin(angle),\r\n                y: oldPos.x*Math.sin(angle) + oldPos.y*Math.cos(angle)\r\n            }\r\n            path[i] = newPos;\r\n        }\r\n    }\r\n    let pos = calcHexCenter(startNode,s,xOffset,yOffset);\r\n    cx.fillStyle = 'black';\r\n    cx.beginPath();\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction drawStartPos(pos,s,canvasRef,angle) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    const r = .85;\r\n    const a = s*Math.sqrt(3)*r/2;\r\n    const b = a/1.3;\r\n    const c = a/2.6;\r\n    let path = [\r\n                { x:a    ,  y:0},\r\n                { x:-2*c ,  y:b},\r\n                { x:-c   ,  y:0},\r\n                { x:-2*c ,  y:-b}\r\n    ];\r\n    if (angle) {\r\n        for (let i=0; i<path.length; i++) {\r\n            let oldPos = path[i];\r\n            let newPos = {\r\n                x: oldPos.x*Math.cos(angle) - oldPos.y*Math.sin(angle),\r\n                y: oldPos.x*Math.sin(angle) + oldPos.y*Math.cos(angle)\r\n            }\r\n            path[i] = newPos;\r\n        }\r\n    }\r\n    cx.fillStyle = 'black';\r\n    cx.beginPath();\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction drawTarget(targetNode,s,lineWidth,xOffset,yOffset,canvasRef) {\r\n    const sideLength = s;\r\n    let pos = calcHexCenter(targetNode,s,xOffset,yOffset);\r\n    // Outer Ring\r\n    fillHex(pos,sideLength,'#b22222',canvasRef);\r\n    // White Fill\r\n    fillHex(pos,sideLength*2/3 - lineWidth/2,'white',canvasRef);\r\n    // Inner Ring\r\n    fillHex(pos,sideLength/3,'#b22222',canvasRef);\r\n    // Remake Border\r\n    drawHex(pos,sideLength,lineWidth,canvasRef);\r\n};\r\n\r\nfunction drawNode(node,s,lineWidth,xOffset,yOffset,color,canvasRef) {\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    fillHex(pos,s,color,canvasRef);\r\n    drawHex(pos,s,lineWidth,canvasRef);\r\n};\r\n\r\n\r\n//=====================================================================================//\r\n// Helper Functions //\r\n//=====================================================================================//\r\n\r\n// Helpers for Canvas Tools//\r\n//========================================//\r\nfunction drawHex(pos,s,lineWidth,canvasRef) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    let path = calcHexPath(pos,s);\r\n    cx.lineWidth = lineWidth;\r\n    cx.beginPath();\r\n    cx.moveTo(path[0].x,path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(path[i].x,path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.stroke();\r\n};\r\n\r\nfunction fillHex(pos,s,color,canvasRef) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    cx.fillStyle = color;\r\n    let path = calcHexPath(pos,s);\r\n    cx.beginPath();\r\n    cx.moveTo(path[0].x, path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(path[i].x,path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n};\r\n\r\nfunction getPointerNode(event,domNode,s,xOffset,yOffset) {\r\n    let rect = domNode.getBoundingClientRect();\r\n    let x = event.clientX - rect.left;\r\n    let y = event.clientY - rect.top;\r\n    return nearestHex({x:x,y:y},s,xOffset,yOffset);\r\n};\r\n\r\n// Functions That Peform Grid Calculations//\r\n//========================================//\r\nfunction calcHexCenter(node,s,xOffset,yOffset) {\r\n    const x = xOffset + (node.j + 1 - ((node.i+1)%2)/2)*s*Math.sqrt(3);\r\n    const y = yOffset + (1.5*node.i + 1)*s\r\n    return {x:x, y:y};\r\n};\r\n\r\nfunction nodeDistance(node1,node2,s,xOffset,yOffset) {\r\n    let pos1 = calcHexCenter(node1,s,xOffset,yOffset);\r\n    let pos2 = calcHexCenter(node2,s,xOffset,yOffset);\r\n    return {x:(pos1.x - pos2.x) , y:(pos1.y - pos2.y)};\r\n};\r\n\r\nfunction nearestHex(pos,s,xOffset,yOffset) {\r\n    const J = Math.floor((pos.x - xOffset)/(s*Math.sqrt(3)));\r\n    const I = Math.floor((pos.y - yOffset)/(1.5*s));\r\n    const u = (pos.x - xOffset)/(s*Math.sqrt(3)) - J;\r\n    const v = 1 - ((pos.y - yOffset)/(1.5*s) - I);\r\n    let i, j;\r\n    if (I%2 === 0) {\r\n        if (u < .5) {\r\n            if (v > (2/3*u + 2/3)) {\r\n                [ i , j ] = [ I-1 , J-1 ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        } else {\r\n            if (v > (-2/3*u + 4/3)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        }\r\n    } else {\r\n        if (u < .5) {\r\n            if (v > (-2/3*u + 1)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J-1 ];\r\n            }\r\n        } else {\r\n            if (v > (2/3*u + 1/3)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        }\r\n    }\r\n    return {i:i,j:j};\r\n};\r\n\r\nfunction calcHexPath(pos, s) {\r\n    let path = [];\r\n    for (let theta = Math.PI/6; theta < 2*Math.PI; theta += Math.PI/3) {\r\n        const x = pos.x + s*Math.cos(theta);\r\n        const y = pos.y + s*Math.sin(theta);\r\n        path.push({x:x, y:y});\r\n    }\r\n    return path;\r\n};\r\n\r\nfunction calcUnits(canvasWidth, canvasHeight, s) {\r\n    /*\r\n    const xUnits = Math.floor(canvasHeight/(1.5*s) - .5);\r\n    const yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)) - .5);\r\n    const xOffset = (canvasWidth - (yUnits + .5)*s*Math.sqrt(3))/2;\r\n    const yOffset = (canvasHeight - (xUnits*1.5 + .5)*s)/2;\r\n    */\r\n    const xUnits = Math.max(Math.floor((canvasHeight - s/2)/(1.5*s)),1);\r\n    let yUnits, xOffset, yOffset;\r\n    if (xUnits === 1) {\r\n        yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)));\r\n        xOffset = (canvasWidth - yUnits*s*Math.sqrt(3))/2;\r\n        yOffset = (canvasHeight - xUnits*2*s)/2;\r\n    } else {\r\n        yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)) - .5);\r\n        xOffset = (canvasWidth - (yUnits + .5)*s*Math.sqrt(3))/2;\r\n        yOffset = (canvasHeight - (xUnits*1.5 + .5)*s)/2;\r\n    }    \r\n    return [xUnits,yUnits,xOffset,yOffset];\r\n};\r\n\r\nfunction initializeBoard(canvasWidth, canvasHeight, s) {   \r\n    let [xUnits,yUnits] = calcUnits(canvasWidth, canvasHeight, s);\r\n    let board = {};\r\n    for (let i = 0; i < xUnits; i++) {\r\n        for (let j = 0; j < yUnits; j++) {\r\n            Object.assign(board, {[[i,j]]: {node:{i:i,j:j}, type:'empty', fill:'white', object:null}})\r\n        }\r\n    }\r\n    let startNode, targetNode, offset;\r\n    if (xUnits > yUnits) {\r\n        offset = Math.floor(xUnits*.25);\r\n        startNode = {i: xUnits-1-offset, j: Math.floor(yUnits/2)};\r\n        targetNode = {i: offset, j: Math.floor(yUnits/2)};\r\n    } else {\r\n        offset = Math.floor(yUnits*.25);\r\n        startNode = {i: Math.floor(xUnits/2), j: offset};\r\n        targetNode = {i: Math.floor(xUnits/2), j: yUnits-1-offset};\r\n    }\r\n    let angle = 0;\r\n    if (xUnits > yUnits) angle = -Math.PI/2;\r\n    Object.assign(board[[startNode.i,startNode.j]], {type: 'start', object:'start', angle:angle});\r\n    Object.assign(board[[targetNode.i,targetNode.j]], {type: 'target', object:'target'});\r\n    return [board, startNode, targetNode];\r\n};\r\n\r\nfunction initializeCanvas(canvasWidth,canvasHeight,s) {\r\n    let [xUnits,yUnits,xOffset,yOffset] = calcUnits(canvasWidth, canvasHeight, s);\r\n    let [board, startNode, targetNode] = initializeBoard(canvasWidth, canvasHeight, s);\r\n    let lineWidth = s/10;\r\n    return {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset,lineWidth};\r\n}\r\n\r\nfunction parseKey(key) {\r\n    let [i,j] = key.split(',').map((item) => parseInt(item));\r\n    return {i:i,j:j};\r\n};\r\n\r\n//=====================================================================================//\r\n// Exports //\r\n//=====================================================================================//\r\nexport {getPointerNode, onMouseDown, onTouchStart}\r\nexport {drawSearch, drawLine, moveStart, moveTarget, clearBoard, doTheJohnWall, lightWeightBaby, clearTheWay}\r\nexport {drawWeight, drawStart, drawStartPos, drawTarget, drawNode, drawHex, fillHex};\r\nexport {sleep, calcHexCenter, nodeDistance, nearestHex, calcHexPath, calcUnits, initializeBoard, initializeCanvas, parseKey};","import React from 'react';\r\nimport {initializeBoard, drawWeight, drawStart, drawStartPos, drawTarget, drawNode} from '../utils/canvas-tools';\r\n\r\n/*\r\n// To Do //\r\n//========================================================================================//\r\n-- Make new drawWeight function that takes node as imput instead of pos\r\n\r\n//========================================================================================//\r\n*/\r\n\r\n\r\nclass Canvas extends React.Component {\r\n    componentDidMount() {\r\n        let [board] = initializeBoard(this.props.width, this.props.height, this.props.s);\r\n        for (let key in board) {\r\n            let {node, fill, object, angle} = board[key];\r\n            this.updateNode(node, fill, object, angle);\r\n        }\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps) {\r\n        if (nextProps.updateID === this.props.updateID) return false;\r\n        else return true;\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (this.props.s !== prevProps.s) {\r\n            let canvas = this.props.canvasRef.current;\r\n            let cx = canvas.getContext('2d');\r\n            cx.clearRect(0,0,this.props.width,this.props.height);\r\n            this.componentDidMount();\r\n        } else {\r\n            for (let key in this.props.canvasUpdates) {\r\n                let {node, fill, object, angle} = this.props.canvasUpdates[key];\r\n                this.updateNode(node, fill, object, angle);\r\n            }\r\n            if (this.props.startPosition) {\r\n                let {pos,angle} = this.props.startPosition;\r\n                drawStartPos(pos,this.props.s,this.props.canvasRef,angle);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateNode(node,fill,object,angle) {\r\n        if (fill) {\r\n            drawNode(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, fill, this.props.canvasRef);\r\n        }\r\n        if (object) {\r\n            if (object === 'weight') {\r\n                drawWeight(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, this.props.canvasRef);\r\n            } else if (object === 'start') {\r\n                drawStart(node, this.props.s, this.props.xOffset, this.props.yOffset, this.props.canvasRef,angle);\r\n            } else if (object === 'target') {\r\n                drawTarget(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, this.props.canvasRef);\r\n            }\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <canvas\r\n                ref = {this.props.canvasRef}\r\n                width = {this.props.width}\r\n                height = {this.props.height}\r\n                onMouseDown={this.props.running ? null : (downEvent) => this.props.onMouseDown(downEvent)}\r\n                onTouchStart={this.props.running ? null : (startEvent) => this.props.onTouchStart(startEvent)}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default Canvas;","import {\r\n    isSameNode, nodeOnBoard, isValidNode, findNeighbors, manhattanDistance, minHeap, shuffleArray, getRandomNode,\r\n    getRandomWallNode, getRandomNeighbor, disjointSet\r\n} from './utils';\r\nimport { parseKey, calcHexCenter } from './canvas-tools';\r\nimport {noise} from './perlin';\r\n\r\n\r\n//=================================================================================================================================//\r\n// Path-Finding Algorithms //\r\n//=================================================================================================================================//\r\n\r\n\r\n// Unweighted Algorithms //\r\n//=======================//\r\nfunction randomWalk(startNode,targetNode,xUnits,yUnits,board,isRunning) {\r\n    // initialize path (not queue since we will only have one path) \r\n    let path = [startNode];\r\n    // initialize array for storing updates to canvas for animation\r\n    let searchUpdates = [];\r\n    // now take a random walk, checking neighboring nodes at each visited nodes until target is found\r\n    let startTime = new Date();\r\n    while (((new Date()).getTime() - startTime.getTime()) < 5000) {\r\n        let currentNode = path[path.length - 1];\r\n        let lastNode;\r\n        path.length < 2 ? lastNode = {i:-1,j:-1} : lastNode = path[path.length - 2];\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or off the board)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes and randomize their order\r\n        neighbors = shuffleArray(neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits))));\r\n        for (let node of neighbors) {\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(node,targetNode)) {\r\n                return [path.concat([node]), searchUpdates];\r\n            } else {\r\n                if (!isSameNode(node,startNode) && !isSameNode(node,lastNode)) {\r\n                    let newState = Object.assign({},board[[node.i,node.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                }\r\n            }\r\n        }\r\n        path.push(neighbors[0])\r\n    }\r\n};\r\n\r\nfunction depthFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.unshift(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction breadthFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.push(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction hillClimbing(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // sort nodes according to distance to target node (descending)\r\n        neighbors.sort((node1,node2) => manhattanDistance(node2,targetNode) - manhattanDistance(node1,targetNode));\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.unshift(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction beamSearch(startNode,targetNode,xUnits,yUnits,board, w = 2) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // sort nodes according to distance to target node (descending)\r\n        neighbors.sort((node1,node2) => manhattanDistance(node2,targetNode) - manhattanDistance(node1,targetNode));\r\n        // filter to valid nodes and keep only the first w number of them\r\n        neighbors = neighbors.filter(\r\n            (node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j))\r\n        ).slice(-w);\r\n        for (let newNode of neighbors) {\r\n            let newPath = currentPath.concat([newNode]);\r\n            // if we found target return the completed path and updates, else add path extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                return [newPath, searchUpdates];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.push(newPath);\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction bestFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.distance < path2.distance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({distance:manhattanDistance(startNode,targetNode) , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = path.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.insert({distance:manhattanDistance(newNode,targetNode) , path:newPath});\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\n\r\n// Weighted Algorithms //\r\n//=====================//\r\n// Dictionary below determines relative weight moving from one node to another.\r\n// Essentially moving through a weight is 10 times as difficult as an empty node.\r\nconst pathWeights = {'empty':1, 'weight':10, 'target':1};\r\n\r\nfunction branchNBound(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.distance < path2.distance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    let bestDistance = Infinity;\r\n    let bestPath = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            // if newDistance is not less than the bestDistance to the target so far, then drop the path from the queue\r\n            if (newDistance >= bestDistance) {\r\n                if (!isSameNode(newNode,targetNode)) {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                }\r\n                continue;\r\n            };\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                [bestPath, bestDistance] = [newPath, newDistance];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({distance:newDistance , path:newPath});\r\n            }\r\n        }\r\n    }\r\n    // Return best path (which could be empty if no path found) and searchUpdates for animation\r\n    return [bestPath, searchUpdates];\r\n};\r\n\r\nfunction aStarSearch(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.estimatedDistance < path2.estimatedDistance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({estimatedDistance:manhattanDistance(startNode,targetNode), distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                // extend other paths to be sure they aren't actually closer to the target (not sure about this part)\r\n                return [newPath, searchUpdates];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({\r\n                    estimatedDistance: newDistance + manhattanDistance(newNode,targetNode), \r\n                    distance:newDistance, \r\n                    path:newPath\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\n// Modified A* For Use In Maze Buidlers //\r\n//======================================//\r\nconst modifiedWeights = (type) => {\r\n    if (type === 0) return 1;\r\n    else return Math.random()*10000 + 1000;\r\n};\r\n\r\nfunction modifiedAStar(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.estimatedDistance < path2.estimatedDistance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({estimatedDistance:manhattanDistance(startNode,targetNode), distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + modifiedWeights(board[[newNode.i,newNode.j]]);\r\n            // if we found target then we have the shortest path, which we will then convert into canvas updates that are returned\r\n            if (isSameNode(newNode,targetNode)) {\r\n                let searchUpdates = [];\r\n                for (let node of newPath) {\r\n                    if (board[[node.i,node.j]] === 1) searchUpdates.push({node:node, type:'empty', fill:'white'});\r\n                }\r\n                return searchUpdates;\r\n            } else {\r\n                queue.insert({\r\n                    estimatedDistance: newDistance + manhattanDistance(newNode,targetNode), \r\n                    distance:newDistance, \r\n                    path:newPath\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // Return empty updates if no path to target was found\r\n    console.log('got here, but should not have')\r\n    return [];\r\n};\r\n\r\n\r\n//=================================================================================================================================//\r\n// Maze Building Algorithms //\r\n//=================================================================================================================================//\r\nfunction randomWalls(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize array to keep track of path for drawing maze and dungeon object for state of maze\r\n    let mazePath = [];\r\n    let dungeon = {};\r\n    // iterate over whole board and randomly generate walls (with P(wall) = .5)\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) {\r\n            dungeon[key] = 0;\r\n        } else if (Math.random() < .50) {\r\n            dungeon[key] = 1;\r\n            mazePath.push({node:node, type:'wall', fill:'#282c34'})\r\n        } else {\r\n            dungeon[key] = 0;\r\n        }\r\n    }\r\n    // use modified A* to ensure a path between the start and target nodes\r\n    let pathUpdates = modifiedAStar(startNode,targetNode,xUnits,yUnits,dungeon);\r\n    mazePath = mazePath.concat(pathUpdates);\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction randomWeights(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iterate over whole board and randomly generate walls (with P(wall) = .5)\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) continue;\r\n        if (Math.random() < .5) {\r\n            mazePath.push({node:node, type:'weight', fill:'white', object:'weight'})\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction depthFirstMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array\r\n    let queue = [start];\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to next node on the queue\r\n        const currentNode = queue.shift();\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // shuffle array to randomize order\r\n        neighbors = shuffleArray(neighbors);\r\n        // initialize array for adding the new nodes to queue (this lets us control the order in case the start or target node are encountered\r\n        // since we want to immediately extend these nodes to ensure a perfect path)\r\n        let nodesToAdd = [];\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) nodesToAdd.unshift(node);\r\n            else nodesToAdd.push(node);\r\n        }\r\n        queue = nodesToAdd.concat(queue);\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction breadthFirstMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array\r\n    let queue = [start];\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to next node on the queue\r\n        const currentNode = queue.shift();\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // shuffle array to randomize order\r\n        neighbors = shuffleArray(neighbors);\r\n        // add new nodes to queue, putting them at the end unless they are the start or target node (this ensures the start and target always get\r\n        // extended immediately which preserves the perfect maze condition)\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) queue.unshift(node);\r\n            else queue.push(node);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction kruskalsMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize list of unvisited nodes which we will visit in a randomized order; however, start and target nodes will be placed at the front to ensure\r\n    // a perfect maze is generated\r\n    let unVisitedNodes = [];\r\n    for (let key in board) {\r\n        if (!isSameNode(parseKey(key),startNode) && !isSameNode(parseKey(key),targetNode)) unVisitedNodes.push(key);\r\n    }\r\n    unVisitedNodes = shuffleArray(unVisitedNodes);\r\n    unVisitedNodes.unshift(startNode.i+','+startNode.j);\r\n    unVisitedNodes.unshift(targetNode.i+','+targetNode.j);\r\n    // initialize set to keep track of nodes added to the path\r\n    let pathNodes = new Set();\r\n    // initialize disjoint set to keep track of the disjoint paths\r\n    let disjointPaths = new disjointSet();\r\n    // lastly initialize array for storing mazePath updates for animation\r\n    let mazePath = [];\r\n    // iteratively look at each node in unVisited nodes, checking to see if it can be added to the path\r\n    for (let currentNode of unVisitedNodes) {\r\n        // get neighboring nodes and convert node to string\r\n        let neighbors = findNeighbors(parseKey(currentNode)).map((node) => (node.i+','+node.j));\r\n        // filter to neighbors that are on the board and are part of a path\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(parseKey(node),xUnits,yUnits) && pathNodes.has(node)));\r\n        // get the roots of each of these neighbors\r\n        let roots = neighbors.map((node) => disjointPaths.find(node));\r\n        // get the unique roots\r\n        let rootsSet = new Set(roots);\r\n        // Condition below guarantees perfect maze, but would not guarantee all paths are joined (and thus not guarantee that there is a path from start to target)\r\n        //if (roots.length !== rootsSet.size) continue;\r\n        // Condition below guarantees all paths are joined, but does not guarantee a perfect maze\r\n        if (roots.length > 1 && rootsSet.size < 2) continue;\r\n        // else we make current node part of the pathNodes and union all the roots\r\n        pathNodes.add(currentNode);\r\n        if (!isSameNode(parseKey(currentNode),startNode) && !isSameNode(parseKey(currentNode),targetNode)) {\r\n            mazePath.push({node:parseKey(currentNode), type:'empty', fill:'white'});\r\n        }\r\n        disjointPaths.makeSet(currentNode);\r\n        for (let node of roots) {\r\n            disjointPaths.union(currentNode,node);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n}\r\n\r\nfunction primsMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array and initialize values for keeping track of start and target nodes\r\n    let queue = [start];\r\n    let [ startFound , targetFound ] = [ false , false ];\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to random node on the queue, unless we have encountered the start or target node, in which case move to this node\r\n        // doing so ensures a perfect maze\r\n        let currentNode;\r\n        if (startFound) {\r\n            currentNode = queue.shift();\r\n            startFound = false;\r\n        }\r\n        else if (targetFound) {\r\n            currentNode = queue.shift();\r\n            targetFound = false;\r\n        } else {\r\n            const i = Math.floor(Math.random() * queue.length);\r\n            currentNode = queue[i];\r\n            queue = queue.slice(0,i).concat(queue.slice(i+1));\r\n        }\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // add new nodes to queue, putting them at the end unless they are the start or target node (this ensures the start and target always get\r\n        // extended immediately which preserves the perfect maze condition)\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode)) {\r\n                queue.unshift(node);\r\n                startFound = true;\r\n            } else if (isSameNode(node,targetNode)) {\r\n                queue.unshift(node);\r\n                targetFound = true;\r\n            }\r\n            else queue.push(node);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction huntAndKill(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array and initialize variable to determine when to choose new random walk point\r\n    let queue = [start];\r\n    let newRandomWalk = false;\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to next node on the queue, unless we determined current path cannot be exteneded, in which case pick random node\r\n        let currentNode;\r\n        if (newRandomWalk) {\r\n            const i = Math.floor(Math.random() * queue.length);\r\n            currentNode = queue[i];\r\n            queue = queue.slice(0,i).concat(queue.slice(i+1));\r\n            newRandomWalk = false;\r\n        } else {\r\n            currentNode = queue.shift();\r\n        }\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // shuffle array to randomize order\r\n        neighbors = shuffleArray(neighbors);\r\n        // initialize array for adding the new nodes to queue (this lets us control the order in case the start or target node are encountered\r\n        // since we want to immediately extend these nodes to ensure a perfect path)\r\n        let nodesToAdd = [];\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) nodesToAdd.unshift(node);\r\n            else nodesToAdd.push(node);\r\n        }\r\n        queue = nodesToAdd.concat(queue);\r\n        if (nodesToAdd.length === 0) newRandomWalk = true;\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction randomDLA(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize sets for keeping track of nodes in the path and neighboring nodes to the path\r\n    let [ pathNodes , pathNeighbors ] = [ new Set() , new Set() ];\r\n    // initialize array for keeping track of canvas updates\r\n    let mazePath = [];\r\n    // initialize brownianNode that randomly drifts around the board, add it to pathNeighbors to esure it is the first node added to th path\r\n    let brownianNode = getRandomNode(xUnits,yUnits,pathNodes);\r\n    pathNeighbors.add(brownianNode);\r\n    // run loop that lets the brownianNode walk randomly around the board\r\n    while (pathNodes.size < (xUnits*yUnits)/6) {\r\n        // updates for when brownianNode comes into contact with path\r\n        if (pathNeighbors.has(brownianNode)) {\r\n            // add node to pathNodes and add neighbors to pathNeighbors\r\n            pathNodes.add(brownianNode);\r\n            let neighbors = findNeighbors(parseKey(brownianNode)).filter((node) => nodeOnBoard(node,xUnits,yUnits));\r\n            for (let neighbor of neighbors) {\r\n                pathNeighbors.add(neighbor.i+','+neighbor.j);\r\n            }\r\n            // add to canvas updates if it is not the start or target node\r\n            if (!isSameNode(parseKey(brownianNode),startNode) && !isSameNode(parseKey(brownianNode),targetNode)) {\r\n                mazePath.push({node:parseKey(brownianNode), type:'empty', fill:'white', object:null});\r\n            }\r\n            // set brownianNode to new random position\r\n            brownianNode = getRandomNode(xUnits,yUnits,pathNodes);\r\n        } else {\r\n            // let brownianNode walk to new neighbor at random\r\n            brownianNode = getRandomNeighbor(brownianNode,xUnits,yUnits);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\nfunction wallDLA(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize sets for keeping track of nodes in the path and neighboring nodes to the path\r\n    let [ pathNodes , pathNeighbors ] = [ new Set() , new Set() ];\r\n    // initialize array for keeping track of canvas updates\r\n    let mazePath = [];\r\n    // initialize brownianNode that randomly drifts around the board, add it to pathNeighbors to esure it is the first node added to th path\r\n    let brownianNode = getRandomWallNode(xUnits,yUnits,pathNodes);\r\n    pathNeighbors.add(brownianNode);\r\n    // run loop that lets the brownianNode walk randomly around the board\r\n    while (pathNodes.size < (xUnits*yUnits)/6) {\r\n        // updates for when brownianNode comes into contact with path\r\n        if (pathNeighbors.has(brownianNode)) {\r\n            // add node to pathNodes and add neighbors to pathNeighbors\r\n            pathNodes.add(brownianNode);\r\n            let neighbors = findNeighbors(parseKey(brownianNode)).filter((node) => nodeOnBoard(node,xUnits,yUnits));\r\n            for (let neighbor of neighbors) {\r\n                pathNeighbors.add(neighbor.i+','+neighbor.j);\r\n            }\r\n            // add to canvas updates if it is not the start or target node\r\n            if (!isSameNode(parseKey(brownianNode),startNode) && !isSameNode(parseKey(brownianNode),targetNode)) {\r\n                mazePath.push({node:parseKey(brownianNode), type:'empty', fill:'white', object:null});\r\n            }\r\n            // set brownianNode to new random position\r\n            brownianNode = getRandomWallNode(xUnits,yUnits,pathNodes);\r\n        } else {\r\n            // let brownianNode walk to new neighbor at random\r\n            brownianNode = getRandomNeighbor(brownianNode,xUnits,yUnits);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction cellularDungeon(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // initialize dictionary for keeping track of dungeon state (0 for empty and 1 for wall)\r\n    let dungeon = {};\r\n    // begin by iterating over whole board and randomly generating walls (with P(wall) = .35)\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) {\r\n            dungeon[key] = 0;\r\n        // remove this to have walls be open\r\n        } else if (node.i === 0 || node.i === xUnits-1 || node.j === 0 || node.j === yUnits-1) {\r\n            mazePath.push({node:node, type:'wall', fill:'#282c34'})\r\n            dungeon[key] = 1;\r\n        } else if (Math.random() < .42) {\r\n            mazePath.push({node:node, type:'wall', fill:'#282c34'})\r\n            dungeon[key] = 1;\r\n        } else {\r\n            dungeon[key] = 0;\r\n        }\r\n    }\r\n    // now we let the board anneal over a set number of iterations to form the dungeons\r\n    for (let i=0; i<5; i++) {\r\n        let newDungeon = {};\r\n        // iterate over previous state and determine new state for each grid cell\r\n        for (let key in dungeon) {\r\n            const node = parseKey(key);\r\n            const neighborsStates = findNeighbors(node)\r\n                .filter((node) => nodeOnBoard(node,xUnits,yUnits))\r\n                // eslint-disable-next-line\r\n                .map((node) => dungeon[[node.i,node.j]]);\r\n            const wallCount = neighborsStates.reduce((state1,state2) => state1 + state2);\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) {\r\n                newDungeon[key] = 0;\r\n            // remove this to have walls be open\r\n            } else if (node.i === 0 || node.i === xUnits-1 || node.j === 0 || node.j === yUnits-1) {\r\n                newDungeon[key] = 1;\r\n            } else if ((dungeon[key] && wallCount >= 2) || (!dungeon[key] && wallCount >= 4)) {\r\n                newDungeon[key] = 1;\r\n            } else {\r\n                newDungeon[key] = 0;\r\n            }\r\n            if (dungeon[key] !== newDungeon[key]) {\r\n                if (newDungeon[key] === 1) {\r\n                    mazePath.push({node:node, type:'wall', fill:'#282c34'})\r\n                } else {\r\n                    mazePath.push({node:node, type:'empty', fill:'white'})\r\n                }\r\n            }\r\n        }\r\n        dungeon = newDungeon\r\n    }\r\n    // use modified A* to ensure a path between the start and target nodes\r\n    let pathUpdates = modifiedAStar(startNode,targetNode,xUnits,yUnits,dungeon);\r\n    mazePath = mazePath.concat(pathUpdates);\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction simplexCaves(startNode,targetNode,xUnits,yUnits,board,s,xOffset,yOffset) {\r\n    // initialize mazePath array for storing canvs updates and dungeon object for storing state of maze\r\n    let mazePath = [];\r\n    let dungeon = {};\r\n    // initiate perline noise\r\n    noise.seed(Math.random());\r\n    // for each node on the board grab the perlin noise value; if the value is above the cutoff, make it a wall, else empty\r\n    const defaultThreshold = .5;\r\n    // use below function to have threshold go to zero as we approach the edges (so the edges become walls)\r\n    function thresholdFunction(node) {\r\n        const offset = Math.ceil(Math.min(xUnits/10, yUnits/10));\r\n        if (node.i < offset) return defaultThreshold * (1 - (offset-node.i)/offset)**2;\r\n        if (node.j < offset) return defaultThreshold * (1 - (offset-node.j)/offset)**2;\r\n        if (node.i > xUnits-1-offset) return defaultThreshold * (1 - (offset-(xUnits-1-node.i))/offset)**2;\r\n        if (node.j > yUnits-1-offset) return defaultThreshold * (1 - (offset-(yUnits-1-node.j))/offset)**2;\r\n        else return defaultThreshold;\r\n    };\r\n    let scale = 150;\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) {\r\n            dungeon[key] = 0;\r\n        } else {\r\n            const pos = calcHexCenter(node,s,xOffset,yOffset);\r\n            const noiseValue = (noise.simplex2(pos.x / scale, pos.y / scale) + 1) / 2;\r\n            const threshold = thresholdFunction(node);\r\n            if (noiseValue > threshold) {\r\n                dungeon[key] = 1;\r\n                mazePath.push({node:node, type:'wall', fill:'#282c34'});\r\n            } else {\r\n                dungeon[key] = 0;\r\n            }\r\n        }\r\n    }\r\n    // use modified A* to ensure a path between the start and target nodes\r\n    let pathUpdates = modifiedAStar(startNode,targetNode,xUnits,yUnits,dungeon);\r\n    mazePath = mazePath.concat(pathUpdates);\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n}\r\n\r\n\r\nexport {randomWalk, depthFirst, breadthFirst, hillClimbing, beamSearch, bestFirst, branchNBound, aStarSearch};\r\nexport {randomWalls, randomWeights, depthFirstMaze, breadthFirstMaze, kruskalsMaze, primsMaze, huntAndKill, randomDLA, wallDLA, cellularDungeon, simplexCaves}","import {\r\n    randomWalk, depthFirst, breadthFirst, hillClimbing, beamSearch, bestFirst, branchNBound, aStarSearch,\r\n    randomWalls, randomWeights, depthFirstMaze, breadthFirstMaze, kruskalsMaze, primsMaze, huntAndKill, randomDLA, wallDLA, cellularDungeon, simplexCaves,\r\n} from './algorithms';\r\nimport { calcHexCenter, nodeDistance, doTheJohnWall, lightWeightBaby, clearTheWay } from './canvas-tools';\r\nimport { scalarProd, vectorSum, vectorDiff, vectorAngle, isSameNode } from './utils';\r\n\r\n\r\n\r\n//=================================================================================================================================//\r\n// Constants //\r\n//=================================================================================================================================//\r\n// mappings for speeds when animating search, drawPath, moveDownPath, victory, and drawMaze\r\nconst searchSpeed = {\r\n    0: 10,\r\n    1: 100,\r\n    2: 1000,\r\n    3: 10000,\r\n    4: Infinity\r\n};\r\nconst drawPathSpeed = {\r\n    0: 5,\r\n    1: 5**2,\r\n    2: 5**3,\r\n    3: 5**4,\r\n    4: Infinity\r\n};\r\nconst moveDownPathSpeed = {\r\n    0: 3,\r\n    1: 3**2,\r\n    2: 3**3,\r\n    3: 3**4,\r\n    4: Infinity\r\n};\r\nconst victorySpeed = {\r\n    0: 1.5*Math.PI,\r\n    1: 2*Math.PI,\r\n    2: 3*Math.PI,\r\n    3: 6*Math.PI,\r\n    4: Infinity\r\n};\r\nconst drawMazeSpeed = {\r\n    0: 6,\r\n    1: 6**2,\r\n    2: 6**3,\r\n    3: 6**4,\r\n    4: Infinity\r\n};\r\n\r\n\r\n//=================================================================================================================================//\r\n// Path-Finding Animations //\r\n//=================================================================================================================================//\r\nfunction pathFinderAnimation(state,canvasRef,setState,isRunning) {\r\n    // Set state to running so user can't interfere with pathFinder \r\n    setState((prevState) => ({\r\n        running: true, \r\n        updateID: prevState.updateID + 1\r\n    }));\r\n    let pathFinder;\r\n    switch (state.algorithm) {\r\n        case 0: pathFinder = depthFirst; break;\r\n        case 1: pathFinder = breadthFirst; break;\r\n        case 2: pathFinder = hillClimbing; break;\r\n        case 3: pathFinder = beamSearch; break;\r\n        case 4: pathFinder = bestFirst; break;\r\n        case 5: pathFinder = branchNBound; break;\r\n        case 6: pathFinder = aStarSearch; break;\r\n        case 7: pathFinder = randomWalk; break;\r\n        default: pathFinder = breadthFirst;\r\n    };\r\n    let [path, searchUpdates] = pathFinder(state.startNode,state.targetNode,state.xUnits,state.yUnits,state.board);\r\n    searchAnimation(path,searchUpdates,state.startNode,state.s,state.xOffset,state.yOffset,state.speed,state.board,setState,isRunning);\r\n};\r\n\r\nfunction searchAnimation(path,searchUpdates,startNode,s,xOffset,yOffset,speed,board,setState,isRunning) {\r\n    let hexsPerSecond = searchSpeed[speed];\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = searchUpdates.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = searchUpdates.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                if (path.length > 0) drawPathAnimation(path,startNode,s,xOffset,yOffset,speed,board,setState,isRunning);\r\n                else {\r\n                    setState((prevState) => ({\r\n                        running: false,\r\n                        updateID: prevState.updateID + 1,\r\n                        canvasUpdates: [],\r\n                        startPosition: false\r\n                    }));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction drawPathAnimation(path,startNode,s,xOffset,yOffset,speed,board,setState,isRunning) {\r\n    let hexsPerSecond = drawPathSpeed[speed];\r\n    let pathUpdates = [];\r\n    for (let node of path.slice(1,-1)) {\r\n        if (!isSameNode(node,startNode)) pathUpdates.push(Object.assign({},board[[node.i,node.j]],{fill:'#b1fc40'}));\r\n    }\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = pathUpdates.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = pathUpdates.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                moveDownPathAnimation(path,s,xOffset,yOffset,speed,setState,isRunning);\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction moveDownPathAnimation(path,s,xOffset,yOffset,speed,setState,isRunning) {\r\n    let hexsPerSecond = moveDownPathSpeed[speed];\r\n    const totalSteps = path.length - 1;\r\n    const totalTime = totalSteps / hexsPerSecond * 1000;\r\n    let startTime = null;\r\n    let i = 0;\r\n    function updateAnimation(time) {\r\n        let [ prevStartNode , prevEndNode ] = [ path[i] , path[i+1] ];\r\n        i = Math.floor((time - startTime) / totalTime * totalSteps);\r\n        let pos, angle;\r\n        if (i < totalSteps) {\r\n            let [ startNode , endNode ] = [ path[i] , path[i+1] ];\r\n            let [ startPos , endPos ] = [ calcHexCenter(startNode,s,xOffset,yOffset) , calcHexCenter(endNode,s,xOffset,yOffset) ]\r\n            let V = vectorDiff(endPos,startPos);\r\n            let v = scalarProd((time - startTime) / totalTime * totalSteps - i, V);\r\n            pos = vectorSum(startPos, v);\r\n            angle = vectorAngle(V);\r\n        } else {\r\n            let [ startNode , endNode ] = [ path[path.length-2] , path[path.length-1] ];\r\n            let [ startPos , endPos ] = [ calcHexCenter(startNode,s,xOffset,yOffset) , calcHexCenter(endNode,s,xOffset,yOffset) ]\r\n            let V = vectorDiff(endPos,startPos);\r\n            pos = calcHexCenter(endPos);\r\n            angle = vectorAngle(V);\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        canvasUpdates: [\r\n                            Object.assign({}, prevState.board[[prevStartNode.i,prevStartNode.j]]),\r\n                            Object.assign({},  prevState.board[[prevEndNode.i,prevEndNode.j]])\r\n                        ],\r\n                        startPosition: Object.assign({},{pos:pos,angle:angle}),\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (startTime != null) {\r\n                updateAnimation(time);\r\n            } else {\r\n                startTime = time;\r\n            }\r\n            if ((time - startTime) < totalTime) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                victoryAnimation(path[path.length-1],path[path.length-2],speed,s,xOffset,yOffset,setState,isRunning);\r\n            }\r\n        } else {\r\n            let [ prevStartNode , prevEndNode ] = [ path[i] , path[i+1] ];\r\n            setState((prevState) => {\r\n                return {\r\n                            canvasUpdates: [\r\n                                Object.assign({}, prevState.board[[prevStartNode.i,prevStartNode.j]]),\r\n                                Object.assign({},  prevState.board[[prevEndNode.i,prevEndNode.j]])\r\n                            ],\r\n                            startPosition: false,\r\n                            updateID: prevState.updateID +1\r\n                };\r\n            });\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction victoryAnimation(targetNode,prevNode,speed,s,xOffset,yOffset,setState,isRunning) {\r\n    const radiansPerSecond = victorySpeed[speed];\r\n    const targetPos = calcHexCenter(targetNode,s,xOffset,yOffset);\r\n    const startAngle = vectorAngle(nodeDistance(targetNode,prevNode,s,xOffset,yOffset));\r\n    const totalTime = 6*Math.PI / radiansPerSecond * 1000;\r\n    let startTime = null;\r\n    function updateAnimation(time) {\r\n        let angle;\r\n        if ((time - startTime) < totalTime) {\r\n            angle = startAngle + (time - startTime)/totalTime*6*Math.PI;\r\n        } else {\r\n            angle = startAngle + 6*Math.PI;\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        canvasUpdates: [ Object.assign({}, prevState.board[[targetNode.i,targetNode.j]]) ],\r\n                        startPosition: Object.assign({},{pos:targetPos,angle:angle}),\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (startTime != null) {\r\n                updateAnimation(time);\r\n            } else {\r\n                startTime = time;\r\n            }\r\n            if ((time - startTime) < totalTime) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                setState((prevState) => ({\r\n                    running: false,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: [],\r\n                    startPosition: false\r\n                }));\r\n            }\r\n        } else {\r\n            setState((prevState) => {\r\n                return {\r\n                            canvasUpdates: [ Object.assign({}, prevState.board[[targetNode.i,targetNode.j]]) ],\r\n                            startPosition: false,\r\n                            updateID: prevState.updateID +1\r\n                };\r\n            });\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\n\r\n//=================================================================================================================================//\r\n// Maze-Drawing Animations //\r\n//=================================================================================================================================//\r\nfunction mazeAnimation(mazeID,state,setState,isRunning) {\r\n    // clear board or fill it with required fill for maze\r\n    if (mazeID === 0 || mazeID === 1 || mazeID === 9 || mazeID === 10) clearTheWay(state,setState);\r\n    else if (mazeID === 7 || mazeID === 8) lightWeightBaby(state,setState);\r\n    else doTheJohnWall(state,setState);\r\n    // Set state to running so user can't interfere with pathFinder \r\n    setState((prevState) => ({\r\n        running: true, \r\n        updateID: prevState.updateID + 1\r\n    }));\r\n    // Get path array of nodes to fill in for maze\r\n    let mazeBuilder;\r\n    switch (mazeID) {\r\n        case 0: mazeBuilder = randomWalls; break;\r\n        case 1: mazeBuilder = randomWeights; break;\r\n        case 2: mazeBuilder = depthFirstMaze; break;\r\n        case 3: mazeBuilder = breadthFirstMaze; break;\r\n        case 4: mazeBuilder = huntAndKill; break;\r\n        case 5: mazeBuilder = primsMaze; break;\r\n        case 6: mazeBuilder = kruskalsMaze; break;\r\n        case 7: mazeBuilder = randomDLA; break;\r\n        case 8: mazeBuilder = wallDLA; break;\r\n        case 9: mazeBuilder = cellularDungeon; break;\r\n        case 10: mazeBuilder = simplexCaves; break;\r\n        default: mazeBuilder = depthFirstMaze;\r\n    };\r\n    let mazePath = mazeBuilder(state.startNode,state.targetNode,state.xUnits,state.yUnits,state.board,state.s,state.xOffset,state.yOffset);\r\n    // Set up parameters for animation\r\n    let hexsPerSecond = drawMazeSpeed[state.speed];\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = mazePath.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = mazePath.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                setState((prevState) => ({\r\n                    running: false,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: [],\r\n                    startPosition: false\r\n                }));\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nexport {pathFinderAnimation, mazeAnimation};","import React from 'react';\r\nimport ControlPanel from './ControlPanel';\r\nimport Canvas from './Canvas';\r\nimport {onMouseDown, onTouchStart, clearBoard, initializeCanvas} from '../utils/canvas-tools';\r\nimport {pathFinderAnimation, mazeAnimation} from '../utils/animations';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faBars} from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass PathFinder extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        let { innerWidth: width, innerHeight: height } = window\r\n        // Set Up Control Panel\r\n        let windowState = this.getWindowState();\r\n        let showControls = {1:false,2:false,3:true}[windowState]\r\n        // Setting Up Canvas\r\n        let canvasHeight;\r\n        if (windowState === 1) canvasHeight = height*.8;\r\n        else if (windowState === 2) canvasHeight = height*.85;\r\n        else canvasHeight = height*.9-4;\r\n        let canvasWidth = width;\r\n        this.canvasRef = React.createRef();\r\n        let s = 15;\r\n        let {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset,lineWidth} = initializeCanvas(canvasWidth,canvasHeight,s);\r\n        // Setting Initial State\r\n        this.state = {\r\n            windowState: this.getWindowState(),\r\n            showControls: showControls,\r\n            algorithm: 5,\r\n            speed: 2,\r\n            tool: 0,\r\n            canvasWidth: canvasWidth,\r\n            canvasHeight: canvasHeight,\r\n            s: s,\r\n            lineWidth: lineWidth,\r\n            board: board,\r\n            startNode: startNode,\r\n            targetNode: targetNode,\r\n            xUnits: xUnits,\r\n            yUnits: yUnits,\r\n            xOffset: xOffset,\r\n            yOffset: yOffset,\r\n            running: false,\r\n            canvasUpdates: [],\r\n            startPosition: false,\r\n            updateID: 0\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('resize', (event) => this.handleResize());\r\n    }\r\n\r\n    handleResize() {\r\n        let windowState = this.getWindowState();\r\n        if (windowState !== this.state.windowState) {\r\n            if ((windowState === 1 || windowState === 2) && (this.state.windowState === 3)) {\r\n                this.setState({windowState:windowState, showControls:false});\r\n            } else if ((windowState === 3) && (this.state.windowState === 1 || this.state.windowState === 2)) {\r\n                this.setState({windowState:windowState, showControls:true});\r\n            } else this.setState({windowState:windowState});\r\n        }\r\n    }\r\n\r\n    getWindowState() {\r\n        let { innerWidth: width, innerHeight: height } = window;\r\n        if (width < 481 || height < 481)  {\r\n            if ( width > height) return 2;\r\n            else return 1;\r\n        } else return 3;\r\n    }\r\n\r\n    toggleSelected(key,id) {\r\n        if (key !== 'clear') {\r\n            this.setState({\r\n                [key]:id\r\n            })\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    toggleControls() {\r\n        this.setState((prevState) => ({showControls: !prevState.showControls}));\r\n    }\r\n\r\n    startPathFinder() {\r\n        // Check to make sure not already running\r\n        if (this.state.running) return;\r\n        const setState = (stateUpdate) => this.setState(stateUpdate);\r\n        const isRunning = () => {return this.state.running;};\r\n        this.clearBoard(1);\r\n        pathFinderAnimation(this.state,this.canvasRef,setState,isRunning);\r\n    }\r\n\r\n    stopPathFinder() {\r\n        this.setState((prevState) => ({running:false, updateID:prevState.updateID+1}));\r\n    }\r\n\r\n    onMouseDown(downEvent) {\r\n        onMouseDown(downEvent,this.state,this.canvasRef,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    onTouchStart(startEvent) {\r\n        // This isn't working in Chrome. Chrome automatically sets scroll event to passive which dissallows preventDefault\r\n        // I could find a way to set event to active, so instead just disabling scroll for canvas in CSS.\r\n        // This however is leading to a bug where scroll gets re-enabled after user uses pinch zoom. No soultion found yet. \r\n        startEvent.preventDefault();\r\n        onTouchStart(startEvent,this.state,this.canvasRef,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    clearBoard(id) {\r\n        if (this.state.running) return;\r\n        clearBoard(id,this.canvasRef,this.state,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    changeHexSize(s) {\r\n        if (this.state.running || s === this.state.s) return;\r\n        this.setState((prevState) => {\r\n            // check that s is not too large\r\n            let hexSize;\r\n            if (prevState.canvasWidth < prevState.canvasHeight) {\r\n                if (prevState.canvasWidth > 1.5*Math.sqrt(3)*s && prevState.canvasHeight > 3.5*s) hexSize = s;\r\n                else hexSize = Math.min(prevState.canvasWidth/(1.5*Math.sqrt(3)),prevState.canvasHeight/(3.5));\r\n            } else {\r\n                if (prevState.canvasWidth > 2*Math.sqrt(3)*s && prevState.canvasHeight > 2*s) hexSize = s;\r\n                else hexSize = Math.min(prevState.canvasWidth/(2*Math.sqrt(3)),prevState.canvasHeight/(2));\r\n            }\r\n            return Object.assign(\r\n                {}, \r\n                initializeCanvas(prevState.canvasWidth,prevState.canvasHeight,hexSize),\r\n                {updateID: prevState.updateID + 1, canvasUpdates: [], s:hexSize}\r\n            );\r\n        });\r\n    }\r\n\r\n    drawMaze(id) {\r\n        if (this.state.running) return;\r\n        const setState = (stateUpdate) => this.setState(stateUpdate);\r\n        const isRunning = () => {return this.state.running;};\r\n        mazeAnimation(id,this.state,setState,isRunning);\r\n    }\r\n\r\n    render() {\r\n        const algorithmMap = {\r\n            0: \"Depth-First Search\",\r\n            1: \"Breadth-First Search\",\r\n            2: \"Hill Climbing\",\r\n            3: \"Beam Search (\\u03C9=2)\",\r\n            4: \"Best-First Search\",\r\n            5: \"Branch & Bound\",\r\n            6: \"A* Search\"\r\n        };\r\n        return (\r\n            <div className=\"PathFinder\">\r\n                <div className=\"Bars-Wrapper\">\r\n                    <FontAwesomeIcon className=\"bars\" icon={faBars} onClick={(event) => this.toggleControls()}/>\r\n                    <div className=\"Algorithm-Text\">{algorithmMap[this.state.algorithm]}</div>\r\n                </div>\r\n                <ControlPanel\r\n                    windowState={this.state.windowState}\r\n                    showControls={this.state.showControls}\r\n                    running={this.state.running}\r\n                    hexSize={this.state.s}\r\n                    toggleSelected={(key,id) => this.toggleSelected(key,id)}\r\n                    clearBoard={(id) => this.clearBoard(id)}\r\n                    changeHexSize={(s) => this.changeHexSize(s)}\r\n                    drawMaze={(id) => this.drawMaze(id)}\r\n                    startSearch={() => this.startPathFinder()}\r\n                    stopSearch={() => this.stopPathFinder()}\r\n                />\r\n                <Canvas\r\n                    className=\"canvas\"\r\n                    canvasRef={this.canvasRef}\r\n                    width={this.state.canvasWidth}\r\n                    height={this.state.canvasHeight}\r\n                    s={this.state.s}\r\n                    lineWidth={this.state.lineWidth}\r\n                    xOffset={this.state.xOffset}\r\n                    yOffset={this.state.yOffset}\r\n                    canvasUpdates={this.state.canvasUpdates}\r\n                    startPosition={this.state.startPosition}\r\n                    updateID={this.state.updateID}\r\n                    running={this.state.running}\r\n                    onMouseDown={(downEvent) => this.onMouseDown(downEvent)}\r\n                    onTouchStart={(startEvent) => this.onTouchStart(startEvent)}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathFinder;","import React from 'react';\nimport PathFinder from './components/PathFinder';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFinder />\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}