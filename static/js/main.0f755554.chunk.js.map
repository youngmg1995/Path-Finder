{"version":3,"sources":["components/Dropdown.js","components/SliderDropdown.js","components/ControlPanel.js","utils/utils.js","utils/canvas-tools.js","components/Canvas.js","utils/algorithms.js","utils/animations.js","components/PathFinder.js","App.js","serviceWorker.js","index.js"],"names":["Dropdown","props","state","listOpen","headerTitle","title","options","this","setState","prevState","event","key","toggleList","document","addEventListener","escapeList","className","onClick","icon","faAngleUp","size","transform","faAngleDown","map","item","id","callBack","selected","faCheck","React","Component","onClickOutside","SliderDropdown","value","target","type","orient","min","max","onInput","changeValue","onMouseUp","submitValue","onKeyDown","onTouchEnd","ControlPanel","algorithm","speed","tool","clear","temp","slice","i","length","toggleSelected","s","changeHexSize","clearBoard","running","clickEvent","stopSearch","startSearch","faPause","faPlay","DIRECTIONS","j","isSameNode","node1","node2","nodeOnBoard","node","xUnits","yUnits","isValidNode","board","findNeighbors","directions","neighbors","change","neighbor","push","manhattanDistance","hexCoord1","hexCoordinates","hexCoord2","dx","x","dy","y","Math","sign","abs","ceil2","dotProduct","v1","v2","vectorMag","v","sqrt","vectorOrthoMag","V","b","a","scalarProd","minHeap","lessThan","heap","floor","minValue","shift","unshift","pop","drawLine","startNode","endNode","lineWidth","xOffset","yOffset","canvasRef","currentNode","nodeDistance","canvasUpdates","targetNode","Object","assign","fill","object","minDis","Infinity","tempNode","currentDis","updateID","moveStart","oldNode","newNode","angle","PI","oldState","moveTarget","drawWeight","pos","calcHexCenter","sideLength","h","w1","w2","rw","r1","cx","current","getContext","path","beginPath","fillStyle","moveTo","lineTo","closePath","ringCenter","arc","stroke","drawHex","calcHexPath","fillHex","color","getPointerNode","domNode","rect","getBoundingClientRect","J","I","u","nearestHex","clientX","left","clientY","top","pos1","pos2","theta","cos","sin","calcUnits","canvasWidth","canvasHeight","initializeBoard","offset","initializeCanvas","parseKey","split","parseInt","Canvas","width","height","updateNode","nextProps","prevProps","clearRect","componentDidMount","drawNode","c","oldPos","newPos","drawStart","drawTarget","ref","onMouseDown","downEvent","onTouchStart","startEvent","depthFirst","queue","visitedNodes","Set","searchUpdates","currentPath","has","add","newState","newPath","concat","breadthFirst","hillClimbing","sort","beamSearch","w","filter","bestFirst","path1","path2","distance","insert","pathWeights","branchNBound","bestDistance","bestPath","newDistance","aStarSearch","estimatedDistance","pathFinderAnimation","isRunning","pathFinder","hexsPerSecond","lastTime","currentStart","steps","totalHexs","requestAnimationFrame","frame","time","start","boardUpdates","update","updateAnimation","pathUpdates","pathAnimation","ceil","searchAnimation","PathFinder","window","innerWidth","innerHeight","createRef","stateUpdate","button","onMove","onMoveType","canvas","origNode","move","moveEvent","buttons","removeEventListener","oldStart","newStart","oldTarget","newTarget","touches","end","endEvent","currentState","includes","faBars","startPathFinder","stopPathFinder","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0f755554.chunk.js","sourcesContent":["import React from 'react';\r\nimport onClickOutside from 'react-onclickoutside';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleUp , faAngleDown, faCheck } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass Dropdown extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            listOpen: false,\r\n            headerTitle: this.props.title,\r\n            options: this.props.options\r\n        }\r\n    }\r\n\r\n    handleClickOutside() {\r\n        this.setState({listOpen: false});\r\n    }\r\n\r\n    toggleList() {\r\n        this.setState(prevState => ({\r\n            listOpen: !prevState.listOpen\r\n        }));\r\n    }\r\n\r\n    escapeList(event) {\r\n        if (this.state.listOpen && event.key === 'Escape') this.toggleList();\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('keydown',(event) => this.escapeList(event));\r\n    }\r\n\r\n    render() {\r\n        const {listOpen, headerTitle, options} = this.state;\r\n        return (\r\n            <div className=\"Dropdown\">\r\n                <div className=\"Dropdown-header\" onClick={() => this.toggleList()}>\r\n                    <div className=\"Dropdown-header-title\">{headerTitle}</div>\r\n                    {listOpen\r\n                        ? <FontAwesomeIcon className=\"angle-up\" icon={faAngleUp} size=\"lg\" transform=\"right-8 down-1\"/>\r\n                        : <FontAwesomeIcon className=\"angle-down\" icon={faAngleDown} size=\"lg\" transform=\"right-8 down-1\"/>\r\n                    }\r\n                </div>\r\n                {listOpen && <ul className={headerTitle+\"-Dropdown-list\"}>\r\n                    {options.map((item) => (\r\n                        <li key={item.id} className=\"Dropdown-list-item\" onClick={() => this.props.callBack(item.id,item.key,item.title)}>\r\n                            {item.title}\r\n                            {item.selected && <FontAwesomeIcon className=\"check\" icon={faCheck} size=\"1x\"/>}\r\n                        </li>\r\n                    ))}\r\n                </ul>}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default onClickOutside(Dropdown);","import React from 'react';\r\nimport onClickOutside from 'react-onclickoutside';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleUp , faAngleDown} from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass SliderDropdown extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            listOpen: false,\r\n            headerTitle: this.props.title,\r\n            value: 15\r\n        }\r\n    }\r\n\r\n    handleClickOutside() {\r\n        this.setState({\r\n            listOpen: false\r\n        });\r\n    }\r\n\r\n    toggleList() {\r\n        this.setState(prevState => ({\r\n            listOpen: !prevState.listOpen\r\n        }));\r\n    }\r\n\r\n    changeValue(event) {\r\n        this.setState({value:event.target.value});\r\n    }\r\n\r\n    submitValue(event) {\r\n        this.props.callBack(event.target.value);\r\n    }\r\n\r\n    escapeList(event) {\r\n        if (this.state.listOpen && event.key === 'Escape') this.toggleList();\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('keydown',(event) => this.escapeList(event));\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"Dropdown\">\r\n                <div className=\"Dropdown-header\" onClick={() => this.toggleList()}>\r\n                    <div className=\"Dropdown-header-title\">{this.state.headerTitle}</div>\r\n                    {this.state.listOpen\r\n                        ? <FontAwesomeIcon className=\"angle-up\" icon={faAngleUp} size=\"lg\" transform=\"right-8 down-1\"/>\r\n                        : <FontAwesomeIcon className=\"angle-down\" icon={faAngleDown} size=\"lg\" transform=\"right-8 down-1\"/>\r\n                    }\r\n                </div>\r\n                {this.state.listOpen && <div className={\"SliderDropdown-list\"}>\r\n                    <div className=\"slider-text\">{this.state.value}</div>\r\n                    <input className=\"slider\" type=\"range\" orient=\"vertical\" min=\"5\" max=\"100\"\r\n                        value={this.state.value}\r\n                        onInput={(event) => this.changeValue(event)}\r\n                        onMouseUp={(event) => this.submitValue(event)}\r\n                        onKeyDown={(event) => {if (event.key === \"Enter\") this.submitValue(event);}}\r\n                        onTouchEnd={(event) => this.submitValue(event)}\r\n                    />\r\n                </div>}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default onClickOutside(SliderDropdown);","import React from 'react';\r\nimport Dropdown from './Dropdown';\r\nimport SliderDropdown from './SliderDropdown';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faPlay , faPause } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass ControlPanel extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            algorithm: [\r\n                        {id:0, title:'Depth-First Search', selected:false, key:'algorithm'},\r\n                        {id:1, title:'Breadth-First Search', selected:false, key:'algorithm'},\r\n                        {id:2, title:'Hill Climbing', selected:false, key:'algorithm'},\r\n                        {id:3, title:'Beam Search (\\u03C9=2)', selected:false, key:'algorithm'},\r\n                        {id:4, title:'Best-First Search', selected:false, key:'algorithm'},\r\n                        {id:5, title:'Branch & Bound', selected:true, key:'algorithm'},\r\n                        {id:6, title:'A* Search', selected:false, key:'algorithm'}\r\n            ],\r\n            speed: [\r\n                        {id:0, title:'Slow', selected:false, key:'speed'},\r\n                        {id:1, title:'Medium', selected:false, key:'speed'},\r\n                        {id:2, title:'Fast', selected:true, key:'speed'},\r\n                        {id:3, title:'Ludicrous', selected:false, key:'speed'},\r\n                        {id:4, title:'Instant', selected:false, key:'speed'}\r\n            ],\r\n            tool: [\r\n                        {id:0, title:'Walls', selected:true, key:'tool'},\r\n                        {id:1, title:'Weights', selected:false, key:'tool'},\r\n                        {id:2, title:'Eraser', selected:false, key:'tool'}\r\n            ],\r\n            clear: [\r\n                        {id:1, title:'Path', selected:false, key:'clear'},\r\n                        {id:2, title:'Walls', selected:false, key:'clear'},\r\n                        {id:3, title:'Weights', selected:false, key:'clear'},\r\n                        {id:0, title:'Board', selected:false, key:'clear'},\r\n                        {id:4, title:'Canvas', selected:false, key:'clear'}\r\n            ]\r\n        }\r\n    }\r\n\r\n    toggleSelected(id,key,title) {\r\n        if (key !== 'clear') {\r\n            let temp = this.state[key].slice();\r\n            for (let i = 0; i < temp.length; i++) {\r\n                temp[i].selected = (id === temp[i].id);\r\n            }\r\n            this.setState({\r\n                [key]:temp\r\n            });\r\n        }\r\n        this.props.toggleSelected(key,id);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"ControlPanel\">\r\n                <div className=\"ControlPanel-column\">\r\n                    <Dropdown className=\"Algorithm-Dropdown\"\r\n                        title={'Algorithm'} \r\n                        options={this.state.algorithm}\r\n                        callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                    />\r\n                </div>\r\n                <div className=\"ControlPanel-column\"> \r\n                    <Dropdown className=\"Speed-Dropdown\"\r\n                        title={'Speed'} \r\n                        options={this.state.speed}\r\n                        callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                    />\r\n                </div>\r\n                <div className=\"ControlPanel-column\">\r\n                    <Dropdown className=\"Tool-Dropdown\"\r\n                        title={'Tool'} \r\n                        options={this.state.tool}\r\n                        callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                    />\r\n                </div>\r\n                <div className=\"ControlPanel-column\">\r\n                    <SliderDropdown className=\"Hex-Size-Dropdown\"\r\n                        title={'Hex Size'} \r\n                        callBack = {(s) => this.props.changeHexSize(s)}\r\n                    />\r\n                </div>\r\n                <div className=\"ControlPanel-column\">\r\n                    <Dropdown className=\"Clear-Dropdown\"\r\n                        title={'Clear'} \r\n                        options={this.state.clear}\r\n                        callBack = {(id,key,title) => this.props.clearBoard(id)}\r\n                    />\r\n                </div>\r\n                <div className=\"Play-Button-Wrapper\">\r\n                    <div className=\"Play-Button\" onClick={this.props.running\r\n                        ? (clickEvent) => this.props.stopSearch()\r\n                        : (clickEvent) => this.props.startSearch()\r\n                    }>\r\n                        {this.props.running\r\n                            ? <FontAwesomeIcon className=\"pause\" icon={faPause}/>\r\n                            : <FontAwesomeIcon className=\"play\" icon={faPlay}/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ControlPanel;","//=====================================================================================//\r\n// Constants //\r\n//=====================================================================================//\r\nconst DIRECTIONS = {\r\n    even: [\r\n            { i:0  , j:1 },\r\n            { i:-1 , j:0 },\r\n            { i:-1 , j:-1 },\r\n            { i:0  , j:-1 },\r\n            { i:1  , j:-1 },\r\n            { i:1  , j:0 }\r\n    ],\r\n    odd: [\r\n            { i:0  , j:1 },\r\n            { i:-1 , j:1 },\r\n            { i:-1 , j:0 },\r\n            { i:0  , j:-1 },\r\n            { i:1  , j:0 },\r\n            { i:1  , j:1 }\r\n    ]\r\n};\r\n\r\n//=====================================================================================//\r\n// Helper Functions //\r\n//=====================================================================================//\r\n\r\n// Node Functions: node = {i:i,j:j}//\r\n//=================================//\r\nfunction isSameNode(node1,node2) {\r\n    return (node1.i === node2.i && node1.j === node2.j);\r\n};\r\n\r\nfunction nodeInPath(node,path) {\r\n    for (let pathNode of path) {\r\n        if (isSameNode(node,pathNode)) return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nfunction addNodes(node1,node2) {\r\n    return { i:(node1.i + node2.i) , j:(node1.j + node2.j) };\r\n};\r\n\r\nfunction nodeOnBoard(node,xUnits,yUnits) {\r\n    return (node.i>=0 && node.j>=0 && node.i<xUnits && node.j<yUnits);\r\n};\r\n\r\nfunction isValidNode(node,board,xUnits,yUnits) {\r\n    let state = board[[node.i,node.j]];\r\n    let onBoard = nodeOnBoard(node,xUnits,yUnits);\r\n    return (onBoard && state.type !== 'wall');\r\n};\r\n\r\nfunction findNeighbors(node) {\r\n    let neighbors = [];\r\n    let directions;\r\n    if (node.i%2 === 0) directions = DIRECTIONS.even;\r\n    else directions = DIRECTIONS.odd;\r\n    for (let change of directions) {\r\n        let neighbor = addNodes(node,change);\r\n        neighbors.push(neighbor);\r\n    }\r\n    return neighbors;\r\n};\r\n\r\nfunction manhattanDistance(node1,node2) {\r\n    const hexCoord1 = hexCoordinates(node1);\r\n    const hexCoord2 = hexCoordinates(node2);\r\n    const dx = hexCoord2.x - hexCoord1.x;\r\n    const dy = hexCoord2.y - hexCoord1.y;\r\n    if (Math.sign(dx) === Math.sign(dy)) {\r\n        return Math.max(Math.abs(dx), Math.abs(dy));\r\n    }\r\n    return Math.abs(dx) + Math.abs(dy);\r\n};\r\n\r\nfunction hexCoordinates(node) {\r\n    return { x: node.j - floor2(node.i) , y: node.j + ceil2(node.i) };\r\n};\r\n\r\nfunction floor2(x) {\r\n    return ((x >= 0) ? (x >> 1) : (x - 1) / 2);\r\n};\r\n\r\nfunction ceil2(x) {\r\n    return ((x >= 0) ? ((x + 1) >> 1) : x / 2);\r\n}\r\n\r\n// Vectors Functions: v = {x:x,y:y} //\r\n//==================================//\r\nfunction dotProduct(v1,v2) {\r\n    return v1.x*v2.x + v1.y*v2.y;\r\n};\r\n\r\nfunction scalarProd(a,v) {\r\n    return {x:a*v.x , y:a*v.y};\r\n};\r\n\r\nfunction vectorDiff(v1,v2) {\r\n    return {x: v1.x - v2.x, y: v1.y - v2.y};\r\n};\r\n\r\nfunction vectorSum(v1,v2) {\r\n    return {x: v1.x + v2.x, y: v1.y + v2.y};\r\n};\r\n\r\nfunction vectorMag(v) {\r\n    return Math.sqrt((v.x)**2 + (v.y)**2);\r\n};\r\n\r\nfunction vectorOrthoMag(v,V) {\r\n    let b = scalarProd(dotProduct(v,V)/(vectorMag(V))**2, V);\r\n    let d =  vectorDiff(v, b);\r\n    return vectorMag(d);\r\n};\r\n\r\n\r\n// Data Structures for Algorithms //\r\n//==================================//\r\nclass minHeap {\r\n    constructor(lessThan) {\r\n        this.heap = [];\r\n        this.lessThan = lessThan\r\n    }\r\n\r\n    length() {\r\n        return this.heap.length;\r\n    }\r\n\r\n    getMin() {\r\n        return this.heap[0];\r\n    }\r\n\r\n    insert(value) {\r\n        this.heap.push(value);\r\n        let i = this.heap.length-1;\r\n        while (i > 0) {\r\n            if (this.lessThan(this.heap[i] , this.heap[Math.floor((i-1)/2)])) {\r\n                [ this.heap[Math.floor((i-1)/2)] , this.heap[i] ] = [ this.heap[i] , this.heap[Math.floor((i-1)/2)] ];\r\n                i = Math.floor((i-1)/2);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    shift() {\r\n        const minValue = this.heap.shift();\r\n        if (this.heap.length === 0) return minValue;\r\n        this.heap.unshift(this.heap.pop());\r\n        let i = 0;\r\n        while (2*i+2 < this.heap.length) {\r\n            if (this.lessThan(this.heap[2*i+1], this.heap[i]) || this.lessThan(this.heap[2*i+2], this.heap[i])) {\r\n                if (this.lessThan(this.heap[2*i+1], this.heap[2*i+2])) {\r\n                    [ this.heap[2*i+1], this.heap[i] ] = [ this.heap[i] , this.heap[2*i+1] ];\r\n                    i = 2*i + 1;\r\n                } else {\r\n                    [ this.heap[2*i+2], this.heap[i] ] = [ this.heap[i] , this.heap[2*i+2] ];\r\n                    i = 2*i + 2;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return minValue;\r\n    }\r\n};\r\n\r\n\r\n//=====================================================================================//\r\n// Exports //\r\n//=====================================================================================//\r\nexport {isSameNode, nodeInPath, addNodes, nodeOnBoard, isValidNode, findNeighbors, manhattanDistance};      // node functions\r\nexport {dotProduct, scalarProd, vectorDiff, vectorSum, vectorMag, vectorOrthoMag};                          // vector functions\r\nexport {minHeap};                                                                                           // algorithm data structures\r\n","import {isSameNode, nodeOnBoard, findNeighbors, dotProduct, vectorOrthoMag} from './utils';\r\n\r\n//=====================================================================================//\r\n// Canvas Mouse and Touch Trackers for Drawing and Manipulating Board //\r\n//=====================================================================================//\r\nfunction onMouseDown(downEvent,state,canvasRef,setState) {\r\n    if (downEvent.button !== 0) return;\r\n    let canvas = canvasRef.current;\r\n    let node = getPointerNode(downEvent,canvas,state.s,state.xOffset,state.yOffset);\r\n    let origNode = node;\r\n    let onMove, onMoveType;\r\n    if (isSameNode(node,state.startNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) =>\r\n        moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 1;\r\n    } else if (isSameNode(node,state.targetNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) => \r\n        moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 2;\r\n    } else {\r\n        drawLine(node,node,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        onMove = (startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) => \r\n        drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits);\r\n        onMoveType = 0;\r\n    }\r\n    let move = (moveEvent) => {\r\n        if (moveEvent.buttons === 0) {\r\n            canvas.removeEventListener(\"mousemove\", move);\r\n            let board = {};\r\n            if (onMoveType === 1) {\r\n                let oldStart = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n                let newStart = {[[node.i,node.j]]: {node:node,type:'start',fill:'white',object:'start'}};\r\n                Object.assign(board, state.board, oldStart, newStart);\r\n                setState({board:board});\r\n            } else if (onMoveType === 2) {\r\n                let oldTarget = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n                let newTarget = {[[node.i,node.j]]: {node:node,type:'target',fill:'white',object:'target'}};\r\n                Object.assign(board, state.board, oldTarget, newTarget);\r\n                setState({board:board});\r\n            }\r\n        } else {\r\n            let newNode = getPointerNode(moveEvent,canvas,state.s,state.xOffset,state.yOffset);\r\n            if (isSameNode(newNode,node)) return;\r\n            if ( \r\n                    (onMoveType !== 0 && !nodeOnBoard(newNode,state.xUnits,state.yUnits))\r\n                ||  (onMoveType === 1 && isSameNode(newNode,state.targetNode))\r\n                ||  (onMoveType === 2 && isSameNode(newNode,state.startNode))\r\n            ) return;\r\n            onMove(node,newNode,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n                (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n            node = newNode;\r\n        }\r\n    };\r\n    canvas.addEventListener(\"mousemove\", move);\r\n};\r\n\r\n\r\nfunction onTouchStart(startEvent,state,canvasRef,setState) {\r\n    // scrolling prevented using CSS instead because I could not find a way to make event listener active\r\n    // startEvent.preventDefault();\r\n    let canvas = canvasRef.current;\r\n    let node = getPointerNode(startEvent.touches[0],canvas,state.s,state.xOffset,state.yOffset);\r\n    let origNode = node;\r\n    let onMove, onMoveType;\r\n    if (isSameNode(node,state.startNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) =>\r\n        moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 1;\r\n    } else if (isSameNode(node,state.targetNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) => \r\n        moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 2;\r\n    } else {\r\n        drawLine(node,node,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        onMove = (startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) => \r\n        drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits);\r\n        onMoveType = 0;\r\n    }\r\n    let move = (moveEvent) => {\r\n        let newNode = getPointerNode(moveEvent.touches[0],canvas,state.s,state.xOffset,state.yOffset);\r\n        if (isSameNode(newNode,node)) return;\r\n        if ( \r\n                (onMoveType !== 0 && !nodeOnBoard(newNode,state.xUnits,state.yUnits))\r\n            ||  (onMoveType === 1 && isSameNode(newNode,state.targetNode))\r\n            ||  (onMoveType === 2 && isSameNode(newNode,state.startNode))\r\n        ) return;\r\n        onMove(node,newNode,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        node = newNode;\r\n    };\r\n    let end = (endEvent) => {\r\n        canvas.removeEventListener(\"touchmove\", move);\r\n        canvas.removeEventListener(\"touchend\", end);\r\n        let board = {};\r\n        if (onMoveType === 1) {\r\n            let oldStart = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n            let newStart = {[[node.i,node.j]]: {node:node,type:'start',fill:'white',object:'start'}};\r\n            Object.assign(board, state.board, oldStart, newStart);\r\n            setState({board:board});\r\n        } else if (onMoveType === 2) {\r\n            let oldTarget = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n            let newTarget = {[[node.i,node.j]]: {node:node,type:'target',fill:'white',object:'target'}};\r\n            Object.assign(board, state.board, oldTarget, newTarget);\r\n            setState({board:board});\r\n        }\r\n    }\r\n    canvas.addEventListener(\"touchmove\", move);\r\n    canvas.addEventListener(\"touchend\", end);\r\n};\r\n\r\n//=====================================================================================//\r\n// Canvas Tools //\r\n//=====================================================================================//\r\nfunction drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) {\r\n    // Setting start of path\r\n    let currentNode = startNode;\r\n    let V = nodeDistance(endNode,startNode,s,xOffset,yOffset);\r\n    // Fill start if not off board and not start/target node\r\n    let canvasUpdates = {};\r\n    if (nodeOnBoard(currentNode,xUnits,yUnits) &&  !isSameNode(currentNode,state.startNode) &&  !isSameNode(currentNode,state.targetNode)\r\n    ) {\r\n        // might be a problem that currentNode changes over time\r\n        if (state.tool === 0) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'wall',fill:'#282c34',object:null}});\r\n        } else if (state.tool === 1) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'weight',fill:'white',object:'weight'}});\r\n        } else if (state.tool === 2) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'empty',fill:'white',object:null}});\r\n        }\r\n    }\r\n    // Looping over path\r\n    while (!isSameNode(currentNode,endNode)) {\r\n        // Reset minDis\r\n        let minDis = Infinity;\r\n        // Find next hex to move to by looping over adjacent hexs\r\n        let neighbors = findNeighbors(currentNode);\r\n        let tempNode = Object.assign({},currentNode);\r\n        for (let neighbor of neighbors) {\r\n            let v = nodeDistance(neighbor,tempNode,s,xOffset,yOffset);\r\n            let dotProd = dotProduct(v,V);\r\n            if (dotProd >= 0) {\r\n                v = nodeDistance(neighbor,startNode,s,xOffset,yOffset);\r\n                let currentDis = vectorOrthoMag(v,V);\r\n                if (currentDis < minDis) {\r\n                    currentNode = neighbor;\r\n                    minDis = currentDis;\r\n                }\r\n            }\r\n        }\r\n        // If next hex off board then end path\r\n        if (!nodeOnBoard(currentNode,xUnits,yUnits)) break;\r\n        // Fill next hex unless it is start or target node\r\n        else if (!isSameNode(currentNode,state.startNode) && !isSameNode(currentNode,state.targetNode)) {\r\n            // might be a problem that currentNode changes over time\r\n            if (state.tool === 0) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'wall',fill:'#282c34',object:null}});\r\n            } else if (state.tool === 1) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'weight',fill:'white',object:'weight'}});\r\n            } else if (state.tool === 2) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'empty',fill:'white',object:null}});\r\n            }\r\n        }\r\n    }\r\n    // Update state\r\n    setState((prevState) => {\r\n        return {\r\n                    board: Object.assign({},prevState.board,canvasUpdates),\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\nfunction moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) {\r\n    let angle = 0;\r\n    if (state.xUnits > state.yUnits) angle = -Math.PI/2;\r\n    let canvasUpdates = {[[newNode.i,newNode.j]]: {node:newNode,type:'start',fill:'white',object:'start',angle:angle}};             \r\n    const oldState = Object.assign({}, state.board[[oldNode.i,oldNode.j]]);\r\n    if (oldState.type === 'start') {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: {node:oldNode,type:'empty',fill:'white',object:null}});\r\n    } else {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: oldState});\r\n    }\r\n    setState((prevState) => {\r\n        return {\r\n                    startNode: newNode,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\nfunction moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) {\r\n    let canvasUpdates = {[[newNode.i,newNode.j]]: {node:newNode,type:'target',fill:'white',object:'target'}};             \r\n    const oldState = Object.assign({}, state.board[[oldNode.i,oldNode.j]]);\r\n    if (oldState.type === 'target') {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: {node:oldNode,type:'empty',fill:'white',object:null}});\r\n    } else {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: oldState});\r\n    }\r\n    setState((prevState) => {\r\n        return {\r\n                    targetNode: newNode,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\nfunction clearBoard(id,canvasRef,state,setState) {\r\n    if (id === 0) {\r\n        let canvas = canvasRef.current;\r\n        let cx = canvas.getContext('2d');\r\n        cx.clearRect(0,0,canvas.width,canvas.height);\r\n        let [board, startNode, targetNode] = initializeBoard(canvas.width, canvas.height, state.s);\r\n        setState((prevState) => {\r\n            return {\r\n                        board: board, \r\n                        startNode: startNode, \r\n                        targetNode: targetNode, \r\n                        canvasUpdates: board,\r\n                        updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    } else if (id === 4) {\r\n        let canvas = canvasRef.current;\r\n        let cx = canvas.getContext('2d');\r\n        cx.clearRect(0,0,canvas.width,canvas.height);\r\n        let { innerWidth: width, innerHeight: height } = window\r\n        let canvasHeight;\r\n        if (width < 481) canvasHeight = height*.85 - 4;\r\n        else canvasHeight = height*.9-4;\r\n        let canvasWidth = width;\r\n        //let [board, startNode, targetNode] = initializeBoard(canvasWidth, canvasHeight, state.s);\r\n        let {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset} = initializeCanvas(canvasWidth,canvasHeight,state.s);\r\n        // Setting Initial State\r\n        setState((prevState) => {\r\n            return {\r\n                canvasWidth: canvasWidth,\r\n                canvasHeight: canvasHeight,\r\n                board: board,\r\n                startNode: startNode,\r\n                targetNode: targetNode,\r\n                xUnits: xUnits,\r\n                yUnits: yUnits,\r\n                xOffset: xOffset,\r\n                yOffset: yOffset,\r\n                canvasUpdates: board,\r\n                updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    } else {\r\n        let canvasUpdates = {};\r\n        if (id === 1) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (!['white','#282c34'].includes(currentState.fill)) {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{fill:'white'});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n        } else if (id === 2) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (currentState.type === 'wall') {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{type:'empty',fill:'white',object:null});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n        } else if (id === 3) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (currentState.type === 'weight') {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{type:'empty',fill:'white',object:null});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        board: Object.assign({},prevState.board,canvasUpdates), \r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    }\r\n};\r\n\r\n//=====================================================================================//\r\n// Basic Drawing Functions //\r\n//=====================================================================================//\r\nfunction drawSearch(node,s,lineWidth,xOffset,yOffset,canvasRef,board,color) {\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    let state = board[[node.i,node.j]];\r\n    sleep(0).then(() => {\r\n        if (state === 'weight') {\r\n            drawWeight(pos,s,lineWidth,canvasRef,color);\r\n        } else {\r\n            fillHex(pos,s,color,canvasRef);\r\n            drawHex(pos,s,lineWidth,canvasRef)\r\n        }\r\n    });\r\n};\r\n\r\nfunction drawWeight(node,s,lineWidth,xOffset,yOffset,canvasRef){\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    let sideLength = s*.9;\r\n    let h = sideLength;\r\n    let w1 = sideLength;\r\n    let w2 = 1.5*sideLength;\r\n    let rw = sideLength*.18;\r\n    let r1 = sideLength*.33;\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    // draw trapezoid\r\n    let path = [\r\n                    {x:w1/2  , y:-h/2},\r\n                    {x:-w1/2 , y:-h/2},\r\n                    {x:-w2/2 , y:h/2},\r\n                    {x:w2/2  , y:h/2}\r\n    ]\r\n    cx.beginPath();\r\n    cx.fillStyle = 'black';\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i = 1; i < path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n    // draw ring\r\n    cx.beginPath();\r\n    let ringCenter = {x:pos.x, y:pos.y - h/2};\r\n    cx.lineWidth = rw;\r\n    cx.arc(ringCenter.x, ringCenter.y, r1, 0, 7);\r\n    cx.stroke();\r\n}\r\n\r\nfunction drawStart(startNode,s,xOffset,yOffset,canvasRef,angle) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    const r = .85;\r\n    const a = s*Math.sqrt(3)*r/2;\r\n    const b = a/1.3;\r\n    const c = a/2.6;\r\n    let path = [\r\n                { x:a    ,  y:0},\r\n                { x:-2*c ,  y:b},\r\n                { x:-c   ,  y:0},\r\n                { x:-2*c ,  y:-b}\r\n    ];\r\n    if (angle) {\r\n        for (let i=0; i<path.length; i++) {\r\n            let oldPos = path[i];\r\n            let newPos = {\r\n                x: oldPos.x*Math.cos(angle) - oldPos.y*Math.sin(angle),\r\n                y: oldPos.x*Math.sin(angle) + oldPos.y*Math.cos(angle)\r\n            }\r\n            path[i] = newPos;\r\n        }\r\n    }\r\n    let pos = calcHexCenter(startNode,s,xOffset,yOffset);\r\n    cx.fillStyle = 'black';\r\n    cx.beginPath();\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction drawTarget(targetNode,s,lineWidth,xOffset,yOffset,canvasRef) {\r\n    const sideLength = s;\r\n    let pos = calcHexCenter(targetNode,s,xOffset,yOffset);\r\n    // Outer Ring\r\n    fillHex(pos,sideLength,'#b22222',canvasRef);\r\n    // White Fill\r\n    fillHex(pos,sideLength*2/3 - lineWidth/2,'white',canvasRef);\r\n    // Inner Ring\r\n    fillHex(pos,sideLength/3,'#b22222',canvasRef);\r\n    // Remake Border\r\n    drawHex(pos,sideLength,lineWidth,canvasRef);\r\n};\r\n\r\nfunction drawNode(node,s,lineWidth,xOffset,yOffset,color,canvasRef) {\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    fillHex(pos,s,color,canvasRef);\r\n    drawHex(pos,s,lineWidth,canvasRef);\r\n};\r\n\r\n\r\n//=====================================================================================//\r\n// Helper Functions //\r\n//=====================================================================================//\r\n\r\n// Helpers for Canvas Tools//\r\n//========================================//\r\nfunction drawHex(pos,s,lineWidth,canvasRef) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    let path = calcHexPath(pos,s);\r\n    cx.lineWidth = lineWidth;\r\n    cx.beginPath();\r\n    cx.moveTo(path[0].x,path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(path[i].x,path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.stroke();\r\n};\r\n\r\nfunction fillHex(pos,s,color,canvasRef) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    cx.fillStyle = color;\r\n    let path = calcHexPath(pos,s);\r\n    cx.beginPath();\r\n    cx.moveTo(path[0].x, path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(path[i].x,path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n};\r\n\r\nfunction getPointerNode(event,domNode,s,xOffset,yOffset) {\r\n    let rect = domNode.getBoundingClientRect();\r\n    let x = event.clientX - rect.left;\r\n    let y = event.clientY - rect.top;\r\n    return nearestHex({x:x,y:y},s,xOffset,yOffset);\r\n};\r\n\r\n// Functions That Peform Grid Calculations//\r\n//========================================//\r\nfunction calcHexCenter(node,s,xOffset,yOffset) {\r\n    const x = xOffset + (node.j + 1 - ((node.i+1)%2)/2)*s*Math.sqrt(3);\r\n    const y = yOffset + (1.5*node.i + 1)*s\r\n    return {x:x, y:y};\r\n};\r\n\r\nfunction nodeDistance(node1,node2,s,xOffset,yOffset) {\r\n    let pos1 = calcHexCenter(node1,s,xOffset,yOffset);\r\n    let pos2 = calcHexCenter(node2,s,xOffset,yOffset);\r\n    return {x:(pos1.x - pos2.x) , y:(pos1.y - pos2.y)};\r\n};\r\n\r\nfunction nearestHex(pos,s,xOffset,yOffset) {\r\n    const J = Math.floor((pos.x - xOffset)/(s*Math.sqrt(3)));\r\n    const I = Math.floor((pos.y - yOffset)/(1.5*s));\r\n    const u = (pos.x - xOffset)/(s*Math.sqrt(3)) - J;\r\n    const v = 1 - ((pos.y - yOffset)/(1.5*s) - I);\r\n    let i, j;\r\n    if (I%2 === 0) {\r\n        if (u < .5) {\r\n            if (v > (2/3*u + 2/3)) {\r\n                [ i , j ] = [ I-1 , J-1 ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        } else {\r\n            if (v > (-2/3*u + 4/3)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        }\r\n    } else {\r\n        if (u < .5) {\r\n            if (v > (-2/3*u + 1)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J-1 ];\r\n            }\r\n        } else {\r\n            if (v > (2/3*u + 1/3)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        }\r\n    }\r\n    return {i:i,j:j};\r\n};\r\n\r\nfunction calcHexPath(pos, s) {\r\n    let path = [];\r\n    for (let theta = Math.PI/6; theta < 2*Math.PI; theta += Math.PI/3) {\r\n        const x = pos.x + s*Math.cos(theta);\r\n        const y = pos.y + s*Math.sin(theta);\r\n        path.push({x:x, y:y});\r\n    }\r\n    return path;\r\n};\r\n\r\nfunction calcUnits(canvasWidth, canvasHeight, s) {\r\n    const xUnits = Math.floor(canvasHeight/(1.5*s) - .5);\r\n    const yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)) - .5);\r\n    const xOffset = (canvasWidth - (yUnits + .5)*s*Math.sqrt(3))/2;\r\n    const yOffset = (canvasHeight - (xUnits*1.5 + .5)*s)/2;\r\n    return [xUnits,yUnits,xOffset,yOffset];\r\n};\r\n\r\nfunction initializeBoard(canvasWidth, canvasHeight, s) {   \r\n    let [xUnits,yUnits] = calcUnits(canvasWidth, canvasHeight, s);\r\n    let board = {};\r\n    for (let i = 0; i < xUnits; i++) {\r\n        for (let j = 0; j < yUnits; j++) {\r\n            Object.assign(board, {[[i,j]]: {node:{i:i,j:j}, type:'empty', fill:'white', object:null}})\r\n        }\r\n    }\r\n    let startNode, targetNode, offset;\r\n    if (xUnits > yUnits) {\r\n        offset = Math.floor(xUnits*.25);\r\n        startNode = {i: xUnits-1-offset, j: Math.floor(yUnits/2)};\r\n        targetNode = {i: offset, j: Math.floor(yUnits/2)};\r\n    } else {\r\n        offset = Math.floor(yUnits*.25);\r\n        startNode = {i: Math.floor(xUnits/2), j: offset};\r\n        targetNode = {i: Math.floor(xUnits/2), j: yUnits-1-offset};\r\n    }\r\n    let angle = 0;\r\n    if (xUnits > yUnits) angle = -Math.PI/2;\r\n    Object.assign(board[[startNode.i,startNode.j]], {type: 'start', object:'start', angle:angle});\r\n    Object.assign(board[[targetNode.i,targetNode.j]], {type: 'target', object:'target'});\r\n    return [board, startNode, targetNode];\r\n};\r\n\r\nfunction initializeCanvas(canvasWidth,canvasHeight,s) {\r\n    let [xUnits,yUnits,xOffset,yOffset] = calcUnits(canvasWidth, canvasHeight, s);\r\n    let [board, startNode, targetNode] = initializeBoard(canvasWidth, canvasHeight, s);\r\n    let lineWidth = s/10;\r\n    return {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset,lineWidth};\r\n}\r\n\r\nfunction parseKey(key) {\r\n    let [i,j] = key.split(',').map((item) => parseInt(item));\r\n    return {i:i,j:j};\r\n};\r\n\r\n//=====================================================================================//\r\n// Exports //\r\n//=====================================================================================//\r\nexport {getPointerNode, onMouseDown, onTouchStart}\r\nexport {drawSearch, drawLine, moveStart, moveTarget, clearBoard}\r\nexport {drawWeight, drawStart, drawTarget, drawNode, drawHex, fillHex};\r\nexport {sleep, calcHexCenter, nodeDistance, nearestHex, calcHexPath, calcUnits, initializeBoard, initializeCanvas, parseKey};","import React from 'react';\r\nimport {initializeBoard, drawWeight, drawStart, drawTarget, drawNode} from '../utils/canvas-tools';\r\n\r\n/*\r\n// To Do //\r\n//========================================================================================//\r\n-- Make new drawWeight function that takes node as imput instead of pos\r\n\r\n//========================================================================================//\r\n*/\r\n\r\n\r\nclass Canvas extends React.Component {\r\n    componentDidMount() {\r\n        let [board] = initializeBoard(this.props.width, this.props.height, this.props.s);\r\n        for (let key in board) {\r\n            let {node, fill, object, angle} = board[key];\r\n            this.updateNode(node, fill, object, angle);\r\n        }\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps) {\r\n        if (nextProps.updateID === this.props.updateID) return false;\r\n        else return true;\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (this.props.s !== prevProps.s) {\r\n            let canvas = this.props.canvasRef.current;\r\n            let cx = canvas.getContext('2d');\r\n            cx.clearRect(0,0,this.props.width,this.props.height);\r\n            this.componentDidMount();\r\n        } else {\r\n            for (let key in this.props.canvasUpdates) {\r\n                let {node, fill, object, angle} = this.props.canvasUpdates[key];\r\n                this.updateNode(node, fill, object, angle);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateNode(node,fill,object,angle) {\r\n        if (fill) {\r\n            // need to fill white first if color = '#b7ff4ae8' since it is transparent\r\n            drawNode(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, fill, this.props.canvasRef);\r\n        }\r\n        if (object) {\r\n            if (object === 'weight') {\r\n                drawWeight(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, this.props.canvasRef);\r\n            } else if (object === 'start') {\r\n                //console.log(angle);\r\n                drawStart(node, this.props.s, this.props.xOffset, this.props.yOffset, this.props.canvasRef,angle);\r\n            } else if (object === 'target') {\r\n                drawTarget(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, this.props.canvasRef);\r\n            }\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <canvas\r\n                ref = {this.props.canvasRef}\r\n                width = {this.props.width}\r\n                height = {this.props.height}\r\n                onMouseDown={this.props.running ? null : (downEvent) => this.props.onMouseDown(downEvent)}\r\n                onTouchStart={this.props.running ? null : (startEvent) => this.props.onTouchStart(startEvent)}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default Canvas;","import {isSameNode, isValidNode, findNeighbors, manhattanDistance, minHeap} from './utils';\r\n\r\n//=====================================================================================//\r\n// Unweighted Algorithms //\r\n//=====================================================================================//\r\nfunction depthFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.unshift(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction breadthFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.push(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction hillClimbing(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // sort nodes according to distance to target node (descending)\r\n        neighbors.sort((node1,node2) => manhattanDistance(node2,targetNode) - manhattanDistance(node1,targetNode));\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.unshift(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction beamSearch(startNode,targetNode,xUnits,yUnits,board, w = 2) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // sort nodes according to distance to target node (descending)\r\n        neighbors.sort((node1,node2) => manhattanDistance(node2,targetNode) - manhattanDistance(node1,targetNode));\r\n        // filter to valid nodes and keep only the first w number of them\r\n        neighbors = neighbors.filter(\r\n            (node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j))\r\n        ).slice(-w);\r\n        for (let newNode of neighbors) {\r\n            let newPath = currentPath.concat([newNode]);\r\n            // if we found target return the completed path and updates, else add path extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                return [newPath, searchUpdates];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.push(newPath);\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction bestFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.distance < path2.distance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({distance:manhattanDistance(startNode,targetNode) , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = path.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.insert({distance:manhattanDistance(newNode,targetNode) , path:newPath});\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\n\r\n//=====================================================================================//\r\n// Weighted Algorithms //\r\n//=====================================================================================//\r\n// Dictionary below determines relative weight moving from one node to another.\r\n// Essentially moving through a weight is 10 times as difficult as an empty node.\r\nconst pathWeights = {'empty':1, 'weight':10, 'target':1};\r\n\r\nfunction branchNBound(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.distance < path2.distance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    let bestDistance = Infinity;\r\n    let bestPath = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            // if newDistance is not less than the bestDistance to the target so far, then drop the path from the queue\r\n            if (newDistance >= bestDistance) {\r\n                if (!isSameNode(newNode,targetNode)) {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                }\r\n                continue;\r\n            };\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                [bestPath, bestDistance] = [newPath, newDistance];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({distance:newDistance , path:newPath});\r\n            }\r\n        }\r\n    }\r\n    // Return best path (which could be empty if no path found) and searchUpdates for animation\r\n    return [bestPath, searchUpdates];\r\n};\r\n\r\nfunction aStarSearch(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.estimatedDistance < path2.estimatedDistance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({estimatedDistance:manhattanDistance(startNode,targetNode), distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                // extend other paths to be sure they aren't actually closer to the target (not sure about this part)\r\n                return [newPath, searchUpdates];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({\r\n                    estimatedDistance: newDistance + manhattanDistance(newNode,targetNode), \r\n                    distance:newDistance, \r\n                    path:newPath\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\n\r\n\r\n// This is an old version of branch and bound algorithm. It doesn't have employ the check at the end\r\n// once the target node is found, but I'm keeping it around because it's structure is much simpler\r\n// and might be useful later.\r\n/*\r\nfunction branchNBound(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.distance < path2.distance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        // sort nodes according to weighted distance from currentNode (descending)\r\n        neighbors.sort((node1,node2) => pathWeights[board[[node2.i,node2.j]].type] - pathWeights[board[[node1.i,node1.j]].type]);\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                // extend other paths to be sure they aren't actually closer to the target (not sure about this part)\r\n                return [newPath, searchUpdates];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({distance:newDistance , path:newPath});\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n*/\r\n\r\n// Similar to above, this is an old version of the A* search algorithm. However, this old method does in fact run\r\n// a check after finding the target, but I now realize that this check is uneccessary. The heuristic distance is\r\n// always a lower bound which means there is no possibility of finding a shorter path once we have reached the target.\r\n/*\r\nfunction aStarSearch(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.estimatedDistance < path2.estimatedDistance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({estimatedDistance:manhattanDistance(startNode,targetNode), distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    let bestDistance = Infinity;\r\n    let bestPath = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        // sort nodes according to weighted distance from currentNode (descending) (this actually might not be necessary)\r\n        //neighbors.sort((node1,node2) => pathWeights[board[[node2.i,node2.j]].type] - pathWeights[board[[node1.i,node1.j]].type]);\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            let estimatedDistance = newDistance + manhattanDistance(newNode,targetNode);\r\n            // if newDistance is not less than the bestDistance to the target so far, then drop the path from the queue\r\n            if (estimatedDistance >= bestDistance) {\r\n                if (!isSameNode(newNode,targetNode)) {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                }\r\n                continue;\r\n            };\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                [bestPath, bestDistance] = [newPath, newDistance];\r\n                console.log(`bestDistance:${bestDistance}`);\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({\r\n                    estimatedDistance: estimatedDistance, \r\n                    distance:newDistance, \r\n                    path:newPath\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [bestPath, searchUpdates];\r\n};\r\n*/\r\n\r\nexport {depthFirst, breadthFirst, hillClimbing, beamSearch, bestFirst, branchNBound, aStarSearch};","import {depthFirst, breadthFirst, hillClimbing, beamSearch, bestFirst, branchNBound, aStarSearch} from './algorithms';\r\n\r\nfunction pathFinderAnimation(state,canvasRef,setState,isRunning) {\r\n    // Set state to running so user can't interfere with pathFinder \r\n    setState((prevState) => ({\r\n        running: true, \r\n        updateID: prevState.updateID + 1\r\n    }));\r\n    let pathFinder;\r\n    switch (state.algorithm) {\r\n        case 0: pathFinder = depthFirst; break;\r\n        case 1: pathFinder = breadthFirst; break;\r\n        case 2: pathFinder = hillClimbing; break;\r\n        case 3: pathFinder = beamSearch; break;\r\n        case 4: pathFinder = bestFirst; break;\r\n        case 5: pathFinder = branchNBound; break;\r\n        case 6: pathFinder = aStarSearch; break;\r\n        default: pathFinder = breadthFirst;\r\n    };\r\n    //let startTime = performance.now();\r\n    let [path, searchUpdates] = pathFinder(state.startNode,state.targetNode,state.xUnits,state.yUnits,state.board);\r\n    //let endTime = performance.now();\r\n    //console.log(`Algorithm Time = ${endTime - startTime}`);\r\n    let hexsPerSecond;\r\n    switch (state.speed) {\r\n        case 0: hexsPerSecond = 10; break;\r\n        case 1: hexsPerSecond = 100; break;\r\n        case 2: hexsPerSecond = 1000; break;\r\n        case 3: hexsPerSecond = 10000; break;\r\n        case 4: hexsPerSecond = Infinity; break;\r\n        default: hexsPerSecond = 1000;\r\n    };\r\n    searchAnimation(path,searchUpdates,hexsPerSecond,state.board,setState,isRunning);\r\n};\r\n\r\nfunction searchAnimation(path,searchUpdates,hexsPerSecond,board,setState,isRunning) {\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = searchUpdates.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = searchUpdates.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                pathAnimation(path,Math.ceil(hexsPerSecond/6),board,setState,isRunning);\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction pathAnimation(path,hexsPerSecond,board,setState,isRunning) {\r\n    let pathUpdates = [];\r\n    for (let node of path.slice(1,-1)) {\r\n        pathUpdates.push(Object.assign({},board[[node.i,node.j]],{fill:'#b1fc40'}));\r\n    }\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = pathUpdates.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = pathUpdates.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                setState((prevState) => ({\r\n                    running: false,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: []\r\n                }));\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nexport {pathFinderAnimation};","import React from 'react';\r\nimport ControlPanel from './ControlPanel';\r\nimport Canvas from './Canvas';\r\nimport {onMouseDown, onTouchStart, clearBoard, initializeCanvas} from '../utils/canvas-tools';\r\nimport {pathFinderAnimation} from '../utils/animations';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faBars} from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass PathFinder extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        let { innerWidth: width, innerHeight: height } = window\r\n        // Setting Up Canvas\r\n        let canvasHeight;\r\n        if (width < 481) canvasHeight = height*.85;\r\n        else canvasHeight = height*.9-4;\r\n        let canvasWidth = width;\r\n        this.canvasRef = React.createRef();\r\n        let s = 15;\r\n        let {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset,lineWidth} = initializeCanvas(canvasWidth,canvasHeight,s);\r\n        // Setting Initial State\r\n        this.state = {\r\n            algorithm: 5,\r\n            speed: 2,\r\n            tool: 0,\r\n            canvasWidth: canvasWidth,\r\n            canvasHeight: canvasHeight,\r\n            s: s,\r\n            lineWidth: lineWidth,\r\n            board: board,\r\n            startNode: startNode,\r\n            targetNode: targetNode,\r\n            xUnits: xUnits,\r\n            yUnits: yUnits,\r\n            xOffset: xOffset,\r\n            yOffset: yOffset,\r\n            running: false,\r\n            canvasUpdates: [],\r\n            updateID: 0\r\n        }\r\n    }\r\n\r\n    toggleSelected(key,id) {\r\n        if (key !== 'clear') {\r\n            this.setState({\r\n                [key]:id\r\n            })\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    startPathFinder() {\r\n        // Check to make sure not already running\r\n        if (this.state.running) return;\r\n        const setState = (stateUpdate) => this.setState(stateUpdate);\r\n        const isRunning = () => {return this.state.running;};\r\n        this.clearBoard(1);\r\n        pathFinderAnimation(this.state,this.canvasRef,setState,isRunning);\r\n    }\r\n\r\n    stopPathFinder() {\r\n        this.setState((prevState) => ({running:false, updateID:prevState.updateID+1}));\r\n    }\r\n\r\n    onMouseDown(downEvent) {\r\n        onMouseDown(downEvent,this.state,this.canvasRef,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    onTouchStart(startEvent) {\r\n        onTouchStart(startEvent,this.state,this.canvasRef,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    clearBoard(id) {\r\n        if (this.state.running) return;\r\n        clearBoard(id,this.canvasRef,this.state,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    changeHexSize(s) {\r\n        if (this.state.running) return;\r\n        this.setState((prevState) => {\r\n            return Object.assign(\r\n                {}, \r\n                initializeCanvas(prevState.canvasWidth,prevState.canvasHeight,s),\r\n                {updateID: prevState.updateID + 1, canvasUpdates: [], s:s}\r\n            );\r\n        });\r\n    }\r\n\r\n    render() {\r\n        const algorithmMap = {\r\n            0: \"Depth-First Search\",\r\n            1: \"Breadth-First Search\",\r\n            2: \"Hill Climbing\",\r\n            3: \"Beam Search (\\u03C9=2)\",\r\n            4: \"Best-First Search\",\r\n            5: \"Branch & Bound\",\r\n            6: \"A* Search\"\r\n        };\r\n        const speedMap = {\r\n\r\n        };\r\n        return (\r\n            <div className=\"PathFinder\">\r\n                <div className=\"Bars-Wrapper\">\r\n                    <FontAwesomeIcon className=\"bars\" icon={faBars}/>\r\n                    <div className=\"Algorithm-Text\">{algorithmMap[1]}</div>\r\n                </div>\r\n                <ControlPanel\r\n                    running={this.state.running} \r\n                    toggleSelected={(key,id) => this.toggleSelected(key,id)}\r\n                    clearBoard={(id) => this.clearBoard(id)}\r\n                    changeHexSize={(s) => this.changeHexSize(s)}\r\n                    startSearch={() => this.startPathFinder()}\r\n                    stopSearch={() => this.stopPathFinder()}\r\n                />\r\n                <Canvas\r\n                    className=\"canvas\"\r\n                    canvasRef={this.canvasRef}\r\n                    width={this.state.canvasWidth}\r\n                    height={this.state.canvasHeight}\r\n                    s={this.state.s}\r\n                    lineWidth={this.state.lineWidth}\r\n                    xOffset={this.state.xOffset}\r\n                    yOffset={this.state.yOffset}\r\n                    canvasUpdates={this.state.canvasUpdates}\r\n                    updateID={this.state.updateID}\r\n                    running={this.state.running}\r\n                    onMouseDown={(downEvent) => this.onMouseDown(downEvent)}\r\n                    onTouchStart={(startEvent) => this.onTouchStart(startEvent)}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathFinder;","import React from 'react';\nimport PathFinder from './components/PathFinder';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFinder />\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}