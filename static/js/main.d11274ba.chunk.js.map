{"version":3,"sources":["components/Dropdown.js","components/SliderDropdown.js","components/ControlPanel.js","utils/utils.js","utils/canvas-tools.js","components/Canvas.js","utils/algorithms.js","utils/animations.js","components/PathFinder.js","App.js","serviceWorker.js","index.js"],"names":["Dropdown","props","state","listOpen","headerTitle","title","options","this","setState","prevState","event","key","toggleList","document","addEventListener","escapeList","backgroundColor","fontColor","windowState","className","onClick","style","color","icon","faAngleUp","size","transform","faAngleDown","map","item","id","callBack","selected","faCheck","React","Component","onClickOutside","SliderDropdown","value","hexSize","target","window","innerWidth","innerHeight","type","orient","min","max","onInput","changeValue","onMouseUp","submitValue","onKeyDown","onTouchEnd","ControlPanel","algorithm","speed","tool","mazes","clear","temp","slice","i","length","toggleSelected","showControls","disableOnClickOutside","s","changeHexSize","drawMaze","clearBoard","running","clickEvent","stopSearch","startSearch","faPause","faPlay","DIRECTIONS","j","isSameNode","node1","node2","nodeOnBoard","node","xUnits","yUnits","isValidNode","board","findNeighbors","directions","neighbors","change","neighbor","push","manhattanDistance","hexCoord1","hexCoordinates","hexCoord2","dx","x","dy","y","Math","sign","abs","ceil2","scalarProd","a","v","vectorDiff","v1","v2","vectorSum","vectorAngle","angle","atan","PI","minHeap","lessThan","heap","floor","minValue","shift","unshift","pop","disjointSet","dictionary","hasOwnProperty","parent","xRoot","find","yRoot","shuffleArray","array","arrayCopy","random","drawLine","startNode","endNode","lineWidth","xOffset","yOffset","canvasRef","canvasUpdates","N","calcHexCenter","startPos","V","line","n","nearestHex","targetNode","Object","assign","fill","object","updateID","moveStart","oldNode","newNode","oldState","moveTarget","drawWeight","pos","sideLength","h","w1","w2","rw","r1","cx","current","getContext","path","beginPath","fillStyle","moveTo","lineTo","closePath","ringCenter","arc","stroke","drawHex","calcHexPath","fillHex","getPointerNode","domNode","rect","getBoundingClientRect","clientX","left","clientY","top","sqrt","J","I","u","theta","cos","sin","calcUnits","canvasWidth","canvasHeight","initializeBoard","offset","initializeCanvas","console","log","parseKey","split","parseInt","Canvas","width","height","updateNode","nextProps","prevProps","clearRect","componentDidMount","startPosition","b","c","oldPos","newPos","drawStartPos","drawNode","drawStart","drawTarget","ref","onMouseDown","downEvent","onTouchStart","startEvent","depthFirst","queue","visitedNodes","Set","searchUpdates","currentPath","currentNode","has","add","newState","newPath","concat","breadthFirst","hillClimbing","sort","beamSearch","w","filter","bestFirst","path1","path2","distance","insert","pathWeights","branchNBound","bestDistance","Infinity","bestPath","newDistance","aStarSearch","estimatedDistance","randomWalls","mazePath","randomWeights","depthFirstMaze","nodesToAdd","breadthFirstMaze","kruskalsMaze","unVisitedNodes","pathNodes","disjointPaths","roots","rootsSet","makeSet","union","primsMaze","startFound","targetFound","huntAndKill","newRandomWalk","searchSpeed","0","1","2","3","4","drawPathSpeed","moveDownPathSpeed","victorySpeed","drawMazeSpeed","pathFinderAnimation","isRunning","pathFinder","hexsPerSecond","lastTime","currentStart","steps","totalHexs","requestAnimationFrame","frame","time","start","boardUpdates","update","updateAnimation","pathUpdates","totalSteps","totalTime","startTime","prevStartNode","prevEndNode","endPos","prevNode","radiansPerSecond","targetPos","startAngle","pos1","pos2","nodeDistance","victoryAnimation","moveDownPathAnimation","drawPathAnimation","searchAnimation","mazeAnimation","mazeID","mazeBuilder","PathFinder","getWindowState","createRef","handleResize","stateUpdate","button","onMove","onMoveType","canvas","origNode","move","moveEvent","buttons","removeEventListener","oldStart","newStart","oldTarget","newTarget","preventDefault","touches","end","endEvent","currentState","includes","doTheJohnWall","faBars","toggleControls","5","6","startPathFinder","stopPathFinder","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.d11274ba.chunk.js","sourcesContent":["import React from 'react';\r\nimport onClickOutside from 'react-onclickoutside';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleUp , faAngleDown, faCheck } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass Dropdown extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            listOpen: false,\r\n            headerTitle: this.props.title,\r\n            options: this.props.options\r\n        }\r\n    }\r\n\r\n    handleClickOutside() {\r\n        this.setState({listOpen: false});\r\n    }\r\n\r\n    toggleList() {\r\n        this.setState(prevState => ({\r\n            listOpen: !prevState.listOpen\r\n        }));\r\n    }\r\n\r\n    escapeList(event) {\r\n        if (this.state.listOpen && event.key === 'Escape') this.toggleList();\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('keydown',(event) => this.escapeList(event));\r\n    }\r\n\r\n    render() {\r\n        const {listOpen, headerTitle, options} = this.state;\r\n        let backgroundColor, fontColor;\r\n        if (this.props.windowState === 1 || this.props.windowState === 2) {\r\n            if (listOpen) [ backgroundColor , fontColor ] = ['#27af62' , 'white' ];\r\n            else [ backgroundColor , fontColor ] = [ 'white' , 'black' ];\r\n        } else [ backgroundColor , fontColor ] = [ '#191414' , 'white' ];\r\n        return (\r\n            <div className=\"Dropdown\">\r\n                <div className=\"Dropdown-header-wrapper\">\r\n                    <div className=\"Dropdown-header\" onClick={() => this.toggleList()} style = {{backgroundColor: backgroundColor, color:fontColor}}>\r\n                        <div className=\"Dropdown-header-title\">{headerTitle}</div>\r\n                        {listOpen\r\n                            ? <FontAwesomeIcon className=\"angle-up\" icon={faAngleUp} size=\"lg\" transform=\"down-1\"/>\r\n                            : <FontAwesomeIcon className=\"angle-down\" icon={faAngleDown} size=\"lg\" transform=\"down-1\"/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n                {listOpen && <ul className={headerTitle+\"-Dropdown-list\"}>\r\n                    {options.map((item) => (\r\n                        <li key={item.id} className=\"Dropdown-list-item\" onClick={() => this.props.callBack(item.id,item.key,item.title)}>\r\n                            {item.title}\r\n                            {item.selected && <FontAwesomeIcon className=\"check\" icon={faCheck} size=\"1x\"/>}\r\n                        </li>\r\n                    ))}\r\n                </ul>}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default onClickOutside(Dropdown);","import React from 'react';\r\nimport onClickOutside from 'react-onclickoutside';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faAngleUp , faAngleDown} from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass SliderDropdown extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            listOpen: false,\r\n            headerTitle: this.props.title,\r\n            value: this.props.hexSize\r\n        }\r\n    }\r\n\r\n    handleClickOutside() {\r\n        this.setState({\r\n            listOpen: false\r\n        });\r\n    }\r\n\r\n    toggleList() {\r\n        this.setState(prevState => ({\r\n            listOpen: !prevState.listOpen\r\n        }));\r\n    }\r\n\r\n    changeValue(event) {\r\n        this.setState({value:event.target.value});\r\n    }\r\n\r\n    submitValue(event) {\r\n        this.props.callBack(event.target.value);\r\n    }\r\n\r\n    escapeList(event) {\r\n        if (this.state.listOpen && event.key === 'Escape') this.toggleList();\r\n    }\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('keydown',(event) => this.escapeList(event));\r\n    }\r\n\r\n    render() {\r\n        let backgroundColor, fontColor;\r\n        if (window.innerWidth < 481 || window.innerHeight < 481) {\r\n            if (this.state.listOpen) [ backgroundColor , fontColor ] = ['#27af62' , 'white' ];\r\n            else [ backgroundColor , fontColor ] = [ 'white' , 'black' ];\r\n        } else [ backgroundColor , fontColor ] = [ '#191414' , 'white' ];\r\n        return (\r\n            <div className=\"Dropdown\">\r\n                <div className=\"Dropdown-header-wrapper\">\r\n                    <div className=\"Dropdown-header\" onClick={() => this.toggleList()} style = {{backgroundColor: backgroundColor, color:fontColor}}>\r\n                        <div className=\"Dropdown-header-title\">{this.state.headerTitle}</div>\r\n                        {this.state.listOpen\r\n                            ? <FontAwesomeIcon className=\"angle-up\" icon={faAngleUp} size=\"lg\" transform=\"down-1\"/>\r\n                            : <FontAwesomeIcon className=\"angle-down\" icon={faAngleDown} size=\"lg\" transform=\"down-1\"/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n                {this.state.listOpen && <div className={\"SliderDropdown-list\"}>\r\n                    <div className=\"slider-text\">{this.state.value}</div>\r\n                    <input className=\"slider\" type=\"range\" orient=\"vertical\" min=\"5\" max=\"100\"\r\n                        value={this.state.value}\r\n                        onInput={(event) => this.changeValue(event)}\r\n                        onMouseUp={(event) => this.submitValue(event)}\r\n                        onKeyDown={(event) => {if (event.key === \"Enter\") this.submitValue(event);}}\r\n                        onTouchEnd={(event) => this.submitValue(event)}\r\n                    />\r\n                </div>}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default onClickOutside(SliderDropdown);","import React from 'react';\r\nimport Dropdown from './Dropdown';\r\nimport SliderDropdown from './SliderDropdown';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faPlay , faPause } from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass ControlPanel extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            algorithm: [\r\n                        {id:0, title:'Depth-First Search', selected:false, key:'algorithm'},\r\n                        {id:1, title:'Breadth-First Search', selected:false, key:'algorithm'},\r\n                        {id:2, title:'Hill Climbing', selected:false, key:'algorithm'},\r\n                        {id:3, title:'Beam Search (\\u03C9=2)', selected:false, key:'algorithm'},\r\n                        {id:4, title:'Best-First Search', selected:false, key:'algorithm'},\r\n                        {id:5, title:'Branch & Bound', selected:true, key:'algorithm'},\r\n                        {id:6, title:'A* Search', selected:false, key:'algorithm'}\r\n            ],\r\n            speed: [\r\n                        {id:0, title:'Slow', selected:false, key:'speed'},\r\n                        {id:1, title:'Medium', selected:false, key:'speed'},\r\n                        {id:2, title:'Fast', selected:true, key:'speed'},\r\n                        {id:3, title:'Ludicrous', selected:false, key:'speed'},\r\n                        {id:4, title:'Instant', selected:false, key:'speed'}\r\n            ],\r\n            tool: [\r\n                        {id:0, title:'Walls', selected:true, key:'tool'},\r\n                        {id:1, title:'Weights', selected:false, key:'tool'},\r\n                        {id:2, title:'Eraser', selected:false, key:'tool'}\r\n            ],\r\n            mazes: [\r\n                        {id:0, title:'Random Walls', selected:false, key:'mazes'},\r\n                        {id:1, title:'Random Weights', selected:false, key:'mazes'},\r\n                        {id:2, title:'Depth-First Maze', selected:false, key:'mazes'},\r\n                        {id:3, title:'Breadth-First Maze', selected:false, key:'mazes'},\r\n                        {id:4, title:\"Hunt & Kill Maze\", selected:false, key:'mazes'},\r\n                        {id:5, title:\"Prim's Maze\", selected:false, key:'mazes'},\r\n                        {id:6, title:\"Kruskal's Maze\", selected:false, key:'mazes'}\r\n            ],\r\n            clear: [\r\n                        {id:1, title:'Path', selected:false, key:'clear'},\r\n                        {id:2, title:'Walls', selected:false, key:'clear'},\r\n                        {id:3, title:'Weights', selected:false, key:'clear'},\r\n                        {id:0, title:'Board', selected:false, key:'clear'},\r\n                        {id:4, title:'Canvas', selected:false, key:'clear'}\r\n            ]\r\n        }\r\n    }\r\n\r\n    toggleSelected(id,key,title) {\r\n        if (key !== 'clear') {\r\n            let temp = this.state[key].slice();\r\n            for (let i = 0; i < temp.length; i++) {\r\n                temp[i].selected = (id === temp[i].id);\r\n            }\r\n            this.setState({\r\n                [key]:temp\r\n            });\r\n        }\r\n        this.props.toggleSelected(key,id);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"ControlPanel\">\r\n                {this.props.showControls &&\r\n                    <div className=\"Controls-Wrapper-Background\">\r\n                        <div className=\"Controls-Wrapper\">\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Algorithm-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Algorithm'} \r\n                                    options={this.state.algorithm}\r\n                                    callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                                    disableOnClickOutside={this.props.windowState === 1}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\"> \r\n                                <Dropdown className=\"Speed-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Speed'} \r\n                                    options={this.state.speed}\r\n                                    callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                                    disableOnClickOutside={this.props.windowState === 1}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Tool-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Tool'} \r\n                                    options={this.state.tool}\r\n                                    callBack = {(id,key,title) => this.toggleSelected(id,key,title)}\r\n                                    disableOnClickOutside={this.props.windowState === 1}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <SliderDropdown className=\"Hex-Size-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Hex Size'}\r\n                                    hexSize={this.props.hexSize}\r\n                                    callBack = {(s) => this.props.changeHexSize(s)}\r\n                                    disableOnClickOutside={this.props.windowState === 1}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Mazes-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Mazes'} \r\n                                    options={this.state.mazes}\r\n                                    callBack = {(id,key,title) => this.props.drawMaze(id)}\r\n                                    disableOnClickOutside={this.props.windowState === 1}\r\n                                />\r\n                            </div>\r\n                            <div className=\"ControlPanel-column\">\r\n                                <Dropdown className=\"Clear-Dropdown\"\r\n                                    windowState={this.props.windowState}\r\n                                    title={'Clear'} \r\n                                    options={this.state.clear}\r\n                                    callBack = {(id,key,title) => this.props.clearBoard(id)}\r\n                                    disableOnClickOutside={this.props.windowState === 1}\r\n                                />\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                }\r\n                <div className=\"Play-Button-Wrapper\">\r\n                    <div className=\"Play-Button\" onClick={this.props.running\r\n                        ? (clickEvent) => this.props.stopSearch()\r\n                        : (clickEvent) => this.props.startSearch()\r\n                    }>\r\n                        {this.props.running\r\n                            ? <FontAwesomeIcon className=\"pause\" icon={faPause}/>\r\n                            : <FontAwesomeIcon className=\"play\" icon={faPlay}/>\r\n                        }\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ControlPanel;","//=====================================================================================//\r\n// Constants //\r\n//=====================================================================================//\r\nconst DIRECTIONS = {\r\n    even: [\r\n            { i:0  , j:1 },\r\n            { i:-1 , j:0 },\r\n            { i:-1 , j:-1 },\r\n            { i:0  , j:-1 },\r\n            { i:1  , j:-1 },\r\n            { i:1  , j:0 }\r\n    ],\r\n    odd: [\r\n            { i:0  , j:1 },\r\n            { i:-1 , j:1 },\r\n            { i:-1 , j:0 },\r\n            { i:0  , j:-1 },\r\n            { i:1  , j:0 },\r\n            { i:1  , j:1 }\r\n    ]\r\n};\r\n\r\n//=====================================================================================//\r\n// Helper Functions //\r\n//=====================================================================================//\r\n\r\n// Node Functions: node = {i:i,j:j}//\r\n//=================================//\r\nfunction isSameNode(node1,node2) {\r\n    return (node1.i === node2.i && node1.j === node2.j);\r\n};\r\n\r\nfunction nodeInPath(node,path) {\r\n    for (let pathNode of path) {\r\n        if (isSameNode(node,pathNode)) return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nfunction addNodes(node1,node2) {\r\n    return { i:(node1.i + node2.i) , j:(node1.j + node2.j) };\r\n};\r\n\r\nfunction nodeOnBoard(node,xUnits,yUnits) {\r\n    return (node.i>=0 && node.j>=0 && node.i<xUnits && node.j<yUnits);\r\n};\r\n\r\nfunction isValidNode(node,board,xUnits,yUnits) {\r\n    let state = board[[node.i,node.j]];\r\n    let onBoard = nodeOnBoard(node,xUnits,yUnits);\r\n    return (onBoard && state.type !== 'wall');\r\n};\r\n\r\nfunction findNeighbors(node) {\r\n    let neighbors = [];\r\n    let directions;\r\n    if (node.i%2 === 0) directions = DIRECTIONS.even;\r\n    else directions = DIRECTIONS.odd;\r\n    for (let change of directions) {\r\n        let neighbor = addNodes(node,change);\r\n        neighbors.push(neighbor);\r\n    }\r\n    return neighbors;\r\n};\r\n\r\nfunction manhattanDistance(node1,node2) {\r\n    const hexCoord1 = hexCoordinates(node1);\r\n    const hexCoord2 = hexCoordinates(node2);\r\n    const dx = hexCoord2.x - hexCoord1.x;\r\n    const dy = hexCoord2.y - hexCoord1.y;\r\n    if (Math.sign(dx) === Math.sign(dy)) {\r\n        return Math.max(Math.abs(dx), Math.abs(dy));\r\n    }\r\n    return Math.abs(dx) + Math.abs(dy);\r\n};\r\n\r\nfunction hexCoordinates(node) {\r\n    return { x: node.j - floor2(node.i) , y: node.j + ceil2(node.i) };\r\n};\r\n\r\nfunction floor2(x) {\r\n    return ((x >= 0) ? (x >> 1) : (x - 1) / 2);\r\n};\r\n\r\nfunction ceil2(x) {\r\n    return ((x >= 0) ? ((x + 1) >> 1) : x / 2);\r\n}\r\n\r\n// Vectors Functions: v = {x:x,y:y} //\r\n//==================================//\r\nfunction dotProduct(v1,v2) {\r\n    return v1.x*v2.x + v1.y*v2.y;\r\n};\r\n\r\nfunction scalarProd(a,v) {\r\n    return {x:a*v.x , y:a*v.y};\r\n};\r\n\r\nfunction vectorDiff(v1,v2) {\r\n    return {x: v1.x - v2.x, y: v1.y - v2.y};\r\n};\r\n\r\nfunction vectorSum(v1,v2) {\r\n    return {x: v1.x + v2.x, y: v1.y + v2.y};\r\n};\r\n\r\nfunction vectorMag(v) {\r\n    return Math.sqrt((v.x)**2 + (v.y)**2);\r\n};\r\n\r\nfunction vectorOrthoMag(v,V) {\r\n    let b = scalarProd(dotProduct(v,V)/(vectorMag(V))**2, V);\r\n    let d =  vectorDiff(v, b);\r\n    return vectorMag(d);\r\n};\r\n\r\nfunction vectorAngle(v) {\r\n    let angle = Math.atan( v.y / v.x );\r\n    if (v.x < 0) angle += Math.PI;\r\n    return angle;\r\n};\r\n\r\n// Data Structures for Algorithms //\r\n//==================================//\r\nclass minHeap {\r\n    constructor(lessThan) {\r\n        this.heap = [];\r\n        this.lessThan = lessThan\r\n    }\r\n\r\n    length() {\r\n        return this.heap.length;\r\n    }\r\n\r\n    getMin() {\r\n        return this.heap[0];\r\n    }\r\n\r\n    insert(value) {\r\n        this.heap.push(value);\r\n        let i = this.heap.length-1;\r\n        while (i > 0) {\r\n            if (this.lessThan(this.heap[i] , this.heap[Math.floor((i-1)/2)])) {\r\n                [ this.heap[Math.floor((i-1)/2)] , this.heap[i] ] = [ this.heap[i] , this.heap[Math.floor((i-1)/2)] ];\r\n                i = Math.floor((i-1)/2);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    shift() {\r\n        const minValue = this.heap.shift();\r\n        if (this.heap.length === 0) return minValue;\r\n        this.heap.unshift(this.heap.pop());\r\n        let i = 0;\r\n        while (2*i+2 < this.heap.length) {\r\n            if (this.lessThan(this.heap[2*i+1], this.heap[i]) || this.lessThan(this.heap[2*i+2], this.heap[i])) {\r\n                if (this.lessThan(this.heap[2*i+1], this.heap[2*i+2])) {\r\n                    [ this.heap[2*i+1], this.heap[i] ] = [ this.heap[i] , this.heap[2*i+1] ];\r\n                    i = 2*i + 1;\r\n                } else {\r\n                    [ this.heap[2*i+2], this.heap[i] ] = [ this.heap[i] , this.heap[2*i+2] ];\r\n                    i = 2*i + 2;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return minValue;\r\n    }\r\n};\r\n\r\nclass disjointSet {\r\n    constructor() {\r\n        this.dictionary = {};\r\n    }\r\n\r\n    makeSet(x) {\r\n        if (this.dictionary.hasOwnProperty(x)) return;\r\n        else {\r\n            this.dictionary[x] = {\r\n                parent: x,\r\n                size: 1\r\n            }\r\n        }\r\n    }\r\n\r\n    find(y) {\r\n        // using path splitting to improve performance\r\n        let x = y;\r\n        while (this.dictionary[x].parent !== x) {\r\n            let parent = this.dictionary[x].parent;\r\n            let grandparent = this.dictionary[parent].parent;\r\n            [ x , this.dictionary[x].parent ] = [ parent , grandparent ];\r\n        }\r\n        return x;\r\n    }\r\n\r\n    union(x,y) {\r\n        // using size, again to improve performance\r\n        let xRoot = this.find(x);\r\n        let yRoot = this.find(y);\r\n        if (xRoot === yRoot) return;\r\n        if (this.dictionary[xRoot].size < this.dictionary[yRoot]) {\r\n            [ xRoot , yRoot ] = [ yRoot , xRoot ];\r\n        }\r\n        this.dictionary[yRoot].parent = xRoot;\r\n        this.dictionary[xRoot].size += this.dictionary[yRoot].size;\r\n    }\r\n};\r\n\r\nfunction shuffleArray(array) {\r\n    let arrayCopy = array.slice();\r\n    for (let i = arrayCopy.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [arrayCopy[i], arrayCopy[j]] = [arrayCopy[j], arrayCopy[i]];\r\n    }\r\n    return arrayCopy;\r\n};\r\n\r\n\r\n//=====================================================================================//\r\n// Exports //\r\n//=====================================================================================//\r\nexport {isSameNode, nodeInPath, addNodes, nodeOnBoard, isValidNode, findNeighbors, manhattanDistance};      // node functions\r\nexport {dotProduct, scalarProd, vectorDiff, vectorSum, vectorMag, vectorOrthoMag, vectorAngle};             // vector functions\r\nexport {minHeap, disjointSet, shuffleArray};                                                                // algorithm data structures\r\n","import {isSameNode, nodeOnBoard, manhattanDistance, scalarProd, vectorSum, vectorDiff} from './utils';\r\n\r\n//=====================================================================================//\r\n// Canvas Mouse and Touch Trackers for Drawing and Manipulating Board //\r\n//=====================================================================================//\r\nfunction onMouseDown(downEvent,state,canvasRef,setState) {\r\n    if (downEvent.button !== 0) return;\r\n    let canvas = canvasRef.current;\r\n    let node = getPointerNode(downEvent,canvas,state.s,state.xOffset,state.yOffset);\r\n    let origNode = node;\r\n    let onMove, onMoveType;\r\n    if (isSameNode(node,state.startNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) =>\r\n        moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 1;\r\n    } else if (isSameNode(node,state.targetNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) => \r\n        moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 2;\r\n    } else {\r\n        drawLine(node,node,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        onMove = (startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) => \r\n        drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits);\r\n        onMoveType = 0;\r\n    }\r\n    let move = (moveEvent) => {\r\n        if (moveEvent.buttons === 0) {\r\n            canvas.removeEventListener(\"mousemove\", move);\r\n            let board = {};\r\n            if (onMoveType === 1) {\r\n                let oldStart = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n                let newStart = {[[node.i,node.j]]: {node:node,type:'start',fill:'white',object:'start'}};\r\n                Object.assign(board, state.board, oldStart, newStart);\r\n                setState({board:board});\r\n            } else if (onMoveType === 2) {\r\n                let oldTarget = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n                let newTarget = {[[node.i,node.j]]: {node:node,type:'target',fill:'white',object:'target'}};\r\n                Object.assign(board, state.board, oldTarget, newTarget);\r\n                setState({board:board});\r\n            }\r\n        } else {\r\n            let newNode = getPointerNode(moveEvent,canvas,state.s,state.xOffset,state.yOffset);\r\n            if (isSameNode(newNode,node)) return;\r\n            if ( \r\n                    (onMoveType !== 0 && !nodeOnBoard(newNode,state.xUnits,state.yUnits))\r\n                ||  (onMoveType === 1 && isSameNode(newNode,state.targetNode))\r\n                ||  (onMoveType === 2 && isSameNode(newNode,state.startNode))\r\n            ) return;\r\n            onMove(node,newNode,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n                (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n            node = newNode;\r\n        }\r\n    };\r\n    canvas.addEventListener(\"mousemove\", move);\r\n};\r\n\r\n\r\nfunction onTouchStart(startEvent,state,canvasRef,setState) {\r\n    let canvas = canvasRef.current;\r\n    let node = getPointerNode(startEvent.touches[0],canvas,state.s,state.xOffset,state.yOffset);\r\n    let origNode = node;\r\n    let onMove, onMoveType;\r\n    if (isSameNode(node,state.startNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) =>\r\n        moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 1;\r\n    } else if (isSameNode(node,state.targetNode)) {\r\n        onMove = (oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) => \r\n        moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState);\r\n        onMoveType = 2;\r\n    } else {\r\n        drawLine(node,node,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        onMove = (startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) => \r\n        drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits);\r\n        onMoveType = 0;\r\n    }\r\n    let move = (moveEvent) => {\r\n        let newNode = getPointerNode(moveEvent.touches[0],canvas,state.s,state.xOffset,state.yOffset);\r\n        if (isSameNode(newNode,node)) return;\r\n        if ( \r\n                (onMoveType !== 0 && !nodeOnBoard(newNode,state.xUnits,state.yUnits))\r\n            ||  (onMoveType === 1 && isSameNode(newNode,state.targetNode))\r\n            ||  (onMoveType === 2 && isSameNode(newNode,state.startNode))\r\n        ) return;\r\n        onMove(node,newNode,state.s,state.lineWidth,state.xOffset,state.yOffset,canvasRef,state,\r\n            (stateUpdate) => setState(stateUpdate),state.xUnits,state.yUnits);\r\n        node = newNode;\r\n    };\r\n    let end = (endEvent) => {\r\n        canvas.removeEventListener(\"touchmove\", move);\r\n        canvas.removeEventListener(\"touchend\", end);\r\n        let board = {};\r\n        if (onMoveType === 1) {\r\n            let oldStart = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n            let newStart = {[[node.i,node.j]]: {node:node,type:'start',fill:'white',object:'start'}};\r\n            Object.assign(board, state.board, oldStart, newStart);\r\n            setState({board:board});\r\n        } else if (onMoveType === 2) {\r\n            let oldTarget = {[[origNode.i,origNode.j]]: {node:origNode,type:'empty',fill:'white',object:null}};\r\n            let newTarget = {[[node.i,node.j]]: {node:node,type:'target',fill:'white',object:'target'}};\r\n            Object.assign(board, state.board, oldTarget, newTarget);\r\n            setState({board:board});\r\n        }\r\n    }\r\n    canvas.addEventListener(\"touchmove\", move);\r\n    canvas.addEventListener(\"touchend\", end);\r\n};\r\n\r\n//=====================================================================================//\r\n// Canvas Tools //\r\n//=====================================================================================//\r\nfunction drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) {\r\n    // Initialize object for storing updates to the canvas\r\n    let canvasUpdates = {};\r\n    // Get Manhatton Distance from startNode to endNode\r\n    const N = manhattanDistance(startNode,endNode);\r\n    //Get equation of line from startNode to endNode\r\n    const [ startPos , endPos ] = [ calcHexCenter(startNode,s,xOffset,yOffset) , calcHexCenter(endNode,s,xOffset,yOffset) ];\r\n    const V = vectorDiff(endPos,startPos);\r\n    const line = (n) => {\r\n        if (N === 0) return startPos;\r\n        else return vectorSum( scalarProd(n/N,V) , startPos );\r\n    }\r\n    // Sample N+1 points along line and fill in hexs these points lie in; however, break the loop if we go off the board\r\n    // Also don't fill in the node if it is the startNode or targetNode\r\n    for (let n = 0; n <= N; n++) {\r\n        const pos = line(n);\r\n        const node = nearestHex(pos,s,xOffset,yOffset);\r\n        //console.log(n);\r\n        //console.log(pos);\r\n        //console.log(node);\r\n        if (!nodeOnBoard(node,xUnits,yUnits)) break;\r\n        if (isSameNode(node,state.startNode) || isSameNode(node,state.targetNode)) continue;\r\n        // Fill in hex according to selected tool\r\n        if (state.tool === 0 && state.board[[node.i,node.j]].type !== 'wall') {\r\n            Object.assign(canvasUpdates, {[[node.i,node.j]]: {node:node,type:'wall',fill:'#282c34',object:null,angle:null}});\r\n        } else if (state.tool === 1 && state.board[[node.i,node.j]].type !== 'weight') {\r\n            Object.assign(canvasUpdates, {[[node.i,node.j]]: {node:node,type:'weight',fill:'white',object:'weight',angle:null}});\r\n        } else if (state.tool === 2 && state.board[[node.i,node.j]].type !== 'empty') {\r\n            Object.assign(canvasUpdates, {[[node.i,node.j]]: {node:node,type:'empty',fill:'white',object:null,angle:null}});\r\n        }\r\n    }\r\n    // Update state\r\n    setState((prevState) => {\r\n        return {\r\n                    board: Object.assign({},prevState.board,canvasUpdates),\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\n// Old drawLine. Not quite as efficient as new one, or easy to understand\r\n/*\r\nfunction drawLine(startNode,endNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState,xUnits,yUnits) {\r\n    // Setting start of path\r\n    let currentNode = startNode;\r\n    let V = nodeDistance(endNode,startNode,s,xOffset,yOffset);\r\n    // Fill start if not off board and not start/target node\r\n    let canvasUpdates = {};\r\n    if (nodeOnBoard(currentNode,xUnits,yUnits) &&  !isSameNode(currentNode,state.startNode) &&  !isSameNode(currentNode,state.targetNode)\r\n    ) {\r\n        // might be a problem that currentNode changes over time\r\n        if (state.tool === 0) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'wall',fill:'#282c34',object:null}});\r\n        } else if (state.tool === 1) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'weight',fill:'white',object:'weight'}});\r\n        } else if (state.tool === 2) {\r\n            Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'empty',fill:'white',object:null}});\r\n        }\r\n    }\r\n    // Looping over path\r\n    while (!isSameNode(currentNode,endNode)) {\r\n        // Reset minDis\r\n        let minDis = Infinity;\r\n        // Find next hex to move to by looping over adjacent hexs\r\n        let neighbors = findNeighbors(currentNode);\r\n        let tempNode = Object.assign({},currentNode);\r\n        for (let neighbor of neighbors) {\r\n            let v = nodeDistance(neighbor,tempNode,s,xOffset,yOffset);\r\n            let dotProd = dotProduct(v,V);\r\n            if (dotProd >= 0) {\r\n                v = nodeDistance(neighbor,startNode,s,xOffset,yOffset);\r\n                let currentDis = vectorOrthoMag(v,V);\r\n                if (currentDis < minDis) {\r\n                    currentNode = neighbor;\r\n                    minDis = currentDis;\r\n                }\r\n            }\r\n        }\r\n        // If next hex off board then end path\r\n        if (!nodeOnBoard(currentNode,xUnits,yUnits)) break;\r\n        // Fill next hex unless it is start or target node\r\n        else if (!isSameNode(currentNode,state.startNode) && !isSameNode(currentNode,state.targetNode)) {\r\n            // might be a problem that currentNode changes over time\r\n            if (state.tool === 0) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'wall',fill:'#282c34',object:null}});\r\n            } else if (state.tool === 1) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'weight',fill:'white',object:'weight'}});\r\n            } else if (state.tool === 2) {\r\n                Object.assign(canvasUpdates, {[[currentNode.i,currentNode.j]]: {node:currentNode,type:'empty',fill:'white',object:null}});\r\n            }\r\n        }\r\n    }\r\n    // Update state\r\n    setState((prevState) => {\r\n        return {\r\n                    board: Object.assign({},prevState.board,canvasUpdates),\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n*/\r\n\r\nfunction moveStart(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) {\r\n    let angle = 0;\r\n    if (state.xUnits > state.yUnits) angle = -Math.PI/2;\r\n    let canvasUpdates = {[[newNode.i,newNode.j]]: {node:newNode,type:'start',fill:'white',object:'start',angle:angle}};             \r\n    const oldState = Object.assign({}, state.board[[oldNode.i,oldNode.j]]);\r\n    if (oldState.type === 'start') {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: {node:oldNode,type:'empty',fill:'white',object:null}});\r\n    } else {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: oldState});\r\n    }\r\n    setState((prevState) => {\r\n        return {\r\n                    startNode: newNode,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\nfunction moveTarget(oldNode,newNode,s,lineWidth,xOffset,yOffset,canvasRef,state,setState) {\r\n    let canvasUpdates = {[[newNode.i,newNode.j]]: {node:newNode,type:'target',fill:'white',object:'target'}};             \r\n    const oldState = Object.assign({}, state.board[[oldNode.i,oldNode.j]]);\r\n    if (oldState.type === 'target') {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: {node:oldNode,type:'empty',fill:'white',object:null}});\r\n    } else {\r\n        Object.assign(canvasUpdates, {[[oldNode.i,oldNode.j]]: oldState});\r\n    }\r\n    setState((prevState) => {\r\n        return {\r\n                    targetNode: newNode,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: canvasUpdates\r\n        }\r\n    });\r\n};\r\n\r\nfunction clearBoard(id,canvasRef,state,setState) {\r\n    if (id === 0) {\r\n        let canvas = canvasRef.current;\r\n        let cx = canvas.getContext('2d');\r\n        cx.clearRect(0,0,canvas.width,canvas.height);\r\n        let [board, startNode, targetNode] = initializeBoard(canvas.width, canvas.height, state.s);\r\n        setState((prevState) => {\r\n            return {\r\n                        board: board, \r\n                        startNode: startNode, \r\n                        targetNode: targetNode, \r\n                        canvasUpdates: board,\r\n                        updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    } else if (id === 4) {\r\n        let canvas = canvasRef.current;\r\n        let cx = canvas.getContext('2d');\r\n        cx.clearRect(0,0,canvas.width,canvas.height);\r\n        let { innerWidth: width, innerHeight: height } = window\r\n        let canvasHeight;\r\n        if (width < 481 || height < 481)  {\r\n            if ( width > height) canvasHeight = height*.85;\r\n            else canvasHeight = height*.8;\r\n        }\r\n        else canvasHeight = height*.9-4;\r\n        let canvasWidth = width;\r\n        let {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset} = initializeCanvas(canvasWidth,canvasHeight,state.s);\r\n        // Setting Initial State\r\n        setState((prevState) => {\r\n            return {\r\n                canvasWidth: canvasWidth,\r\n                canvasHeight: canvasHeight,\r\n                board: board,\r\n                startNode: startNode,\r\n                targetNode: targetNode,\r\n                xUnits: xUnits,\r\n                yUnits: yUnits,\r\n                xOffset: xOffset,\r\n                yOffset: yOffset,\r\n                canvasUpdates: board,\r\n                updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    } else {\r\n        let canvasUpdates = {};\r\n        if (id === 1) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (!['white','#282c34'].includes(currentState.fill)) {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{fill:'white'});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n            Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n        } else if (id === 2) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (currentState.type === 'wall') {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{type:'empty',fill:'white',object:null});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n        } else if (id === 3) {\r\n            for (let key in state.board) {\r\n                let currentState = state.board[key];\r\n                if (currentState.type === 'weight') {\r\n                    let node = parseKey(key);\r\n                    let newState = Object.assign({},currentState,{type:'empty',fill:'white',object:null});\r\n                    Object.assign(canvasUpdates, {[[node.i,node.j]]: newState});\r\n                }\r\n            }\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        board: Object.assign({},prevState.board,canvasUpdates), \r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID + 1\r\n            };\r\n        });\r\n    }\r\n};\r\n\r\nfunction doTheJohnWall(state,setState) {\r\n    let canvasUpdates = {};\r\n    for (let key in state.board) {\r\n        Object.assign(canvasUpdates, {[key]: {node:parseKey(key), type:'wall', fill:'#282c34'}});\r\n    }\r\n    Object.assign(canvasUpdates, {[[state.startNode.i,state.startNode.j]]: state.board[[state.startNode.i,state.startNode.j]]});\r\n    Object.assign(canvasUpdates, {[[state.targetNode.i,state.targetNode.j]]: state.board[[state.targetNode.i,state.targetNode.j]]});\r\n    setState((prevState) => {\r\n        return {\r\n                    board: canvasUpdates, \r\n                    canvasUpdates: canvasUpdates,\r\n                    updateID: prevState.updateID + 1\r\n        };\r\n    });\r\n}\r\n\r\n//=====================================================================================//\r\n// Basic Drawing Functions //\r\n//=====================================================================================//\r\nfunction drawSearch(node,s,lineWidth,xOffset,yOffset,canvasRef,board,color) {\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    let state = board[[node.i,node.j]];\r\n    sleep(0).then(() => {\r\n        if (state === 'weight') {\r\n            drawWeight(pos,s,lineWidth,canvasRef,color);\r\n        } else {\r\n            fillHex(pos,s,color,canvasRef);\r\n            drawHex(pos,s,lineWidth,canvasRef)\r\n        }\r\n    });\r\n};\r\n\r\nfunction drawWeight(node,s,lineWidth,xOffset,yOffset,canvasRef){\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    let sideLength = s*.9;\r\n    let h = sideLength;\r\n    let w1 = sideLength;\r\n    let w2 = 1.5*sideLength;\r\n    let rw = sideLength*.18;\r\n    let r1 = sideLength*.33;\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    // draw trapezoid\r\n    let path = [\r\n                    {x:w1/2  , y:-h/2},\r\n                    {x:-w1/2 , y:-h/2},\r\n                    {x:-w2/2 , y:h/2},\r\n                    {x:w2/2  , y:h/2}\r\n    ]\r\n    cx.beginPath();\r\n    cx.fillStyle = 'black';\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i = 1; i < path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n    // draw ring\r\n    cx.beginPath();\r\n    let ringCenter = {x:pos.x, y:pos.y - h/2};\r\n    cx.lineWidth = rw;\r\n    cx.arc(ringCenter.x, ringCenter.y, r1, 0, 7);\r\n    cx.stroke();\r\n};\r\n\r\nfunction drawStart(startNode,s,xOffset,yOffset,canvasRef,angle) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    const r = .85;\r\n    const a = s*Math.sqrt(3)*r/2;\r\n    const b = a/1.3;\r\n    const c = a/2.6;\r\n    let path = [\r\n                { x:a    ,  y:0},\r\n                { x:-2*c ,  y:b},\r\n                { x:-c   ,  y:0},\r\n                { x:-2*c ,  y:-b}\r\n    ];\r\n    if (angle) {\r\n        for (let i=0; i<path.length; i++) {\r\n            let oldPos = path[i];\r\n            let newPos = {\r\n                x: oldPos.x*Math.cos(angle) - oldPos.y*Math.sin(angle),\r\n                y: oldPos.x*Math.sin(angle) + oldPos.y*Math.cos(angle)\r\n            }\r\n            path[i] = newPos;\r\n        }\r\n    }\r\n    let pos = calcHexCenter(startNode,s,xOffset,yOffset);\r\n    cx.fillStyle = 'black';\r\n    cx.beginPath();\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction drawStartPos(pos,s,canvasRef,angle) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    const r = .85;\r\n    const a = s*Math.sqrt(3)*r/2;\r\n    const b = a/1.3;\r\n    const c = a/2.6;\r\n    let path = [\r\n                { x:a    ,  y:0},\r\n                { x:-2*c ,  y:b},\r\n                { x:-c   ,  y:0},\r\n                { x:-2*c ,  y:-b}\r\n    ];\r\n    if (angle) {\r\n        for (let i=0; i<path.length; i++) {\r\n            let oldPos = path[i];\r\n            let newPos = {\r\n                x: oldPos.x*Math.cos(angle) - oldPos.y*Math.sin(angle),\r\n                y: oldPos.x*Math.sin(angle) + oldPos.y*Math.cos(angle)\r\n            }\r\n            path[i] = newPos;\r\n        }\r\n    }\r\n    cx.fillStyle = 'black';\r\n    cx.beginPath();\r\n    cx.moveTo(pos.x + path[0].x, pos.y + path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(pos.x + path[i].x, pos.y + path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction drawTarget(targetNode,s,lineWidth,xOffset,yOffset,canvasRef) {\r\n    const sideLength = s;\r\n    let pos = calcHexCenter(targetNode,s,xOffset,yOffset);\r\n    // Outer Ring\r\n    fillHex(pos,sideLength,'#b22222',canvasRef);\r\n    // White Fill\r\n    fillHex(pos,sideLength*2/3 - lineWidth/2,'white',canvasRef);\r\n    // Inner Ring\r\n    fillHex(pos,sideLength/3,'#b22222',canvasRef);\r\n    // Remake Border\r\n    drawHex(pos,sideLength,lineWidth,canvasRef);\r\n};\r\n\r\nfunction drawNode(node,s,lineWidth,xOffset,yOffset,color,canvasRef) {\r\n    let pos = calcHexCenter(node,s,xOffset,yOffset);\r\n    fillHex(pos,s,color,canvasRef);\r\n    drawHex(pos,s,lineWidth,canvasRef);\r\n};\r\n\r\n\r\n//=====================================================================================//\r\n// Helper Functions //\r\n//=====================================================================================//\r\n\r\n// Helpers for Canvas Tools//\r\n//========================================//\r\nfunction drawHex(pos,s,lineWidth,canvasRef) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    let path = calcHexPath(pos,s);\r\n    cx.lineWidth = lineWidth;\r\n    cx.beginPath();\r\n    cx.moveTo(path[0].x,path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(path[i].x,path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.stroke();\r\n};\r\n\r\nfunction fillHex(pos,s,color,canvasRef) {\r\n    let canvas = canvasRef.current;\r\n    let cx = canvas.getContext('2d');\r\n    cx.fillStyle = color;\r\n    let path = calcHexPath(pos,s);\r\n    cx.beginPath();\r\n    cx.moveTo(path[0].x, path[0].y);\r\n    for (let i=1; i<path.length; i++) {\r\n        cx.lineTo(path[i].x,path[i].y);\r\n    }\r\n    cx.closePath();\r\n    cx.fill();\r\n};\r\n\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n};\r\n\r\nfunction getPointerNode(event,domNode,s,xOffset,yOffset) {\r\n    let rect = domNode.getBoundingClientRect();\r\n    let x = event.clientX - rect.left;\r\n    let y = event.clientY - rect.top;\r\n    return nearestHex({x:x,y:y},s,xOffset,yOffset);\r\n};\r\n\r\n// Functions That Peform Grid Calculations//\r\n//========================================//\r\nfunction calcHexCenter(node,s,xOffset,yOffset) {\r\n    const x = xOffset + (node.j + 1 - ((node.i+1)%2)/2)*s*Math.sqrt(3);\r\n    const y = yOffset + (1.5*node.i + 1)*s\r\n    return {x:x, y:y};\r\n};\r\n\r\nfunction nodeDistance(node1,node2,s,xOffset,yOffset) {\r\n    let pos1 = calcHexCenter(node1,s,xOffset,yOffset);\r\n    let pos2 = calcHexCenter(node2,s,xOffset,yOffset);\r\n    return {x:(pos1.x - pos2.x) , y:(pos1.y - pos2.y)};\r\n};\r\n\r\nfunction nearestHex(pos,s,xOffset,yOffset) {\r\n    const J = Math.floor((pos.x - xOffset)/(s*Math.sqrt(3)));\r\n    const I = Math.floor((pos.y - yOffset)/(1.5*s));\r\n    const u = (pos.x - xOffset)/(s*Math.sqrt(3)) - J;\r\n    const v = 1 - ((pos.y - yOffset)/(1.5*s) - I);\r\n    let i, j;\r\n    if (I%2 === 0) {\r\n        if (u < .5) {\r\n            if (v > (2/3*u + 2/3)) {\r\n                [ i , j ] = [ I-1 , J-1 ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        } else {\r\n            if (v > (-2/3*u + 4/3)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        }\r\n    } else {\r\n        if (u < .5) {\r\n            if (v > (-2/3*u + 1)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J-1 ];\r\n            }\r\n        } else {\r\n            if (v > (2/3*u + 1/3)) {\r\n                [ i , j ] = [ I-1 , J ];\r\n            } else {\r\n                [ i , j ] = [ I , J ];\r\n            }\r\n        }\r\n    }\r\n    return {i:i,j:j};\r\n};\r\n\r\nfunction calcHexPath(pos, s) {\r\n    let path = [];\r\n    for (let theta = Math.PI/6; theta < 2*Math.PI; theta += Math.PI/3) {\r\n        const x = pos.x + s*Math.cos(theta);\r\n        const y = pos.y + s*Math.sin(theta);\r\n        path.push({x:x, y:y});\r\n    }\r\n    return path;\r\n};\r\n\r\nfunction calcUnits(canvasWidth, canvasHeight, s) {\r\n    /*\r\n    const xUnits = Math.floor(canvasHeight/(1.5*s) - .5);\r\n    const yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)) - .5);\r\n    const xOffset = (canvasWidth - (yUnits + .5)*s*Math.sqrt(3))/2;\r\n    const yOffset = (canvasHeight - (xUnits*1.5 + .5)*s)/2;\r\n    */\r\n    const xUnits = Math.max(Math.floor((canvasHeight - s/2)/(1.5*s)),1);\r\n    let yUnits, xOffset, yOffset;\r\n    if (xUnits === 1) {\r\n        yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)));\r\n        xOffset = (canvasWidth - yUnits*s*Math.sqrt(3))/2;\r\n        yOffset = (canvasHeight - xUnits*2*s)/2;\r\n    } else {\r\n        yUnits = Math.floor(canvasWidth/(s*Math.sqrt(3)) - .5);\r\n        xOffset = (canvasWidth - (yUnits + .5)*s*Math.sqrt(3))/2;\r\n        yOffset = (canvasHeight - (xUnits*1.5 + .5)*s)/2;\r\n    }    \r\n    return [xUnits,yUnits,xOffset,yOffset];\r\n};\r\n\r\nfunction initializeBoard(canvasWidth, canvasHeight, s) {   \r\n    let [xUnits,yUnits] = calcUnits(canvasWidth, canvasHeight, s);\r\n    let board = {};\r\n    for (let i = 0; i < xUnits; i++) {\r\n        for (let j = 0; j < yUnits; j++) {\r\n            Object.assign(board, {[[i,j]]: {node:{i:i,j:j}, type:'empty', fill:'white', object:null}})\r\n        }\r\n    }\r\n    let startNode, targetNode, offset;\r\n    if (xUnits > yUnits) {\r\n        offset = Math.floor(xUnits*.25);\r\n        startNode = {i: xUnits-1-offset, j: Math.floor(yUnits/2)};\r\n        targetNode = {i: offset, j: Math.floor(yUnits/2)};\r\n    } else {\r\n        offset = Math.floor(yUnits*.25);\r\n        startNode = {i: Math.floor(xUnits/2), j: offset};\r\n        targetNode = {i: Math.floor(xUnits/2), j: yUnits-1-offset};\r\n    }\r\n    let angle = 0;\r\n    if (xUnits > yUnits) angle = -Math.PI/2;\r\n    Object.assign(board[[startNode.i,startNode.j]], {type: 'start', object:'start', angle:angle});\r\n    Object.assign(board[[targetNode.i,targetNode.j]], {type: 'target', object:'target'});\r\n    return [board, startNode, targetNode];\r\n};\r\n\r\nfunction initializeCanvas(canvasWidth,canvasHeight,s) {\r\n    let [xUnits,yUnits,xOffset,yOffset] = calcUnits(canvasWidth, canvasHeight, s);\r\n    console.log([xUnits,yUnits,xOffset,yOffset]);\r\n    let [board, startNode, targetNode] = initializeBoard(canvasWidth, canvasHeight, s);\r\n    let lineWidth = s/10;\r\n    return {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset,lineWidth};\r\n}\r\n\r\nfunction parseKey(key) {\r\n    let [i,j] = key.split(',').map((item) => parseInt(item));\r\n    return {i:i,j:j};\r\n};\r\n\r\n//=====================================================================================//\r\n// Exports //\r\n//=====================================================================================//\r\nexport {getPointerNode, onMouseDown, onTouchStart}\r\nexport {drawSearch, drawLine, moveStart, moveTarget, clearBoard, doTheJohnWall}\r\nexport {drawWeight, drawStart, drawStartPos, drawTarget, drawNode, drawHex, fillHex};\r\nexport {sleep, calcHexCenter, nodeDistance, nearestHex, calcHexPath, calcUnits, initializeBoard, initializeCanvas, parseKey};","import React from 'react';\r\nimport {initializeBoard, drawWeight, drawStart, drawStartPos, drawTarget, drawNode} from '../utils/canvas-tools';\r\n\r\n/*\r\n// To Do //\r\n//========================================================================================//\r\n-- Make new drawWeight function that takes node as imput instead of pos\r\n\r\n//========================================================================================//\r\n*/\r\n\r\n\r\nclass Canvas extends React.Component {\r\n    componentDidMount() {\r\n        let [board] = initializeBoard(this.props.width, this.props.height, this.props.s);\r\n        for (let key in board) {\r\n            let {node, fill, object, angle} = board[key];\r\n            this.updateNode(node, fill, object, angle);\r\n        }\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps) {\r\n        if (nextProps.updateID === this.props.updateID) return false;\r\n        else return true;\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (this.props.s !== prevProps.s) {\r\n            let canvas = this.props.canvasRef.current;\r\n            let cx = canvas.getContext('2d');\r\n            cx.clearRect(0,0,this.props.width,this.props.height);\r\n            this.componentDidMount();\r\n        } else {\r\n            for (let key in this.props.canvasUpdates) {\r\n                let {node, fill, object, angle} = this.props.canvasUpdates[key];\r\n                this.updateNode(node, fill, object, angle);\r\n            }\r\n            if (this.props.startPosition) {\r\n                let {pos,angle} = this.props.startPosition;\r\n                drawStartPos(pos,this.props.s,this.props.canvasRef,angle);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateNode(node,fill,object,angle) {\r\n        if (fill) {\r\n            drawNode(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, fill, this.props.canvasRef);\r\n        }\r\n        if (object) {\r\n            if (object === 'weight') {\r\n                drawWeight(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, this.props.canvasRef);\r\n            } else if (object === 'start') {\r\n                drawStart(node, this.props.s, this.props.xOffset, this.props.yOffset, this.props.canvasRef,angle);\r\n            } else if (object === 'target') {\r\n                drawTarget(node, this.props.s, this.props.lineWidth, this.props.xOffset, this.props.yOffset, this.props.canvasRef);\r\n            }\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <canvas\r\n                ref = {this.props.canvasRef}\r\n                width = {this.props.width}\r\n                height = {this.props.height}\r\n                onMouseDown={this.props.running ? null : (downEvent) => this.props.onMouseDown(downEvent)}\r\n                onTouchStart={this.props.running ? null : (startEvent) => this.props.onTouchStart(startEvent)}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default Canvas;","import {isSameNode, nodeOnBoard, isValidNode, findNeighbors, manhattanDistance, minHeap, shuffleArray, disjointSet} from './utils';\r\nimport { parseKey } from './canvas-tools';\r\n\r\n\r\n//=================================================================================================================================//\r\n// Path-Finding Algorithms //\r\n//=================================================================================================================================//\r\n\r\n\r\n// Unweighted Algorithms //\r\n//=======================//\r\nfunction depthFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.unshift(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction breadthFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.push(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction hillClimbing(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // sort nodes according to distance to target node (descending)\r\n        neighbors.sort((node1,node2) => manhattanDistance(node2,targetNode) - manhattanDistance(node1,targetNode));\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = currentPath.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add path extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.unshift(newPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction beamSearch(startNode,targetNode,xUnits,yUnits,board, w = 2) {\r\n    // initialize queue of paths and set of visited node\r\n    let queue = [[startNode]];\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length > 0) {\r\n        let currentPath = queue.shift();\r\n        let currentNode = currentPath[currentPath.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // sort nodes according to distance to target node (descending)\r\n        neighbors.sort((node1,node2) => manhattanDistance(node2,targetNode) - manhattanDistance(node1,targetNode));\r\n        // filter to valid nodes and keep only the first w number of them\r\n        neighbors = neighbors.filter(\r\n            (node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j))\r\n        ).slice(-w);\r\n        for (let newNode of neighbors) {\r\n            let newPath = currentPath.concat([newNode]);\r\n            // if we found target return the completed path and updates, else add path extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                return [newPath, searchUpdates];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.push(newPath);\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\nfunction bestFirst(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.distance < path2.distance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({distance:manhattanDistance(startNode,targetNode) , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        for (let newNode of neighbors) {\r\n            if (isValidNode(newNode,board,xUnits,yUnits) && !visitedNodes.has(newNode.i+','+newNode.j)) {\r\n                let newPath = path.concat([newNode]);\r\n                // if we found target return the completed path and updates, else add extended path to queue\r\n                if (isSameNode(newNode,targetNode)) {\r\n                    return [newPath, searchUpdates];\r\n                } else {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                    queue.insert({distance:manhattanDistance(newNode,targetNode) , path:newPath});\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\n\r\n// Weighted Algorithms //\r\n//=====================//\r\n// Dictionary below determines relative weight moving from one node to another.\r\n// Essentially moving through a weight is 10 times as difficult as an empty node.\r\nconst pathWeights = {'empty':1, 'weight':10, 'target':1};\r\n\r\nfunction branchNBound(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.distance < path2.distance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    let bestDistance = Infinity;\r\n    let bestPath = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            // if newDistance is not less than the bestDistance to the target so far, then drop the path from the queue\r\n            if (newDistance >= bestDistance) {\r\n                if (!isSameNode(newNode,targetNode)) {\r\n                    let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                    searchUpdates.push(newState);\r\n                }\r\n                continue;\r\n            };\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                [bestPath, bestDistance] = [newPath, newDistance];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({distance:newDistance , path:newPath});\r\n            }\r\n        }\r\n    }\r\n    // Return best path (which could be empty if no path found) and searchUpdates for animation\r\n    return [bestPath, searchUpdates];\r\n};\r\n\r\nfunction aStarSearch(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize queue of paths as minHeap and set of visited node\r\n    let lessThan = (path1,path2) => {return path1.estimatedDistance < path2.estimatedDistance;};\r\n    let queue = new minHeap(lessThan);\r\n    queue.insert({estimatedDistance:manhattanDistance(startNode,targetNode), distance:0 , path:[startNode]});\r\n    let visitedNodes = new Set();\r\n    let searchUpdates = [];\r\n    // iteratively extend paths in queue until no possible paths left or target found\r\n    while (queue.length() > 0) {\r\n        let {distance, path} = queue.shift();\r\n        let currentNode = path[path.length - 1];\r\n        // check that node has not been extended already, if so drop path, else add to set of visited nodes and updates\r\n        if (visitedNodes.has(currentNode.i+','+currentNode.j)) continue;\r\n        visitedNodes.add(currentNode.i+','+currentNode.j);\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) {\r\n            let newState = Object.assign({},board[[currentNode.i,currentNode.j]],{fill:'#6495ed'});\r\n            searchUpdates.push(newState);\r\n        }\r\n        // extend path by iterating over neighboring nodes (that are not walls or already extended)\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to valid nodes\r\n        neighbors = neighbors.filter((node) => (isValidNode(node,board,xUnits,yUnits) && !visitedNodes.has(node.i+','+node.j)));\r\n        for (let newNode of neighbors) {\r\n            let newPath = path.concat([newNode]);\r\n            let newDistance = distance + pathWeights[board[[newNode.i,newNode.j]].type];\r\n            // if we found target return the completed path and updates, else add extended path to queue\r\n            if (isSameNode(newNode,targetNode)) {\r\n                // extend other paths to be sure they aren't actually closer to the target (not sure about this part)\r\n                return [newPath, searchUpdates];\r\n            } else {\r\n                let newState = Object.assign({},board[[newNode.i,newNode.j]],{fill:'#4b0082'});\r\n                searchUpdates.push(newState);\r\n                queue.insert({\r\n                    estimatedDistance: newDistance + manhattanDistance(newNode,targetNode), \r\n                    distance:newDistance, \r\n                    path:newPath\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // Return empty path and updates if no path to target was found\r\n    return [[], searchUpdates];\r\n};\r\n\r\n\r\n//=================================================================================================================================//\r\n// Maze Building Algorithms //\r\n//=================================================================================================================================//\r\nfunction randomWalls(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iterate over whole board and randomly generate walls (with P(wall) = .50)\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) continue;\r\n        if (Math.random() < .45) {\r\n            mazePath.push({node:node, type:'wall', fill:'#282c34'})\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction randomWeights(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iterate over whole board and randomly generate walls (with P(wall) = .50)\r\n    for (let key in board) {\r\n        let node = parseKey(key);\r\n        if (isSameNode(node,startNode) || isSameNode(node,targetNode)) continue;\r\n        if (Math.random() < .45) {\r\n            mazePath.push({node:node, type:'weight', fill:'white', object:'weight'})\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction depthFirstMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array\r\n    let queue = [start];\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to next node on the queue\r\n        const currentNode = queue.shift();\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // shuffle array to randomize order\r\n        neighbors = shuffleArray(neighbors);\r\n        // initialize array for adding the new nodes to queue (this lets us control the order in case the start or target node are encountered\r\n        // since we want to immediately extend these nodes to ensure a perfect path)\r\n        let nodesToAdd = [];\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) nodesToAdd.unshift(node);\r\n            else nodesToAdd.push(node);\r\n        }\r\n        queue = nodesToAdd.concat(queue);\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction breadthFirstMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array\r\n    let queue = [start];\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to next node on the queue\r\n        const currentNode = queue.shift();\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // shuffle array to randomize order\r\n        neighbors = shuffleArray(neighbors);\r\n        // add new nodes to queue, putting them at the end unless they are the start or target node (this ensures the start and target always get\r\n        // extended immediately which preserves the perfect maze condition)\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) queue.unshift(node);\r\n            else queue.push(node);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction kruskalsMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize list of unvisited nodes which we will visit in a randomized order; however, start and target nodes will be placed at the front to ensure\r\n    // a perfect maze is generated\r\n    let unVisitedNodes = [];\r\n    for (let key in board) {\r\n        if (!isSameNode(parseKey(key),startNode) && !isSameNode(parseKey(key),targetNode)) unVisitedNodes.push(key);\r\n    }\r\n    unVisitedNodes = shuffleArray(unVisitedNodes);\r\n    unVisitedNodes.unshift(startNode.i+','+startNode.j);\r\n    unVisitedNodes.unshift(targetNode.i+','+targetNode.j);\r\n    // initialize set to keep track of nodes added to the path\r\n    let pathNodes = new Set();\r\n    // initialize disjoint set to keep track of the disjoint paths\r\n    let disjointPaths = new disjointSet();\r\n    // lastly initialize array for storing mazePath updates for animation\r\n    let mazePath = [];\r\n    // iteratively look at each node in unVisited nodes, checking to see if it can be added to the path\r\n    for (let currentNode of unVisitedNodes) {\r\n        // get neighboring nodes and convert node to string\r\n        let neighbors = findNeighbors(parseKey(currentNode)).map((node) => (node.i+','+node.j));\r\n        // filter to neighbors that are on the board and are part of a path\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(parseKey(node),xUnits,yUnits) && pathNodes.has(node)));\r\n        // get the roots of each of these neighbors\r\n        let roots = neighbors.map((node) => disjointPaths.find(node));\r\n        // get the unique roots\r\n        let rootsSet = new Set(roots);\r\n        // Condition below guarantees perfect maze, but would not guarantee all paths are joined (and thus not guarantee that there is a path from start to target)\r\n        //if (roots.length !== rootsSet.size) continue;\r\n        // Condition below guarantees all paths are joined, but does not guarantee a perfect maze\r\n        if (roots.length > 1 && rootsSet.size < 2) continue;\r\n        // else we make current node part of the pathNodes and union all the roots\r\n        pathNodes.add(currentNode);\r\n        if (!isSameNode(parseKey(currentNode),startNode) && !isSameNode(parseKey(currentNode),targetNode)) {\r\n            mazePath.push({node:parseKey(currentNode), type:'empty', fill:'white'});\r\n        }\r\n        disjointPaths.makeSet(currentNode);\r\n        for (let node of roots) {\r\n            disjointPaths.union(currentNode,node);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n}\r\n\r\nfunction primsMaze(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array and initialize values for keeping track of start and target nodes\r\n    let queue = [start];\r\n    let [ startFound , targetFound ] = [ false , false ];\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to random node on the queue, unless we have encountered the start or target node, in which case move to this node\r\n        // doing so ensures a perfect maze\r\n        let currentNode;\r\n        if (startFound) {\r\n            currentNode = queue.shift();\r\n            startFound = false;\r\n        }\r\n        else if (targetFound) {\r\n            currentNode = queue.shift();\r\n            targetFound = false;\r\n        } else {\r\n            const i = Math.floor(Math.random() * queue.length);\r\n            currentNode = queue[i];\r\n            queue = queue.slice(0,i).concat(queue.slice(i+1));\r\n        }\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // add new nodes to queue, putting them at the end unless they are the start or target node (this ensures the start and target always get\r\n        // extended immediately which preserves the perfect maze condition)\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode)) {\r\n                queue.unshift(node);\r\n                startFound = true;\r\n            } else if (isSameNode(node,targetNode)) {\r\n                queue.unshift(node);\r\n                targetFound = true;\r\n            }\r\n            else queue.push(node);\r\n        }\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\nfunction huntAndKill(startNode,targetNode,xUnits,yUnits,board) {\r\n    // initialize dictionary of nodes that keeps track of how many times each one was visited\r\n    // each time we check the node, add 1, and if we extend the node set to Infinity\r\n    let visitedNodes = {};\r\n    for (let node in board) {\r\n        visitedNodes[node] = 0;\r\n    }\r\n    // pick starting point at random\r\n    let start = {i: Math.floor(Math.random()*xUnits) , j: Math.floor(Math.random()*yUnits)};\r\n    // initialize queue as array and initialize variable to determine when to choose new random walk point\r\n    let queue = [start];\r\n    let newRandomWalk = false;\r\n    // initialize array to keep track of path for drawing maze\r\n    let mazePath = [];\r\n    // iteratively extend path until no more paths are left in the queue\r\n    while (queue.length > 0) {\r\n        // move to next node on the queue, unless we determined current path cannot be exteneded, in which case pick random node\r\n        let currentNode;\r\n        if (newRandomWalk) {\r\n            const i = Math.floor(Math.random() * queue.length);\r\n            currentNode = queue[i];\r\n            queue = queue.slice(0,i).concat(queue.slice(i+1));\r\n            newRandomWalk = false;\r\n        } else {\r\n            currentNode = queue.shift();\r\n        }\r\n        // if the node has already been extended or checked twice, then remove from queue and continue\r\n        // else we extend the node and update visitedNodes and mazePath\r\n        if (visitedNodes[[currentNode.i,currentNode.j]] >= 2) continue;\r\n        visitedNodes[[currentNode.i,currentNode.j]] = Infinity;\r\n        if (!isSameNode(currentNode,startNode) && !isSameNode(currentNode,targetNode)) mazePath.push({node:currentNode, type:'empty', fill:'white'});\r\n        // find the node's neighbors\r\n        let neighbors = findNeighbors(currentNode);\r\n        // filter to nodes on the board that have not already been extended or checked twice\r\n        neighbors = neighbors.filter((node) => (nodeOnBoard(node,xUnits,yUnits) && (visitedNodes[[node.i,node.j]] < 2)));\r\n        // shuffle array to randomize order\r\n        neighbors = shuffleArray(neighbors);\r\n        // initialize array for adding the new nodes to queue (this lets us control the order in case the start or target node are encountered\r\n        // since we want to immediately extend these nodes to ensure a perfect path)\r\n        let nodesToAdd = [];\r\n        for (let node of neighbors) {\r\n            visitedNodes[[node.i,node.j]]++\r\n            if (isSameNode(node,startNode) || isSameNode(node,targetNode)) nodesToAdd.unshift(node);\r\n            else nodesToAdd.push(node);\r\n        }\r\n        queue = nodesToAdd.concat(queue);\r\n        if (nodesToAdd.length === 0) newRandomWalk = true;\r\n    }\r\n    // return path used to build the maze for animations\r\n    return mazePath;\r\n};\r\n\r\n\r\nexport {depthFirst, breadthFirst, hillClimbing, beamSearch, bestFirst, branchNBound, aStarSearch};\r\nexport {randomWalls, randomWeights, depthFirstMaze, breadthFirstMaze, kruskalsMaze, primsMaze, huntAndKill}","import {\r\n    depthFirst, breadthFirst, hillClimbing, beamSearch, bestFirst, branchNBound, aStarSearch,\r\n    randomWalls, randomWeights, depthFirstMaze, breadthFirstMaze, kruskalsMaze, primsMaze, huntAndKill\r\n} from './algorithms';\r\nimport { calcHexCenter, nodeDistance } from './canvas-tools';\r\nimport { scalarProd, vectorSum, vectorDiff, vectorAngle } from './utils';\r\n\r\n\r\n\r\n//=================================================================================================================================//\r\n// Constants //\r\n//=================================================================================================================================//\r\n// mappings for speeds when animating search, drawPath, moveDownPath, victory, and drawMaze\r\nconst searchSpeed = {\r\n    0: 10,\r\n    1: 100,\r\n    2: 1000,\r\n    3: 10000,\r\n    4: Infinity\r\n};\r\nconst drawPathSpeed = {\r\n    0: 5,\r\n    1: 5**2,\r\n    2: 5**3,\r\n    3: 5**4,\r\n    4: Infinity\r\n};\r\nconst moveDownPathSpeed = {\r\n    0: 3,\r\n    1: 3**2,\r\n    2: 3**3,\r\n    3: 3**4,\r\n    4: Infinity\r\n};\r\nconst victorySpeed = {\r\n    0: 1.5*Math.PI,\r\n    1: 2*Math.PI,\r\n    2: 3*Math.PI,\r\n    3: 6*Math.PI,\r\n    4: Infinity\r\n};\r\nconst drawMazeSpeed = {\r\n    0: 6,\r\n    1: 6**2,\r\n    2: 6**3,\r\n    3: 6**4,\r\n    4: Infinity\r\n};\r\n\r\n\r\n//=================================================================================================================================//\r\n// Path-Finding Animations //\r\n//=================================================================================================================================//\r\nfunction pathFinderAnimation(state,canvasRef,setState,isRunning) {\r\n    // Set state to running so user can't interfere with pathFinder \r\n    setState((prevState) => ({\r\n        running: true, \r\n        updateID: prevState.updateID + 1\r\n    }));\r\n    let pathFinder;\r\n    switch (state.algorithm) {\r\n        case 0: pathFinder = depthFirst; break;\r\n        case 1: pathFinder = breadthFirst; break;\r\n        case 2: pathFinder = hillClimbing; break;\r\n        case 3: pathFinder = beamSearch; break;\r\n        case 4: pathFinder = bestFirst; break;\r\n        case 5: pathFinder = branchNBound; break;\r\n        case 6: pathFinder = aStarSearch; break;\r\n        default: pathFinder = breadthFirst;\r\n    };\r\n    let [path, searchUpdates] = pathFinder(state.startNode,state.targetNode,state.xUnits,state.yUnits,state.board);\r\n    searchAnimation(path,searchUpdates,state.s,state.xOffset,state.yOffset,state.speed,state.board,setState,isRunning);\r\n};\r\n\r\nfunction searchAnimation(path,searchUpdates,s,xOffset,yOffset,speed,board,setState,isRunning) {\r\n    let hexsPerSecond = searchSpeed[speed];\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = searchUpdates.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = searchUpdates.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                if (path.length > 0) drawPathAnimation(path,s,xOffset,yOffset,speed,board,setState,isRunning);\r\n                else {\r\n                    setState((prevState) => ({\r\n                        running: false,\r\n                        updateID: prevState.updateID + 1,\r\n                        canvasUpdates: [],\r\n                        startPosition: false\r\n                    }));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction drawPathAnimation(path,s,xOffset,yOffset,speed,board,setState,isRunning) {\r\n    let hexsPerSecond = drawPathSpeed[speed];\r\n    let pathUpdates = [];\r\n    for (let node of path.slice(1,-1)) {\r\n        pathUpdates.push(Object.assign({},board[[node.i,node.j]],{fill:'#b1fc40'}));\r\n    }\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = pathUpdates.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = pathUpdates.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                moveDownPathAnimation(path,s,xOffset,yOffset,speed,setState,isRunning);\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction moveDownPathAnimation(path,s,xOffset,yOffset,speed,setState,isRunning) {\r\n    let hexsPerSecond = moveDownPathSpeed[speed];\r\n    const totalSteps = path.length - 1;\r\n    const totalTime = totalSteps / hexsPerSecond * 1000;\r\n    let startTime = null;\r\n    let i = 0;\r\n    function updateAnimation(time) {\r\n        let [ prevStartNode , prevEndNode ] = [ path[i] , path[i+1] ];\r\n        i = Math.floor((time - startTime) / totalTime * totalSteps);\r\n        let pos, angle;\r\n        if (i < totalSteps) {\r\n            let [ startNode , endNode ] = [ path[i] , path[i+1] ];\r\n            let [ startPos , endPos ] = [ calcHexCenter(startNode,s,xOffset,yOffset) , calcHexCenter(endNode,s,xOffset,yOffset) ]\r\n            let V = vectorDiff(endPos,startPos);\r\n            let v = scalarProd((time - startTime) / totalTime * totalSteps - i, V);\r\n            pos = vectorSum(startPos, v);\r\n            angle = vectorAngle(V);\r\n        } else {\r\n            let [ startNode , endNode ] = [ path[path.length-2] , path[path.length-1] ];\r\n            let [ startPos , endPos ] = [ calcHexCenter(startNode,s,xOffset,yOffset) , calcHexCenter(endNode,s,xOffset,yOffset) ]\r\n            let V = vectorDiff(endPos,startPos);\r\n            pos = calcHexCenter(endPos);\r\n            angle = vectorAngle(V);\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        canvasUpdates: [\r\n                            Object.assign({}, prevState.board[[prevStartNode.i,prevStartNode.j]]),\r\n                            Object.assign({},  prevState.board[[prevEndNode.i,prevEndNode.j]])\r\n                        ],\r\n                        startPosition: Object.assign({},{pos:pos,angle:angle}),\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (startTime != null) {\r\n                updateAnimation(time);\r\n            } else {\r\n                startTime = time;\r\n            }\r\n            if ((time - startTime) < totalTime) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                victoryAnimation(path[path.length-1],path[path.length-2],speed,s,xOffset,yOffset,setState,isRunning);\r\n            }\r\n        } else {\r\n            let [ prevStartNode , prevEndNode ] = [ path[i] , path[i+1] ];\r\n            setState((prevState) => {\r\n                return {\r\n                            canvasUpdates: [\r\n                                Object.assign({}, prevState.board[[prevStartNode.i,prevStartNode.j]]),\r\n                                Object.assign({},  prevState.board[[prevEndNode.i,prevEndNode.j]])\r\n                            ],\r\n                            startPosition: false,\r\n                            updateID: prevState.updateID +1\r\n                };\r\n            });\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nfunction victoryAnimation(targetNode,prevNode,speed,s,xOffset,yOffset,setState,isRunning) {\r\n    const radiansPerSecond = victorySpeed[speed];\r\n    const targetPos = calcHexCenter(targetNode,s,xOffset,yOffset);\r\n    const startAngle = vectorAngle(nodeDistance(targetNode,prevNode,s,xOffset,yOffset));\r\n    const totalTime = 6*Math.PI / radiansPerSecond * 1000;\r\n    let startTime = null;\r\n    function updateAnimation(time) {\r\n        let angle;\r\n        if ((time - startTime) < totalTime) {\r\n            angle = startAngle + (time - startTime)/totalTime*6*Math.PI;\r\n        } else {\r\n            angle = startAngle + 6*Math.PI;\r\n        }\r\n        setState((prevState) => {\r\n            return {\r\n                        canvasUpdates: [ Object.assign({}, prevState.board[[targetNode.i,targetNode.j]]) ],\r\n                        startPosition: Object.assign({},{pos:targetPos,angle:angle}),\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (startTime != null) {\r\n                updateAnimation(time);\r\n            } else {\r\n                startTime = time;\r\n            }\r\n            if ((time - startTime) < totalTime) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                setState((prevState) => ({\r\n                    running: false,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: [],\r\n                    startPosition: false\r\n                }));\r\n            }\r\n        } else {\r\n            setState((prevState) => {\r\n                return {\r\n                            canvasUpdates: [ Object.assign({}, prevState.board[[targetNode.i,targetNode.j]]) ],\r\n                            startPosition: false,\r\n                            updateID: prevState.updateID +1\r\n                };\r\n            });\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\n\r\n//=================================================================================================================================//\r\n// Maze-Drawing Animations //\r\n//=================================================================================================================================//\r\nfunction mazeAnimation(mazeID,state,setState,isRunning) {\r\n    // Set state to running so user can't interfere with pathFinder \r\n    setState((prevState) => ({\r\n        running: true, \r\n        updateID: prevState.updateID + 1\r\n    }));\r\n    // Get path array of nodes to fill in for maze\r\n    let mazeBuilder;\r\n    switch (mazeID) {\r\n        case 0: mazeBuilder = randomWalls; break;\r\n        case 1: mazeBuilder = randomWeights; break;\r\n        case 2: mazeBuilder = depthFirstMaze; break;\r\n        case 3: mazeBuilder = breadthFirstMaze; break;\r\n        case 4: mazeBuilder = huntAndKill; break;\r\n        case 5: mazeBuilder = primsMaze; break;\r\n        case 6: mazeBuilder = kruskalsMaze; break;\r\n        default: mazeBuilder = depthFirstMaze;\r\n    };\r\n    let mazePath = mazeBuilder(state.startNode,state.targetNode,state.xUnits,state.yUnits,state.board);\r\n    // Set up parameters for animation\r\n    let hexsPerSecond = drawMazeSpeed[state.speed];\r\n    let lastTime = null;\r\n    let currentStart = 0;\r\n    let steps = 0;\r\n    const totalHexs = mazePath.length;\r\n    function updateAnimation(start,steps) {\r\n        setState((prevState) => {\r\n            let canvasUpdates = mazePath.slice(start,start+steps);\r\n            let boardUpdates = {};\r\n            for (let update of canvasUpdates) {\r\n                Object.assign(boardUpdates,{[[update.node.i,update.node.j]]: update});\r\n            }\r\n            return {\r\n                        board: Object.assign({},prevState.board,boardUpdates),\r\n                        canvasUpdates: canvasUpdates,\r\n                        updateID: prevState.updateID +1\r\n            };\r\n        });\r\n    };\r\n    function frame(time) {\r\n        if (isRunning()) {\r\n            if (lastTime != null) {\r\n                steps = Math.floor(hexsPerSecond * (time - lastTime) / 1000);\r\n                if (steps > 0) {\r\n                    updateAnimation(currentStart,steps);\r\n                    currentStart += steps;\r\n                    lastTime = time;\r\n                }\r\n            } else {\r\n                lastTime = time;\r\n            }\r\n            if (currentStart < totalHexs) {\r\n                requestAnimationFrame(frame);\r\n            } else {\r\n                setState((prevState) => ({\r\n                    running: false,\r\n                    updateID: prevState.updateID + 1,\r\n                    canvasUpdates: [],\r\n                    startPosition: false\r\n                }));\r\n            }\r\n        }\r\n    };\r\n    requestAnimationFrame(frame);\r\n};\r\n\r\nexport {pathFinderAnimation, mazeAnimation};","import React from 'react';\r\nimport ControlPanel from './ControlPanel';\r\nimport Canvas from './Canvas';\r\nimport {onMouseDown, onTouchStart, clearBoard, doTheJohnWall, initializeCanvas} from '../utils/canvas-tools';\r\nimport {pathFinderAnimation, mazeAnimation} from '../utils/animations';\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { faBars} from \"@fortawesome/free-solid-svg-icons\";\r\n\r\nclass PathFinder extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        let { innerWidth: width, innerHeight: height } = window\r\n        // Set Up Control Panel\r\n        let windowState = this.getWindowState();\r\n        let showControls = {1:false,2:false,3:true}[windowState]\r\n        // Setting Up Canvas\r\n        let canvasHeight;\r\n        if (windowState === 1) canvasHeight = height*.8;\r\n        else if (windowState === 2) canvasHeight = height*.85;\r\n        else canvasHeight = height*.9-4;\r\n        let canvasWidth = width;\r\n        this.canvasRef = React.createRef();\r\n        let s = 15;\r\n        let {board,startNode,targetNode,xUnits,yUnits,xOffset,yOffset,lineWidth} = initializeCanvas(canvasWidth,canvasHeight,s);\r\n        // Setting Initial State\r\n        this.state = {\r\n            windowState: this.getWindowState(),\r\n            showControls: showControls,\r\n            algorithm: 5,\r\n            speed: 2,\r\n            tool: 0,\r\n            canvasWidth: canvasWidth,\r\n            canvasHeight: canvasHeight,\r\n            s: s,\r\n            lineWidth: lineWidth,\r\n            board: board,\r\n            startNode: startNode,\r\n            targetNode: targetNode,\r\n            xUnits: xUnits,\r\n            yUnits: yUnits,\r\n            xOffset: xOffset,\r\n            yOffset: yOffset,\r\n            running: false,\r\n            canvasUpdates: [],\r\n            startPosition: false,\r\n            updateID: 0\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('resize', (event) => this.handleResize());\r\n    }\r\n\r\n    handleResize() {\r\n        let windowState = this.getWindowState();\r\n        if (windowState !== this.state.windowState) {\r\n            if ((windowState === 1 || windowState === 2) && (this.state.windowState === 3)) {\r\n                this.setState({windowState:windowState, showControls:false});\r\n            } else if ((windowState === 3) && (this.state.windowState === 1 || this.state.windowState === 2)) {\r\n                this.setState({windowState:windowState, showControls:true});\r\n            } else this.setState({windowState:windowState});\r\n        }\r\n    }\r\n\r\n    getWindowState() {\r\n        let { innerWidth: width, innerHeight: height } = window;\r\n        if (width < 481 || height < 481)  {\r\n            if ( width > height) return 2;\r\n            else return 1;\r\n        } else return 3;\r\n    }\r\n\r\n    toggleSelected(key,id) {\r\n        if (key !== 'clear') {\r\n            this.setState({\r\n                [key]:id\r\n            })\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    toggleControls() {\r\n        this.setState((prevState) => ({showControls: !prevState.showControls}));\r\n    }\r\n\r\n    startPathFinder() {\r\n        // Check to make sure not already running\r\n        if (this.state.running) return;\r\n        const setState = (stateUpdate) => this.setState(stateUpdate);\r\n        const isRunning = () => {return this.state.running;};\r\n        this.clearBoard(1);\r\n        pathFinderAnimation(this.state,this.canvasRef,setState,isRunning);\r\n    }\r\n\r\n    stopPathFinder() {\r\n        this.setState((prevState) => ({running:false, updateID:prevState.updateID+1}));\r\n    }\r\n\r\n    onMouseDown(downEvent) {\r\n        onMouseDown(downEvent,this.state,this.canvasRef,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    onTouchStart(startEvent) {\r\n        // This isn't working in Chrome. Chrome automatically sets scroll event to passive which dissallows preventDefault\r\n        // I could find a way to set event to active, so instead just disabling scroll for canvas in CSS.\r\n        // This however is leading to a bug where scroll gets re-enabled after user uses pinch zoom. No soultion found yet. \r\n        startEvent.preventDefault();\r\n        onTouchStart(startEvent,this.state,this.canvasRef,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    clearBoard(id) {\r\n        if (this.state.running) return;\r\n        clearBoard(id,this.canvasRef,this.state,(stateUpdate) => this.setState(stateUpdate));\r\n    }\r\n\r\n    changeHexSize(s) {\r\n        if (this.state.running || s === this.state.s) return;\r\n        this.setState((prevState) => {\r\n            // check that s is not too large\r\n            let hexSize;\r\n            console.log(s);\r\n            console.log(prevState.canvasWidth < prevState.canvasHeight);\r\n            console.log(prevState.canvasWidth);\r\n            console.log(prevState.canvasHeight);\r\n            console.log(prevState.canvasWidth > 1.5*Math.sqrt(3)*s && prevState.canvasHeight > 3.5*s);\r\n            console.log(prevState.canvasWidth > 2*Math.sqrt(3)*s && prevState.canvasHeight > 2*s);\r\n            if (prevState.canvasWidth < prevState.canvasHeight) {\r\n                if (prevState.canvasWidth > 1.5*Math.sqrt(3)*s && prevState.canvasHeight > 3.5*s) hexSize = s;\r\n                else hexSize = Math.min(prevState.canvasWidth/(1.5*Math.sqrt(3)),prevState.canvasHeight/(3.5));\r\n            } else {\r\n                if (prevState.canvasWidth > 2*Math.sqrt(3)*s && prevState.canvasHeight > 2*s) hexSize = s;\r\n                else hexSize = Math.min(prevState.canvasWidth/(2*Math.sqrt(3)),prevState.canvasHeight/(2));\r\n            }\r\n            console.log(hexSize);\r\n            return Object.assign(\r\n                {}, \r\n                initializeCanvas(prevState.canvasWidth,prevState.canvasHeight,hexSize),\r\n                {updateID: prevState.updateID + 1, canvasUpdates: [], s:hexSize}\r\n            );\r\n        });\r\n    }\r\n\r\n    drawMaze(id) {\r\n        if (this.state.running) return;\r\n        const setState = (stateUpdate) => this.setState(stateUpdate);\r\n        const isRunning = () => {return this.state.running;};\r\n        if (id === 0 || id === 1) this.clearBoard(0);\r\n        else doTheJohnWall(this.state,setState);\r\n        mazeAnimation(id,this.state,setState,isRunning);\r\n    }\r\n\r\n    render() {\r\n        const algorithmMap = {\r\n            0: \"Depth-First Search\",\r\n            1: \"Breadth-First Search\",\r\n            2: \"Hill Climbing\",\r\n            3: \"Beam Search (\\u03C9=2)\",\r\n            4: \"Best-First Search\",\r\n            5: \"Branch & Bound\",\r\n            6: \"A* Search\"\r\n        };\r\n        return (\r\n            <div className=\"PathFinder\">\r\n                <div className=\"Bars-Wrapper\">\r\n                    <FontAwesomeIcon className=\"bars\" icon={faBars} onClick={(event) => this.toggleControls()}/>\r\n                    <div className=\"Algorithm-Text\">{algorithmMap[this.state.algorithm]}</div>\r\n                </div>\r\n                <ControlPanel\r\n                    windowState={this.state.windowState}\r\n                    showControls={this.state.showControls}\r\n                    running={this.state.running}\r\n                    hexSize={this.state.s}\r\n                    toggleSelected={(key,id) => this.toggleSelected(key,id)}\r\n                    clearBoard={(id) => this.clearBoard(id)}\r\n                    changeHexSize={(s) => this.changeHexSize(s)}\r\n                    drawMaze={(id) => this.drawMaze(id)}\r\n                    startSearch={() => this.startPathFinder()}\r\n                    stopSearch={() => this.stopPathFinder()}\r\n                />\r\n                <Canvas\r\n                    className=\"canvas\"\r\n                    canvasRef={this.canvasRef}\r\n                    width={this.state.canvasWidth}\r\n                    height={this.state.canvasHeight}\r\n                    s={this.state.s}\r\n                    lineWidth={this.state.lineWidth}\r\n                    xOffset={this.state.xOffset}\r\n                    yOffset={this.state.yOffset}\r\n                    canvasUpdates={this.state.canvasUpdates}\r\n                    startPosition={this.state.startPosition}\r\n                    updateID={this.state.updateID}\r\n                    running={this.state.running}\r\n                    onMouseDown={(downEvent) => this.onMouseDown(downEvent)}\r\n                    onTouchStart={(startEvent) => this.onTouchStart(startEvent)}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathFinder;","import React from 'react';\nimport PathFinder from './components/PathFinder';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFinder />\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}